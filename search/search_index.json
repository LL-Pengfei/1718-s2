{
    "docs": [
        {
            "location": "/index.html",
            "text": "If you stumble upon this site via search engines, please note that this is an old site for CS2030 circa AY2017/18.  For AY2019/20 Semester 1, please access the module resources via \nLuminus\n and \nits Q&A forum via Piazza here\n\n\nAY 2017/18 Semester 2\n\n\n \nPiazza Q&A\n\n\n Labs and Assessments\n\n\n\u00a0\u00a0 \n \nFinal\n\n\n\u00a0\u00a0 \n \nMidterm\n\n\n\u00a0\u00a0 6. \nAsync Web API\n\n\n\u00a0\u00a0 5. \nMatrix Multiplication\n\n\n\u00a0\u00a0 4b. \nSimulator ver 2.1\n\n\n\u00a0\u00a0 4a. \nSimulator ver 2.0\n\n\n\u00a0\u00a0 3. \nInfinite List\n\n\n\u00a0\u00a0 2b. \nSimulator ver 1.3\n\n\n\u00a0\u00a0 2a. \nSimulator ver 1.2\n\n\n\u00a0\u00a0 1b. \nSimulator ver 1.1\n\n\n\u00a0\u00a0 1a. \nSimulator ver 1.0\n\n\n\u00a0\u00a0 0. \nWarm Up\n\n\n\n\n Lectures\n\n\n\u00a0\u00a012. Review (no notes)\u00a0\u00a0\n [\n\n (Extra: \nBuild a Monad\n)\n\n\n\u00a0\u00a011. \nGetting Asynchronous with CompletableFuture\n\u00a0\u00a0\n \n\n\n\u00a0\u00a010. \nParallel Streams\n\u00a0\u00a0\n \n\n\n\u00a0\u00a09. \nFunctionl-Style Patterns\n \u00a0\u00a0\n \n\n\n\u00a0\u00a08. \nStreams\n \u00a0\u00a0\n \n\n\n\u00a0\u00a07. \nFunctions\n \u00a0\u00a0\n \n\n\n\u00a0\u00a06. \nHash Code, Nested Class, Enum\n \u00a0\u00a0\n \n\n\n\u00a0\u00a05. \nGenerics and Collections\n \u00a0\u00a0\n \n\n\n\u00a0\u00a04. \nTypes, Memory, Exception\n \u00a0\u00a0\n \n\n\n\u00a0\u00a03. \nMore on Inheritance\n \u00a0\u00a0\n \n\n\n\u00a0\u00a02. \nInheritance and Polymorphism\n \u00a0\u00a0\n \n\n\n\u00a0\u00a01. \nAbstraction and Encapsulation\n \u00a0\u00a0\n \n\n\nFor list of topics coming up, see \nthe class schedule\n.",
            "title": "Home"
        },
        {
            "location": "/index.html#ay-201718-semester-2",
            "text": "",
            "title": "AY 2017/18 Semester 2"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/index.html#labs-and-assessments",
            "text": "Final  \u00a0\u00a0    Midterm  \u00a0\u00a0 6.  Async Web API  \u00a0\u00a0 5.  Matrix Multiplication  \u00a0\u00a0 4b.  Simulator ver 2.1  \u00a0\u00a0 4a.  Simulator ver 2.0  \u00a0\u00a0 3.  Infinite List  \u00a0\u00a0 2b.  Simulator ver 1.3  \u00a0\u00a0 2a.  Simulator ver 1.2  \u00a0\u00a0 1b.  Simulator ver 1.1  \u00a0\u00a0 1a.  Simulator ver 1.0  \u00a0\u00a0 0.  Warm Up",
            "title": "Labs and Assessments"
        },
        {
            "location": "/index.html#lectures",
            "text": "12. Review (no notes)\u00a0\u00a0  [ \n (Extra:  Build a Monad )  \u00a0\u00a011.  Getting Asynchronous with CompletableFuture \u00a0\u00a0    \u00a0\u00a010.  Parallel Streams \u00a0\u00a0    \u00a0\u00a09.  Functionl-Style Patterns  \u00a0\u00a0    \u00a0\u00a08.  Streams  \u00a0\u00a0    \u00a0\u00a07.  Functions  \u00a0\u00a0    \u00a0\u00a06.  Hash Code, Nested Class, Enum  \u00a0\u00a0    \u00a0\u00a05.  Generics and Collections  \u00a0\u00a0    \u00a0\u00a04.  Types, Memory, Exception  \u00a0\u00a0    \u00a0\u00a03.  More on Inheritance  \u00a0\u00a0    \u00a0\u00a02.  Inheritance and Polymorphism  \u00a0\u00a0    \u00a0\u00a01.  Abstraction and Encapsulation  \u00a0\u00a0    For list of topics coming up, see  the class schedule .",
            "title": "Lectures"
        },
        {
            "location": "/about/index.html",
            "text": "CS2030 Programming Methodology II\n\n\nAY17/18 Semester 2\n\n\nAbout\n\n\nThis module is a follow up to CS1010.  It explores two modern programming paradigms, object-oriented programming and functional programming.  Through a series of integrated assignments, students will learn to develop medium-scale software programs in the order of thousands of lines of code and tens of classes using object-oriented design principles and advanced programming constructs available in the two paradigms.  Topics include objects and classes, composition, association, inheritance, interface, polymorphism, abstract classes, dynamic binding, lambda expression, effect-free programming, first class functions, closures, continuations, monad, etc.  \n\n\nWho/When/Where\n\n\n\n\nLecture:\n 10am - 12noon, every Monday\n\n\nVenue:\n LT19\n\n\nInstructor:\n \nOoi Wei Tsang\n (\nooiwt@comp.nus.edu.sg\n)\n\n\nTeaching Assistant:\n \n\n\nLan Ziquan (\nziquan@comp.nus.edu.sg\n)\n\n\n\n\n\n\nUG Tutors:\n\n\nBernard Teo Zhi Yi\n\n\nChang Ho Huan\n\n\nChung Zhi Li, Denzel\n\n\nEvan Tay\n\n\nHo Boon Wee Addison\n\n\nJeremy Lim Yu Xuan\n\n\nJoshi Atharv Abhay\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nOng Yan Zhi\n\n\nQiu Siyu\n\n\nTan Thong Cai, Nelvin\n\n\nTay Hui Chun\n\n\nTeh Zi Cong Nicholas\n\n\nThangavel Sharan\n\n\nTriston Pang Erh Syen\n\n\nWinson Heng Yong Seng\n\n\nYuen Jun Rong\n\n\n\n\n\n\nLab:\n Every Tuesday (Week 3 - Week 13)\n\n\nMidterm Test:\n March 5, 2018, Monday, 10am\n\n\nFinal Assessment:\n May 3, 2018, Thursday\n\n\n\n\nWorkload\n\n\nBesides the 4-hour contact time for lecture and lab, students are expected to spend about 6 hours on average weekly on homework and on preparing the class.\n\n\nHistory\n\n\nCS2030 is a new module, required for all students in Bachelor of Computing (Computer Science) and Second Major in Computer Science students, cohort 17/18 onwards.  In 2017, the Department of Computer Science reorganized the two module series on data structures and algorithms (CS1020, CS2010) into (CS2030, CS2040).  CS2040 focuses on data structures and algorithms, while the advanced programming methodologies from CS1020 are moved into CS2030.  CS2030 will also covers some basics OO design that previously were covered in CS2103, and introduces students to functional programming, concurrent programming, event-based programming, and other paradigms that are increasingly important.\n\n\nLearning Outcomes\n\n\nAfter completing the module, students should:\n\n\n\n\nbe confident in reading and developing medium-scale programs (up to 10K lines of code)\n\n\nbe familiarize enough with common OO concepts to understand software code written in common OO language and understand documentation of software libraries in OO\n\n\nbe able to apply OO concepts to design and implement medium to large scale  programs, including\n\n\ndesign and implement a class\n\n\ndecompose a problem solution into classes and define members and methods for each class\n\n\nuse polymorphism effectively\n\n\nuse inheritance to design simple class hierarchies that allow code reuse\n\n\ntrace the control flow of a programs that use dynamic dispatch\n\n\nuse encapsulation mechanisms such as interfaces, private methods/members\n\n\n\n\n\n\nbe familiarize enough with common functional programming concepts and constructs, including lambda expression, effect-free programming, first class functions, infinite streams.\n\n\nbe able to apply functional programming concepts to design and implement , including:\n\n\nImplement basic algorithms in functions that are effect free.\n\n\nImplement useful functions that take/return another function\n\n\nWrite correct and effective code using lambda expressions and/or infinite streams\n\n\n\n\n\n\nbe able to compare and contrast imperative programming, OO programming, and function programming paradigms, and select the most natural paradigms for each situation\n\n\nbe aware of how the OOP and FP concepts are implemented in different ways in different programming languages\n\n\nbe confident enough to learn new programming languages that uses OOP and FP paradigm\n\n\nattain proficiency in Java 8 (and above)\n\n\nbe equipped with solid programming foundations for further studies in computer science\n\n\n\n\nTextbook\n\n\nThere is no textbook for this class.\n\n\nThere are many good books and online articles written about the topics covered in the module.  These will be listed under the \nReadings\n section.",
            "title": "About"
        },
        {
            "location": "/about/index.html#cs2030-programming-methodology-ii",
            "text": "",
            "title": "CS2030 Programming Methodology II"
        },
        {
            "location": "/about/index.html#ay1718-semester-2",
            "text": "",
            "title": "AY17/18 Semester 2"
        },
        {
            "location": "/about/index.html#about",
            "text": "This module is a follow up to CS1010.  It explores two modern programming paradigms, object-oriented programming and functional programming.  Through a series of integrated assignments, students will learn to develop medium-scale software programs in the order of thousands of lines of code and tens of classes using object-oriented design principles and advanced programming constructs available in the two paradigms.  Topics include objects and classes, composition, association, inheritance, interface, polymorphism, abstract classes, dynamic binding, lambda expression, effect-free programming, first class functions, closures, continuations, monad, etc.",
            "title": "About"
        },
        {
            "location": "/about/index.html#whowhenwhere",
            "text": "Lecture:  10am - 12noon, every Monday  Venue:  LT19  Instructor:   Ooi Wei Tsang  ( ooiwt@comp.nus.edu.sg )  Teaching Assistant:    Lan Ziquan ( ziquan@comp.nus.edu.sg )    UG Tutors:  Bernard Teo Zhi Yi  Chang Ho Huan  Chung Zhi Li, Denzel  Evan Tay  Ho Boon Wee Addison  Jeremy Lim Yu Xuan  Joshi Atharv Abhay  Lim Heng Guang  Lin Si Jie  Ong Yan Zhi  Qiu Siyu  Tan Thong Cai, Nelvin  Tay Hui Chun  Teh Zi Cong Nicholas  Thangavel Sharan  Triston Pang Erh Syen  Winson Heng Yong Seng  Yuen Jun Rong    Lab:  Every Tuesday (Week 3 - Week 13)  Midterm Test:  March 5, 2018, Monday, 10am  Final Assessment:  May 3, 2018, Thursday",
            "title": "Who/When/Where"
        },
        {
            "location": "/about/index.html#workload",
            "text": "Besides the 4-hour contact time for lecture and lab, students are expected to spend about 6 hours on average weekly on homework and on preparing the class.",
            "title": "Workload"
        },
        {
            "location": "/about/index.html#history",
            "text": "CS2030 is a new module, required for all students in Bachelor of Computing (Computer Science) and Second Major in Computer Science students, cohort 17/18 onwards.  In 2017, the Department of Computer Science reorganized the two module series on data structures and algorithms (CS1020, CS2010) into (CS2030, CS2040).  CS2040 focuses on data structures and algorithms, while the advanced programming methodologies from CS1020 are moved into CS2030.  CS2030 will also covers some basics OO design that previously were covered in CS2103, and introduces students to functional programming, concurrent programming, event-based programming, and other paradigms that are increasingly important.",
            "title": "History"
        },
        {
            "location": "/about/index.html#learning-outcomes",
            "text": "After completing the module, students should:   be confident in reading and developing medium-scale programs (up to 10K lines of code)  be familiarize enough with common OO concepts to understand software code written in common OO language and understand documentation of software libraries in OO  be able to apply OO concepts to design and implement medium to large scale  programs, including  design and implement a class  decompose a problem solution into classes and define members and methods for each class  use polymorphism effectively  use inheritance to design simple class hierarchies that allow code reuse  trace the control flow of a programs that use dynamic dispatch  use encapsulation mechanisms such as interfaces, private methods/members    be familiarize enough with common functional programming concepts and constructs, including lambda expression, effect-free programming, first class functions, infinite streams.  be able to apply functional programming concepts to design and implement , including:  Implement basic algorithms in functions that are effect free.  Implement useful functions that take/return another function  Write correct and effective code using lambda expressions and/or infinite streams    be able to compare and contrast imperative programming, OO programming, and function programming paradigms, and select the most natural paradigms for each situation  be aware of how the OOP and FP concepts are implemented in different ways in different programming languages  be confident enough to learn new programming languages that uses OOP and FP paradigm  attain proficiency in Java 8 (and above)  be equipped with solid programming foundations for further studies in computer science",
            "title": "Learning Outcomes"
        },
        {
            "location": "/about/index.html#textbook",
            "text": "There is no textbook for this class.  There are many good books and online articles written about the topics covered in the module.  These will be listed under the  Readings  section.",
            "title": "Textbook"
        },
        {
            "location": "/prereqs/index.html",
            "text": "Assumed Prior Knowledge\n\n\nCS2030 has the prerequisite of CS1010 or its equivalent.  There are, however, several versions of CS1010, and some students are waived from doing CS1010 due to prior programming knowledge.  This document here outlines the prior knowledge that the instructors assume the students have before entering CS2030.\n\n\nBasic computational problem solving and programming skills\n\n\nHere are some learning outcomes that students should attained after taking CS1010.  Students should be familiar with:\n\n\n\n\nthe computational thinking process of formulating a problem and coming up with a solution,\n\n\nfundamental programming concepts, including variables, assignments, conditions, branches, loops, expressions, functions, recursions, and structures\n\n\nhow to program a given solution in a programming language\n\n\ndifferent classes of programming errors (logical errors, syntax errors, run-time errors)\n\n\ncommon debugging techniques and strategies\n\n\ngood programming practices (comments, naming convention, indentation, modular code)\n\n\nsimple data structures (e.g., arrays)\n\n\nwriting test cases to check correctness of own program\n\n\nhow a program is executed and represented in a computing device (at a high level)\n\n\nthe compilation process (at a high level)\n\n\nthe concept of reusability and the use of standard/3\nrd\n party software\n\n\nbubble sort, insertion sort, linear search, and binary search\n\n\n\n\nStudents who take CS2030 are assumed to have sufficient knowledge of the above.  If there are specific components that you are not familiar with, please pick up the notes from CS1010 and self-learn.\n\n\nUNIX command line\n\n\nWe will use the \nsunfire\n computing server for this module.  As such, you are expected to be comfortable with using CLI (command line interface) and the basic UNIX commands, in a text window without fancy windows and mouse, and the concept of \nssh\n-ing into a remote host and work remotely.\n\n\nIf you are not familiar with this concept, take a look at the \nslides from the CS1010/CS1020 workshop\n.\n\n\nSource code editors\n\n\nYou are expected to be familiar with one or more source code editors.  Note that source code editor is not the same as text editor (e.g., Notepad).  A source code editor automatically highlights syntax, indents the code, matches parenthesis, supports autocompletion and code folding, and integrates with the software development process (such as revision control).\n\n\nCS1010 started (or would have started) you off with \nvim\n.  Many good source code editors exists, such as \nAtom\n, \nVS Code\n, and of course \nemacs\n1\n!\n\n\nFor your career, you should pick one and master it.  If you want to learn \nvim\n, the command \nvimtutor\n is a good place to start.  There are also many tutorials, webcasts, games, etc, online to help you learn \nvim\n.  Just google.\n\n\nDeveloper's Friendly OS\n\n\nYour life through the computing modules would be much much better if you are using a developer's friendly operating system on your personal computer.  \n\n\n\n\n\n\nIf you uses Linux or macOS, you are all set.  For macOS users, \nbrew\n is highly recommended.\n\n\n\n\n\n\nIf you use Windows 10, you should definitely install the Ubuntu Bash Shell.  There are many excellent tutorials online (such as \nthis one\n).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can't mention \nvim\n without mentioning \nemacs\n\u00a0\n\u21a9",
            "title": "Prerequisites"
        },
        {
            "location": "/prereqs/index.html#assumed-prior-knowledge",
            "text": "CS2030 has the prerequisite of CS1010 or its equivalent.  There are, however, several versions of CS1010, and some students are waived from doing CS1010 due to prior programming knowledge.  This document here outlines the prior knowledge that the instructors assume the students have before entering CS2030.",
            "title": "Assumed Prior Knowledge"
        },
        {
            "location": "/prereqs/index.html#basic-computational-problem-solving-and-programming-skills",
            "text": "Here are some learning outcomes that students should attained after taking CS1010.  Students should be familiar with:   the computational thinking process of formulating a problem and coming up with a solution,  fundamental programming concepts, including variables, assignments, conditions, branches, loops, expressions, functions, recursions, and structures  how to program a given solution in a programming language  different classes of programming errors (logical errors, syntax errors, run-time errors)  common debugging techniques and strategies  good programming practices (comments, naming convention, indentation, modular code)  simple data structures (e.g., arrays)  writing test cases to check correctness of own program  how a program is executed and represented in a computing device (at a high level)  the compilation process (at a high level)  the concept of reusability and the use of standard/3 rd  party software  bubble sort, insertion sort, linear search, and binary search   Students who take CS2030 are assumed to have sufficient knowledge of the above.  If there are specific components that you are not familiar with, please pick up the notes from CS1010 and self-learn.",
            "title": "Basic computational problem solving and programming skills"
        },
        {
            "location": "/prereqs/index.html#unix-command-line",
            "text": "We will use the  sunfire  computing server for this module.  As such, you are expected to be comfortable with using CLI (command line interface) and the basic UNIX commands, in a text window without fancy windows and mouse, and the concept of  ssh -ing into a remote host and work remotely.  If you are not familiar with this concept, take a look at the  slides from the CS1010/CS1020 workshop .",
            "title": "UNIX command line"
        },
        {
            "location": "/prereqs/index.html#source-code-editors",
            "text": "You are expected to be familiar with one or more source code editors.  Note that source code editor is not the same as text editor (e.g., Notepad).  A source code editor automatically highlights syntax, indents the code, matches parenthesis, supports autocompletion and code folding, and integrates with the software development process (such as revision control).  CS1010 started (or would have started) you off with  vim .  Many good source code editors exists, such as  Atom ,  VS Code , and of course  emacs 1 !  For your career, you should pick one and master it.  If you want to learn  vim , the command  vimtutor  is a good place to start.  There are also many tutorials, webcasts, games, etc, online to help you learn  vim .  Just google.",
            "title": "Source code editors"
        },
        {
            "location": "/prereqs/index.html#developers-friendly-os",
            "text": "Your life through the computing modules would be much much better if you are using a developer's friendly operating system on your personal computer.      If you uses Linux or macOS, you are all set.  For macOS users,  brew  is highly recommended.    If you use Windows 10, you should definitely install the Ubuntu Bash Shell.  There are many excellent tutorials online (such as  this one ).        I can't mention  vim  without mentioning  emacs \u00a0 \u21a9",
            "title": "Developer's Friendly OS"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS2030]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nWe do take attendance during the lab sessions, but it does not affect your grades if you do not attend the lab sessions as long as you still need to submit the graded lab exercises.  \n\n\n\n\n\n\nYou should stick to your allocated time slot for labs.  If there is a strong reason for your to attend another lab session, please inform your lab instructors.\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll graded exercise must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons can be considered (e.g., representing NUS for a sports event is OK, going for vacation is not)\n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the assessment grade) for every 5-minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for lab assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nLecture Video\n\n\n\n\n\n\nScreencast will be recorded and posted online 2-3 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS2030, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with me, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including graded labs, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.  Java documentation will be made available during labs.  Relevant Java APIs will be provided during midterm tests and final assessments.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS2030] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "We do take attendance during the lab sessions, but it does not affect your grades if you do not attend the lab sessions as long as you still need to submit the graded lab exercises.      You should stick to your allocated time slot for labs.  If there is a strong reason for your to attend another lab session, please inform your lab instructors.",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All graded exercise must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons can be considered (e.g., representing NUS for a sports event is OK, going for vacation is not)    For late submission, there is a 1% penalty (of the assessment grade) for every 5-minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for lab assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#lecture-video",
            "text": "Screencast will be recorded and posted online 2-3 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.",
            "title": "Lecture Video"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS2030, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with me, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including graded labs, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.  Java documentation will be made available during labs.  Relevant Java APIs will be provided during midterm tests and final assessments.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/schedule/index.html",
            "text": "Lab Timetable\n\n\nAll labs are on Tuesday.\n\n\n\n\n\n\n\n\nTime\n\n\nCOM1-B109\n\n\nCOM1-B111\n\n\nCOM1-B112\n\n\n\n\n\n\n\n\n\n\n1000 - 1200\n\n\n(1) Wei Tsang, Sharan, Yan Zhi\n\n\n-\n\n\n(5) Ziquan, Yi Chong, Jeremy\n\n\n\n\n\n\n1200 - 1400\n\n\n-\n\n\n(6) Ziquan, Jun Rong\n\n\n-\n\n\n\n\n\n\n1400 - 1600\n\n\n(3) Wei Tsang, Nelvin, Nicholas\n\n\n(7) Siyu, Hui Chun\n\n\n-\n\n\n\n\n\n\n1600 - 1800\n\n\n(4) Heng Guang, Bernard, Si Jie\n\n\n-\n\n\n(2) Winson, Triston\n\n\n\n\n\n\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nDate\n\n\nTopics\n\n\nLabs\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-01-15\n\n\n1. Abstraction and Encapsulation\n\n\n\n\n\n\n\n\n2\n\n\n2018-01-22\n\n\n2. Inheritance and Polymorphism\n\n\n\n\n\n\n\n\n3\n\n\n2018-01-29\n\n\n3. On Object-Oriented Design\n\n\nLab 0: Warm Up\n\n\n\n\n\n\n4\n\n\n2018-02-03\n\n\n4. Java Execution and Memory Models (incl Exceptions)\n\n\nLab 1a: Simulator v1.0\n\n\n\n\n\n\n5\n\n\n2018-02-12\n\n\n5. Generics and Collections\n\n\nLab 1b: Simulator v1.1\n\n\n\n\n\n\n6\n\n\n2018-02-19\n\n\n6. Types and Nested Classes\n\n\nLab 2a: Simulator v1.2\n\n\n\n\n\n\n2018-02-26\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2018-03-05\n\n\n[Midterm]\n\n\nLab 2b: Simulator v1.3\n\n\n\n\n\n\n8\n\n\n2018-03-12\n\n\n7. Functions and Lambdas\n\n\nLab 3a: Lambda List\n\n\n\n\n\n\n9\n\n\n2018-03-19\n\n\n8. Stream and Collections\n\n\nLab 3b: Infinite Lazy List\n\n\n\n\n\n\n10\n\n\n2018-03-26\n\n\n9. Optional, Functor, and Monad\n\n\nLab 4a: Simulator v2.0\n\n\n\n\n\n\n11\n\n\n2018-04-02\n\n\n10. Parallel Programming\n\n\nLab 4b: Simulator v2.1\n\n\n\n\n\n\n12\n\n\n2018-04-09\n\n\n11. Asynchronous Programming\n\n\nLab 5: Parallel\n\n\n\n\n\n\n13\n\n\n2018-04-16\n\n\n12. Recap\n\n\nLab 6: Async",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lab-timetable",
            "text": "All labs are on Tuesday.     Time  COM1-B109  COM1-B111  COM1-B112      1000 - 1200  (1) Wei Tsang, Sharan, Yan Zhi  -  (5) Ziquan, Yi Chong, Jeremy    1200 - 1400  -  (6) Ziquan, Jun Rong  -    1400 - 1600  (3) Wei Tsang, Nelvin, Nicholas  (7) Siyu, Hui Chun  -    1600 - 1800  (4) Heng Guang, Bernard, Si Jie  -  (2) Winson, Triston",
            "title": "Lab Timetable"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Date  Topics  Labs      1  2018-01-15  1. Abstraction and Encapsulation     2  2018-01-22  2. Inheritance and Polymorphism     3  2018-01-29  3. On Object-Oriented Design  Lab 0: Warm Up    4  2018-02-03  4. Java Execution and Memory Models (incl Exceptions)  Lab 1a: Simulator v1.0    5  2018-02-12  5. Generics and Collections  Lab 1b: Simulator v1.1    6  2018-02-19  6. Types and Nested Classes  Lab 2a: Simulator v1.2    2018-02-26  Break      7  2018-03-05  [Midterm]  Lab 2b: Simulator v1.3    8  2018-03-12  7. Functions and Lambdas  Lab 3a: Lambda List    9  2018-03-19  8. Stream and Collections  Lab 3b: Infinite Lazy List    10  2018-03-26  9. Optional, Functor, and Monad  Lab 4a: Simulator v2.0    11  2018-04-02  10. Parallel Programming  Lab 4b: Simulator v2.1    12  2018-04-09  11. Asynchronous Programming  Lab 5: Parallel    13  2018-04-16  12. Recap  Lab 6: Async",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nHere is a collection of readings related to CS2030 or otherwise.\n\n\nOn UNIX, Vim, and Emacs\n\n\n\n\n\n\nStackExchange: \nTime to Drop Emacs and Vim?\n\n\n\n\n\n\nBook: \nThe Art of UNIX Programming\n, online version, by Eric Steven Raymond, 2003. \n\n\n\n\n\n\nOn Programming Practices\n\n\n\n\nGoogle Java Style Guide\n\n\n\n\nOn OOP\n\n\n\n\n\n\nWhy extends is evil\n by Allen Holub. \n\"Good designers write most of their code in terms of interfaces, not concrete base classes.\"\n\n\n\n\n\n\nGoodbye, Object Oriented Programming\n by Charles Scalfani. \n\"One day, my code works and the next day it stops working. Here\u2019s the kicker. I didn\u2019t change my code.\n\"\n\n\n\n\n\n\nWhy getters and setters methods are evil\n, by Allen Holub. \"\nThough getter/setter methods are commonplace in Java, they are not particularly object oriented (OO). In fact, they can damage your code's maintainability. Moreover, the presence of numerous getter and setter methods is a red flag that the program isn't necessarily well designed from an OO perspective.\n\"\n\n\n\n\n\n\nGetters/Setters.  Evil.  Period\n, by Yegor Bygayenko.  \"\nThe gist of the following text is this: getters and setters is a terrible practice and those who use it can't be excused.\n\"\n\n\n\n\n\n\nTell, Don't Ask\n by Thoughtbot Inc. \n\"Good OOP is about telling objects what you want done, not querying an object and acting on its behalf. Data and operations that depend on that data belong in the same object.\"\n\n\n\n\n\n\nTell, Don't Ask\n by The Pragmatic Bookshelf. \n\"Procedural code gets information then makes decisions. Object-oriented code tells objects to do things.\"\n\n\n\n\n\n\nFor 1\nst\n Year Students\n\n\n\n\n\n\nNotes to Computer Science Freshmen, From the Future\n: \nEarly into the AY12/13 academic year, Prof Tay Yong Chiang organized a supper for Computer Science freshmen at Tembusu College. The bunch of seniors who were gathered there put together a document for NUS computing freshmen. This is that document.\n\n\n\n\n\n\nHow Not to Go About a Programming Assignment, by Agustin Cernuda del Rio\n: \nComputer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..\n\n\n\n\n\n\nBest Teacher I Ever Had, by David Owen\n: \nMr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..\n\n\n\n\n\n\nAcademic Honesty\n: \nAll students share the responsibility for upholding the academic standards and reputation of the University. Academic honesty is a prerequisite condition in the pursuit and acquisition of knowledge..",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "Here is a collection of readings related to CS2030 or otherwise.",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#on-unix-vim-and-emacs",
            "text": "StackExchange:  Time to Drop Emacs and Vim?    Book:  The Art of UNIX Programming , online version, by Eric Steven Raymond, 2003.",
            "title": "On UNIX, Vim, and Emacs"
        },
        {
            "location": "/readings/index.html#on-programming-practices",
            "text": "Google Java Style Guide",
            "title": "On Programming Practices"
        },
        {
            "location": "/readings/index.html#on-oop",
            "text": "Why extends is evil  by Allen Holub.  \"Good designers write most of their code in terms of interfaces, not concrete base classes.\"    Goodbye, Object Oriented Programming  by Charles Scalfani.  \"One day, my code works and the next day it stops working. Here\u2019s the kicker. I didn\u2019t change my code.\n\"    Why getters and setters methods are evil , by Allen Holub. \" Though getter/setter methods are commonplace in Java, they are not particularly object oriented (OO). In fact, they can damage your code's maintainability. Moreover, the presence of numerous getter and setter methods is a red flag that the program isn't necessarily well designed from an OO perspective. \"    Getters/Setters.  Evil.  Period , by Yegor Bygayenko.  \" The gist of the following text is this: getters and setters is a terrible practice and those who use it can't be excused. \"    Tell, Don't Ask  by Thoughtbot Inc.  \"Good OOP is about telling objects what you want done, not querying an object and acting on its behalf. Data and operations that depend on that data belong in the same object.\"    Tell, Don't Ask  by The Pragmatic Bookshelf.  \"Procedural code gets information then makes decisions. Object-oriented code tells objects to do things.\"",
            "title": "On OOP"
        },
        {
            "location": "/readings/index.html#for-1st-year-students",
            "text": "Notes to Computer Science Freshmen, From the Future :  Early into the AY12/13 academic year, Prof Tay Yong Chiang organized a supper for Computer Science freshmen at Tembusu College. The bunch of seniors who were gathered there put together a document for NUS computing freshmen. This is that document.    How Not to Go About a Programming Assignment, by Agustin Cernuda del Rio :  Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..    Best Teacher I Ever Had, by David Owen :  Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..    Academic Honesty :  All students share the responsibility for upholding the academic standards and reputation of the University. Academic honesty is a prerequisite condition in the pursuit and acquisition of knowledge..",
            "title": "For 1st Year Students"
        },
        {
            "location": "/final/index.html",
            "text": "Information about Final Assessment\n\n\nPlease check back regularly for updates.\n\n\nDate and Time\n\n\n\n\n3 May, 2018 (Thurs) \n\n\n1:00pm\n\n\nMPSH6\n\n\n\n\nFormat\n\n\n\n\nOpen book\n\n\nMCQs and short questions\n\n\n\n\nScope\n\n\n\n\nAll lectures, all labs\n\n\n\n\nPYQ\n\n\n\n\nAY2017/18 Semester 1 \nQuestions\n | \nQuestions with Solutions\n\n\nAY2017/18 Semester 2 \nQuestions with Solutions\n\n\nRejected Final Questions",
            "title": "Final"
        },
        {
            "location": "/final/index.html#information-about-final-assessment",
            "text": "Please check back regularly for updates.",
            "title": "Information about Final Assessment"
        },
        {
            "location": "/final/index.html#date-and-time",
            "text": "3 May, 2018 (Thurs)   1:00pm  MPSH6",
            "title": "Date and Time"
        },
        {
            "location": "/final/index.html#format",
            "text": "Open book  MCQs and short questions",
            "title": "Format"
        },
        {
            "location": "/final/index.html#scope",
            "text": "All lectures, all labs",
            "title": "Scope"
        },
        {
            "location": "/final/index.html#pyq",
            "text": "AY2017/18 Semester 1  Questions  |  Questions with Solutions  AY2017/18 Semester 2  Questions with Solutions  Rejected Final Questions",
            "title": "PYQ"
        },
        {
            "location": "/midterm/index.html",
            "text": "Midterm\n\n\nStatistics\n\n\n\n\nAverage: 33.5\n\n\nStd Dev: 8.14\n\n\nMax: 48\n\n\n\n\n\n\nMidterm Question Paper\n (with solution, marking scheme, and comments)\n\n\nSlides from the Labs\n\n\nVideo from Lecture 7 on Q11\n\n\nImportant Information\n\n\n\n\nDate: March 5, 2018 (Monday)\n\n\nTime: 1000 - 1130\n\n\nVenue: MPSH 2 Section C\n\n\n\n\nPlease arrive at least 5 minutes earlier and wait outside the hall.\n\n\nScope\n\n\n\n\nEverything taught during Week 1 - Week 6\n\n\nLab 0 - Lab 1b\n\n\n\n\nOpen Book\n\n\nThis is an open book midterm.  You can bring in books and notes.  They can be printed or hand written.  No digital materials (laptop, tablet, etc.).  Any Java API needed will be provided to you.\n\n\nPast Year Paper\n\n\n\n\nAY2017/18 Semester 1",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#midterm",
            "text": "",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#statistics",
            "text": "Average: 33.5  Std Dev: 8.14  Max: 48",
            "title": "Statistics"
        },
        {
            "location": "/midterm/index.html#midterm-question-paper-with-solution-marking-scheme-and-comments",
            "text": "",
            "title": "Midterm Question Paper (with solution, marking scheme, and comments)"
        },
        {
            "location": "/midterm/index.html#slides-from-the-labs",
            "text": "",
            "title": "Slides from the Labs"
        },
        {
            "location": "/midterm/index.html#video-from-lecture-7-on-q11",
            "text": "",
            "title": "Video from Lecture 7 on Q11"
        },
        {
            "location": "/midterm/index.html#important-information",
            "text": "Date: March 5, 2018 (Monday)  Time: 1000 - 1130  Venue: MPSH 2 Section C   Please arrive at least 5 minutes earlier and wait outside the hall.",
            "title": "Important Information"
        },
        {
            "location": "/midterm/index.html#scope",
            "text": "Everything taught during Week 1 - Week 6  Lab 0 - Lab 1b",
            "title": "Scope"
        },
        {
            "location": "/midterm/index.html#open-book",
            "text": "This is an open book midterm.  You can bring in books and notes.  They can be printed or hand written.  No digital materials (laptop, tablet, etc.).  Any Java API needed will be provided to you.",
            "title": "Open Book"
        },
        {
            "location": "/midterm/index.html#past-year-paper",
            "text": "AY2017/18 Semester 1",
            "title": "Past Year Paper"
        },
        {
            "location": "/lab0/index.html",
            "text": "Lab 0\n\n\nThis is a warm up, ungraded, lab.  \n\n\nSubmission deadline: 2359, Friday, February 2, 2018.\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe more comfortable with the CS2030 laboratory environment, including knowing how to remotely access \ncs2030-i\n, create directory, copy files, edit files, transfer files between \ncs2030-i\n and local computers, run a script, and other \nUNIX commands\n\n\nbe familiar with compiling and running Java programs from the command line\n\n\nbe familiar with the concept of standard input and standard output, how to redirect the content of a file to standard input, and how to print to standard output\n\n\nbe more comfortable with basic Java syntax and semantics, specifically with\n\n\nadding methods into existing classes\n\n\ninvoking the methods of the classes to solve problems\n\n\ndeclaring and using arrays, primitive types, and objects\n\n\nusing if/else and for statements\n\n\nprinting to standard output\n\n\nthe \nthis\n keyword\n\n\n\n\n\n\n\n\n\n\nexperience reading Java API documentation and find out what are the methods available, and what are the arguments and returned types.\n\n\nsee an example of how class \nScanner\n is used\n\n\nappreciate how encapsulation of class \nPoint\n and class \nCircle\n allows one to reason about higher-level tasks without worrying about lower level representation\n\n\n\n\nSetup\n\n\nLogin to \ncs2030-i\n, copy the files from \n~cs2030/lab0\n to your local directory under your home \n~/lab0\n.  You should see four java files (\nPoint.java\n, \nCircle.java\n, \nMaxDiscCover.java\n, and \nLabZero.java\n), and a few data files (\nTESTDATA1.txt\n, \nTESTDATA2.txt\n, ..., \nTESTDATA5.txt\n)\n\n\nRead through the files above.  Although we have seen \nCircle\n and \nPoint\n as examples in class, these classes are slightly different.\n\n\n1. Augment the class Point\n\n\nAugment the class \nPoint\n with the following public methods and constructors.\nYou may find the static methods provided by \njava.lang.Math\n useful.\n\n\n1.1. Static Method to construct mid point\n\n\n1\npublic\n \nstatic\n \nPoint\n \nmidPoint\n(\nPoint\n \np\n,\n \nPoint\n \nq\n)\n\n\n\n\n\n\n\nGiven two points \np\n and \nq\n, create and return the midpoint of \np\n and \nq\n.\n\n\n1.2 Distance between points\n\n\n1\npublic\n \ndouble\n \ndistanceTo\n(\nPoint\n \nq\n)\n \n\n\n\n\n\n\nYou should have written something like this from your Exercise 1.  This method returns the Euclidean distance of \nthis\n point to the point \nq\n.\n\n\n1.3 Angle between points\n\n\n1\npublic\n \ndouble\n \nangleTo\n(\nPoint\n \nq\n)\n \n\n\n\n\n\n\nThis method returns the angle between the current point and point \nq\n.  In the figure below, it returns the angle \n\\theta\n\\theta\n.  You can compute this using the \natan2()\n function. For instance, \n\n1\n2\nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\n0\n,\n \n0\n);\n\n\np\n.\nangleTo\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n));\n\n\n\n\n\nshould return\n\n1\n0.7853981633974483\n\n\n\n\nwhich is \n\\pi/4\n\\pi/4\n.\n\n\n1\np.angleTo(new Point(1, 0));\n\n\n\n\n\n\nshould return \n\n\n1\n0.0\n\n\n\n\n\n\natan2()\n takes in two \ndouble\n as arguments for coordinate \nx\n and \ny\n. It returns \ntheta\n, the angle in radian, counted in \nanti-clockwise direction with respect to origin. One mathematical trick here is if you subtract the coordinates \nof \nPoint p\n from \nPoint q\n, you basically reduce \nPoint p\n to be an origin to \nPoint q\n. \nFor more detail, please refer to the Java API for \natan2\n for more details.\n\n\n\n\n1.4. Move a point\n\n\n1\npublic\n \nvoid\n \nmove\n(\ndouble\n \ntheta\n,\n \ndouble\n \nd\n)\n\n\n\n\n\n\n\nMove the point by a given distance at direction theta (in radian).  See Figure:\n\n\n\n\nThe new point should have the coordinate (\nx + d\\cos\\theta, y + d\\sin\\theta\nx + d\\cos\\theta, y + d\\sin\\theta\n).  Note in this method, you are given the angle (theta) and want to find length. Hence you need to use cosine and sine.\n\n\nAfter\n\n1\np.move(p.angleTo(q), p.distanceTo(q));\n\n\n\n\n\np\n should coincide with \nq\n.\n\n\n\n\nMutable vs. Immutable\n\n\nThe method \nmove\n is called a \nmutable\n method, since it modifies (mutates) the object that it is called on.  Later in CS2030, you will be introduced to the concept of \nimmutable\n methods.\n\n\n\n\n2. Augment the class Circle\n\n\nAugment the class \nCircle\n with the following methods and constructors:\n\n\n2.1 Constructor\n\n\n1\npublic\n \nCircle\n(\nPoint\n \np\n,\n \nPoint\n \nq\n,\n \ndouble\n \nradius\n)\n\n\n\n\n\n\n\nThe constructor above takes in two points \np\n and \nq\n, and returns a circle  that passes through both \np\n and \nq\n, with radius \nradius\n.  \n\n\nThere are two such possible circles (see figures below) if distance between \np\n and \nq\n is no greater than 2x\nradius\n1\n.  Imagine if you walk from \np\n to \nq\n, one of the circle will have the center on your left, the other will have the center on your right. In this method, we will only consider the circle on the left because the circle on the right will be considered when you walk from \nq\n to \np\n. See figure below.\n\n\n\n\nHint: To find the center \nc\nc\n of the new circle, you can first find the midpoint \nm\nm\n of line \npq\npq\n, the length of line \nmc\nmc\n, and the angle between \nm\nm\n and \nc\nc\n, using the \nPoint\n methods you have written.  We also know that length of \ncq\ncq\n is \nradius\n.  See figure below.\n\n\n\n\nThe constructor should return a \nCircle\n with \nDouble.NaN\n as the radius and (0,0) as center if the distance between \np\n and \nq\n is larger than 2x\nradius\n or is zero\n2\n.  Such \nCircle\n objects are invalid, and you may want to add a method in the \nCircle\n class to check for validity.  You can use \nDouble.isNaN\n for check if a double variable is NaN.\n\n\n3. Maximum Disc Coverage\n\n\nWe are now going to use the \nCircle\n class and \nPoint\n class to solve the maximum disc coverage problem.  In this problem, we are given a set of points on a 2D plane, and a unit disc (i.e., a circle of radius 1).  We want to place the disc so that it covers as many points as possible.  What is the maximum number of points that we can cover with the disc at any one time?   \n\n\nWe will use the following simple (non-optimal)  algorithm\n3\n.  First, some observations:\n\n\n\n\nA disc that covers the maximum number of points must pass through at least two points.\n\n\nFor every pair of points that is of no more than distance 2 away from each other, there is at most two unit discs that have their perimeter passing through the two points (you have written a constructor that helps you to find such circles).\n\n\n\n\nSo, the algorithm simply goes through every pair of points, and for each circle that passes through them, count how many points are covered by each circle.\n\n\nThe skeleton of the main class, called \nLabZero.java\n has been given to you.  The file \nMaxDiscCover.java\n, also given, is where you will implement tha maximum disc coverage solution .  These two files are placed in the same directory as \nCircle.java\n and \nPoint.java\n.  \n\n\nThe skeleton code reads a set of points from the standard input, in the following format:\n\n\n\n\nThe first line is an integer, indicating the number of points \nn\nn\n (\nn\nn\n > 2) in the file.\n\n\nThe next \nn\nn\n lines contains the \nx\nx\n and \ny\ny\n coordinates of \nn\nn\n points, one point per line.  Each line has two doubles, separated by space.  The first double is the \nx\nx\n coordinate; the second double is the \ny\ny\n coordinate.\n\n\n\n\nYou can assume that the format of the input is always correct and there is always at least two points with distance less than 2 between them.\n\n\nComplete the program by implementing the maximum disc coverage algorithm above, and print the maximum number of points covered to standard output.  You can add additional methods and fields for \nPoint\n and \nCircle\n if needed.\n\n\n1\n2\nooiwt@cs2030-i:~/lab0[xxx]$ java LabZero < TESTDATA1.txt\n2\n\n\n\n\n\n\nThe test cases and answers should be:\n\n\n\n\n\n\n\n\nTEST\n\n\nMax Number of Points\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n\n\n\n\n2\n\n\n4\n\n\n\n\n\n\n3\n\n\n12\n\n\n\n\n\n\n4\n\n\n44\n\n\n\n\n\n\n5\n\n\n5\n\n\n\n\n\n\n\n\nNote that it is still possible for your solution to be buggy and you still get the same answer as above.\n\n\nAdding Methods\n\n\nYou can add new methods as needed into the provided skeleton classes.  You should, however, avoid using setters and getters, and must not break the abstraction barrier by exposing any instance field as \npublic\n.\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit0\n\n\n\n\n\nwhich will copy your java files (and nothing else) from your \n~/lab0\n directory on \ncs2030-i\n to an internal grading directory.\n\n\nYou can submit multiple times, but only the most recent submission will be graded for the next lab onwards. This lab is a warm-up lab, which will not be graded. \n\n\n\n\n\n\n\n\n\n\nIf the distance between \np\n and \nq\n is exactly 2x\nradius\n, then the two circles are one and the same.\u00a0\n\u21a9\n\n\n\n\n\n\nA cleaner solution is to throw an exception, but you won't learn this until later in class.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is a \nO(n^3)\nO(n^3)\n algorithm.  Faster algorithm exists.\u00a0\n\u21a9",
            "title": "0. Warm Up"
        },
        {
            "location": "/lab0/index.html#lab-0",
            "text": "This is a warm up, ungraded, lab.    Submission deadline: 2359, Friday, February 2, 2018.",
            "title": "Lab 0"
        },
        {
            "location": "/lab0/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be more comfortable with the CS2030 laboratory environment, including knowing how to remotely access  cs2030-i , create directory, copy files, edit files, transfer files between  cs2030-i  and local computers, run a script, and other  UNIX commands  be familiar with compiling and running Java programs from the command line  be familiar with the concept of standard input and standard output, how to redirect the content of a file to standard input, and how to print to standard output  be more comfortable with basic Java syntax and semantics, specifically with  adding methods into existing classes  invoking the methods of the classes to solve problems  declaring and using arrays, primitive types, and objects  using if/else and for statements  printing to standard output  the  this  keyword      experience reading Java API documentation and find out what are the methods available, and what are the arguments and returned types.  see an example of how class  Scanner  is used  appreciate how encapsulation of class  Point  and class  Circle  allows one to reason about higher-level tasks without worrying about lower level representation",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab0/index.html#setup",
            "text": "Login to  cs2030-i , copy the files from  ~cs2030/lab0  to your local directory under your home  ~/lab0 .  You should see four java files ( Point.java ,  Circle.java ,  MaxDiscCover.java , and  LabZero.java ), and a few data files ( TESTDATA1.txt ,  TESTDATA2.txt , ...,  TESTDATA5.txt )  Read through the files above.  Although we have seen  Circle  and  Point  as examples in class, these classes are slightly different.",
            "title": "Setup"
        },
        {
            "location": "/lab0/index.html#1-augment-the-class-point",
            "text": "Augment the class  Point  with the following public methods and constructors.\nYou may find the static methods provided by  java.lang.Math  useful.",
            "title": "1. Augment the class Point"
        },
        {
            "location": "/lab0/index.html#11-static-method-to-construct-mid-point",
            "text": "1 public   static   Point   midPoint ( Point   p ,   Point   q )    Given two points  p  and  q , create and return the midpoint of  p  and  q .",
            "title": "1.1. Static Method to construct mid point"
        },
        {
            "location": "/lab0/index.html#12-distance-between-points",
            "text": "1 public   double   distanceTo ( Point   q )     You should have written something like this from your Exercise 1.  This method returns the Euclidean distance of  this  point to the point  q .",
            "title": "1.2 Distance between points"
        },
        {
            "location": "/lab0/index.html#13-angle-between-points",
            "text": "1 public   double   angleTo ( Point   q )     This method returns the angle between the current point and point  q .  In the figure below, it returns the angle  \\theta \\theta .  You can compute this using the  atan2()  function. For instance,  1\n2 Point   p   =   new   Point ( 0 ,   0 );  p . angleTo ( new   Point ( 1 ,   1 ));   \nshould return 1 0.7853981633974483  \nwhich is  \\pi/4 \\pi/4 .  1 p.angleTo(new Point(1, 0));   should return   1 0.0   atan2()  takes in two  double  as arguments for coordinate  x  and  y . It returns  theta , the angle in radian, counted in \nanti-clockwise direction with respect to origin. One mathematical trick here is if you subtract the coordinates \nof  Point p  from  Point q , you basically reduce  Point p  to be an origin to  Point q . \nFor more detail, please refer to the Java API for  atan2  for more details.",
            "title": "1.3 Angle between points"
        },
        {
            "location": "/lab0/index.html#14-move-a-point",
            "text": "1 public   void   move ( double   theta ,   double   d )    Move the point by a given distance at direction theta (in radian).  See Figure:   The new point should have the coordinate ( x + d\\cos\\theta, y + d\\sin\\theta x + d\\cos\\theta, y + d\\sin\\theta ).  Note in this method, you are given the angle (theta) and want to find length. Hence you need to use cosine and sine.  After 1 p.move(p.angleTo(q), p.distanceTo(q));   p  should coincide with  q .   Mutable vs. Immutable  The method  move  is called a  mutable  method, since it modifies (mutates) the object that it is called on.  Later in CS2030, you will be introduced to the concept of  immutable  methods.",
            "title": "1.4. Move a point"
        },
        {
            "location": "/lab0/index.html#2-augment-the-class-circle",
            "text": "Augment the class  Circle  with the following methods and constructors:",
            "title": "2. Augment the class Circle"
        },
        {
            "location": "/lab0/index.html#21-constructor",
            "text": "1 public   Circle ( Point   p ,   Point   q ,   double   radius )    The constructor above takes in two points  p  and  q , and returns a circle  that passes through both  p  and  q , with radius  radius .    There are two such possible circles (see figures below) if distance between  p  and  q  is no greater than 2x radius 1 .  Imagine if you walk from  p  to  q , one of the circle will have the center on your left, the other will have the center on your right. In this method, we will only consider the circle on the left because the circle on the right will be considered when you walk from  q  to  p . See figure below.   Hint: To find the center  c c  of the new circle, you can first find the midpoint  m m  of line  pq pq , the length of line  mc mc , and the angle between  m m  and  c c , using the  Point  methods you have written.  We also know that length of  cq cq  is  radius .  See figure below.   The constructor should return a  Circle  with  Double.NaN  as the radius and (0,0) as center if the distance between  p  and  q  is larger than 2x radius  or is zero 2 .  Such  Circle  objects are invalid, and you may want to add a method in the  Circle  class to check for validity.  You can use  Double.isNaN  for check if a double variable is NaN.",
            "title": "2.1 Constructor"
        },
        {
            "location": "/lab0/index.html#3-maximum-disc-coverage",
            "text": "We are now going to use the  Circle  class and  Point  class to solve the maximum disc coverage problem.  In this problem, we are given a set of points on a 2D plane, and a unit disc (i.e., a circle of radius 1).  We want to place the disc so that it covers as many points as possible.  What is the maximum number of points that we can cover with the disc at any one time?     We will use the following simple (non-optimal)  algorithm 3 .  First, some observations:   A disc that covers the maximum number of points must pass through at least two points.  For every pair of points that is of no more than distance 2 away from each other, there is at most two unit discs that have their perimeter passing through the two points (you have written a constructor that helps you to find such circles).   So, the algorithm simply goes through every pair of points, and for each circle that passes through them, count how many points are covered by each circle.  The skeleton of the main class, called  LabZero.java  has been given to you.  The file  MaxDiscCover.java , also given, is where you will implement tha maximum disc coverage solution .  These two files are placed in the same directory as  Circle.java  and  Point.java .    The skeleton code reads a set of points from the standard input, in the following format:   The first line is an integer, indicating the number of points  n n  ( n n  > 2) in the file.  The next  n n  lines contains the  x x  and  y y  coordinates of  n n  points, one point per line.  Each line has two doubles, separated by space.  The first double is the  x x  coordinate; the second double is the  y y  coordinate.   You can assume that the format of the input is always correct and there is always at least two points with distance less than 2 between them.  Complete the program by implementing the maximum disc coverage algorithm above, and print the maximum number of points covered to standard output.  You can add additional methods and fields for  Point  and  Circle  if needed.  1\n2 ooiwt@cs2030-i:~/lab0[xxx]$ java LabZero < TESTDATA1.txt\n2   The test cases and answers should be:     TEST  Max Number of Points      1  2    2  4    3  12    4  44    5  5     Note that it is still possible for your solution to be buggy and you still get the same answer as above.",
            "title": "3. Maximum Disc Coverage"
        },
        {
            "location": "/lab0/index.html#adding-methods",
            "text": "You can add new methods as needed into the provided skeleton classes.  You should, however, avoid using setters and getters, and must not break the abstraction barrier by exposing any instance field as  public .",
            "title": "Adding Methods"
        },
        {
            "location": "/lab0/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit0   which will copy your java files (and nothing else) from your  ~/lab0  directory on  cs2030-i  to an internal grading directory.  You can submit multiple times, but only the most recent submission will be graded for the next lab onwards. This lab is a warm-up lab, which will not be graded.       If the distance between  p  and  q  is exactly 2x radius , then the two circles are one and the same.\u00a0 \u21a9    A cleaner solution is to throw an exception, but you won't learn this until later in class.\u00a0 \u21a9    This is a  O(n^3) O(n^3)  algorithm.  Faster algorithm exists.\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab1a/index.html",
            "text": "Lab 1a\n\n\nSubmission deadline: 2359, Friday, February 9, 2018.\n\n\nPrerequisites\n\n\nAssume that students are already familiar with:\n\n\n\n\nthe \nCS2030 laboratory environment\n\n\nhow to \ncompile and run Java programs\n\n\ncomfortable with Java syntax\n\n\nlooking up Java API documentation\n\n\nunderstand the concepts of encapsulation and using encapsulated objects\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe more comfortable with looking at a complex problem and identify data and procedures that should be kept within an abstraction barrier.  In other words, be more comfortable with creating own encapsulated class.\n\n\nbe more comfortable with basic Java syntax and semantics, particularly when creating classes from scratch.\n\n\nbe comfortable with following a given coding convention.\n\n\n\n\nSetup\n\n\nLogin to \ncs2030-i\n, copy the files from \n~cs2030/lab1a\n to your local directory under your home \n~/lab1a\n.  You should see one java file (\nLabOneA.java\n) and a few data files (\nTESTDATA1.txt\n, \nTESTDATA2.txt\n, ..., \nTESTDATA5.txt\n)\n\n\nGoals\n\n\nLabOneA.java\n implements a working discrete event simulator that simulates customers being served by a server.  It is written in procedural style with \nno encapsulation\n.  The goal, in this lab, is to rewrite this simulator with OO style, by properly using encapsulation to create abstraction barriers to the various variables and methods.  Here and some hints:\n\n\n\n\nThink about the problem that you are solving: what are the nouns?  These are good candidates for classes. \n\n\nFor each class, what are the attributes/properties relevant to the class?  These are good candidates for fields in the class.\n\n\nFor each class, what are their responsibilities?  What can they \ndo\n?  These are good candidates for methods in the class.\n\n\nHow do the objects of each class interact?  These are good candidates for public methods.\n\n\n\n\nNote that the goal of this lab and, and of CS2030 in general, is \nNOT\n to solve the problem with the cleverest and the shortest piece of code possible.  For instance, you might notice that you can solve Lab 1a with only a few variables and an array.  But such solution is hard to extend and modify.  In CS2030, our goal is to produce a software that can easily evolve and be modified, with a reduced risk of introducing bugs while doing so.\n\n\nNote that Lab 1a is the first of a series of labs, where we introduce new requirements or modify existing ones in every lab (not \nunlike what software engineers face in the real world\n).  We will slowly evolve the simulator into something more general and will simulate a more complex server and customer behaviors in our simulation.\n\n\nThus, making sure that your code will be able to adapt to new problem statements is the key.  Trying to solve the lab without considering this (such as coming up with a solution that computes the average waiting time in only tens of lines of code) and you will likely find yourself painted into a corner and have to re-write much of your solution to handle the new requirement.\n\n\nGrading\n\n\nThis lab is not graded.  But, it will be extended to Lab 1b, which is graded.  Coming out with a good encapsulation will make your Lab 1b much easier to solve. \nYou may be tempted to wait for Lab 1b to be released and solve Lab 1a and 1b together -- unless you are very sure you can handle it, do not do this.  The purpose of Lab 1a is to give you enough time to ponder \nover different designs and get feedback from your Lab TAs.\n\n\nDiscrete Event Simulator\n\n\nA discrete event simulator is a software that simulates a system (often modeled after the real world) with events and states.  An event occurs at a particular time, and each event alters the states of the system and may generate more events.  A discrete event simulator can be used to study many complex real-world systems.  The term \ndiscrete\n refers to the fact that, the states remain unchanged between two events, and therefore, the simulator can \njump\n from the time of one event to another, instead of following the clock in real time.  The simulator typically keeps track of some statistics to measure the performance of the system.\n\n\nIn this lab, we start with simulating a specific situation:\n\n\n\n\nWe have a shop with a \nserver\n (a person providing service to the customer).\n\n\nThe server can serve one customer at a time.\n\n\nWe assume for now that the server takes constant time to serve a customer.\n  The time taken to serve is called \nservice time\n.\n\n\nWhen a customer arrives:\n\n\nif the server is idle (not serving any customer), then the server serves the customer immediately (no waiting).\n\n\nif the server is serving another customer, then the customer that just arrives waits.\n\n\nif the server is serving one customer, and another customer is waiting, then the customer that just arrives just leave (no waiting) and go elsewhere.  In other words, there is at most one waiting customer.\n\n\n\n\n\n\nWhen the server is done serving a customer:\n\n\nthe served customer leaves.\n\n\nif there is another customer waiting, the server starts serving the waiting customer immediately.\n\n\nif there is no waiting customer, then server becomes idle again.\n\n\n\n\n\n\n\n\nWe are interested in the following.  Given a sequence of customer arrivals (time of each arrival is given):\n\n\n\n\nWhat is the average waiting time for customers that have been served?\n\n\nHow many customers are served?\n\n\nHow many customers left without being served?\n\n\n\n\nIn your Lab 1a, you are given a simple discrete event simulator to answer the questions above.  There are two classes: \nSimulator\n and \nEvent\n.\n\n\nClass \nEvent\n\n\nThe event class is written in a procedural style, not unlike a \nstruct\n in C.  All members are public, and there is no method.  Each \nEvent\n keeps track of two information: the \ntime\n the event occurs, and \neventType\n, which signifies what type of events is this.  Instead of using time like 9:45 pm, we simply and represent time as a double value.\n\n\n1\n2\n3\n4\n  \nstatic\n \nclass\n \nEvent\n \n{\n\n    \npublic\n \ndouble\n \ntime\n;\n \n// The time this event will occur\n\n    \npublic\n \nint\n \neventType\n;\n \n// The type of event, indicates what should happen when an event occurs. \n\n  \n}\n\n\n\n\n\n\n\nWe handle two types of events for this particular scenario: an event of type \nCUSTOMER_ARRIVE\n means that a customer arrives during this event; while an event of type \nCUSTOMER_DONE\n means that the customer is done being served.  \nCUSTOMER_ARRIVE\n events are created based on the given input.  \nCUSTOMER_DONE\n events are created and scheduled to occur sometime in the future when a customer is being served.\n\n\n1\n2\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_ARRIVE\n \n=\n \n1\n;\n\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_DONE\n \n=\n \n2\n;\n\n\n\n\n\n\n\nClass \nSimulator\n\n\nThe simulator class is again written in procedural style.  All members are public, and there is no method.\n\n\nThe \nSimulator\n class contains two configuration parameters, \nMAX_NUMBER_OF_EVENTS\n indicates the maximum number of events that the simulator can store at one time; \nSERVICE_TIME\n indicates the time the server takes to serve a customer.\n\n1\n2\n    \npublic\n \nstatic\n \nfinal\n \nint\n \nMAX_NUMBER_OF_EVENTS\n \n=\n \n100\n;\n \n// Maximum number of events\n\n    \npublic\n \nstatic\n \nfinal\n \ndouble\n \nSERVICE_TIME\n \n=\n \n1.0\n;\n \n// Time spent serving a customer\n\n\n\n\n\n\nThe \nevents\n is an array of \nEvent\n that store all events scheduled for the future in the simulator.\n\n1\n2\n    \npublic\n \nEvent\n[]\n \nevents\n;\n \n// Array of events, order of events not guaranteed.\n\n    \npublic\n \nint\n \nnumOfEvents\n;\n \n// The number of events in the event array.\n\n\n\n\n\n\nThe simulator needs to keep track of three states:\n\n\n\n\nis a customer being served?\n\n\nis a customer waiting?\n\n\nif a customer is waiting, when did he start waiting?\n\n\n\n\nThese states are represented as:\n\n\n1\n2\n3\n    \npublic\n \nboolean\n \ncustomerBeingServed\n;\n \n// is a customer currently being served?\n\n    \npublic\n \nboolean\n \ncustomerWaiting\n;\n \n// is a customer currently waiting?\n\n    \npublic\n \ndouble\n \ntimeStartedWaiting\n;\n \n// the time the current waiting customer started waiting\n\n\n\n\n\n\n\nRemember we are interested in the following statistics:\n\n\n\n\nWhat is the average waiting time for customers that have been served?\n\n\nHow many customers are served?\n\n\nHow many customers left without being served?\n\n\n\n\nwhich can be computed from the following members:\n\n\n1\n2\n3\n    \npublic\n \ndouble\n \ntotalWaitingTime\n;\n \n// total time everyone spent waiting\n\n    \npublic\n \nint\n \ntotalNumOfServedCustomer\n;\n \n// how many customer has waited\n\n    \npublic\n \nint\n \ntotalNumOfLostCustomer\n;\n \n// how many customer has been lost\n\n\n\n\n\n\n\nFinally, for debugging purposes, the simulator assigns unique IDs 1, 2, 3, ... to the customers, in the order of their arrivals.  It then keeps track of the ID of the customer being served (if any) and the customer waiting to be served.\n\n\n1\n2\n3\n    \npublic\n \nint\n \nlastCustomerId\n;\n \n// starts from 0 and increases as customer arrives.\n\n    \npublic\n \nint\n \nservedCustomerId\n;\n \n// id of the customer being served, if any\n\n    \npublic\n \nint\n \nwaitingCustomerId\n;\n \n// id of the customer currently waiting, if any\n\n\n\n\n\n\n\nInteraction between \nSimulator\n and \nEvent\n\n\nWe create a \nSimulator\n by calling the method:\n\n1\n  \nstatic\n \nSimulator\n \ncreateSimulator\n()\n \n{..}\n\n\n\n\n\nand an \nEvent\n by calling the method, specifying \nwhen\n the event will occur, and the \ntype\n of the event.\n\n1\n  \nstatic\n \nEvent\n \ncreateEvent\n(\ndouble\n \nwhen\n,\n \nint\n \ntype\n)\n  \n{..}\n\n\n\n\n\n\nWe can schedule the event \ne\n to be executed by simulator \nsim\n by calling:\n\n1\n  \nstatic\n \nboolean\n \nscheduleEventInSimulator\n(\nEvent\n \ne\n,\n \nSimulator\n \nsim\n)\n \n{..}\n\n\n\n\n\nThis method will return \ntrue\n if the event is scheduled successfully, \nfalse\n if the simulator run out of space to store the event (i.e., \nMAX_NUMBER_OF_EVENTS\n is reached).\n\n\nWe always execute the events in increasing sequence of their time.  Once the simulator starts running, it repeatedly finds the next event with the smallest timestamp (i.e., earliest event), removes it from the list of events, and execute the event.  The simulator stops when there is no more event to run.\n\n\n1\n2\n3\n4\n5\n6\n  \nstatic\n \nvoid\n \nrunSimulator\n(\nSimulator\n \nsim\n)\n \n{\n\n    \nwhile\n \n(\nsim\n.\nnumOfEvents\n \n>\n \n0\n)\n \n{\n\n      \nEvent\n \ne\n \n=\n \ngetNextEarliestEvent\n(\nsim\n);\n\n      \nsimulateEvent\n(\nsim\n,\n \ne\n);\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nHere, \ne = getNextEarliestEvent(sim)\n removes and returns the earliest event in the simulator, and \nsimulateEvent(sim, e)\n update the states of the simulator according to the type of the event \ne\n.\n\n\nSimulated System\n\n\nThe logic of the system being simulator (i.e., the behavior of customers and server) is implemented in \nsimulateEvent\n.  There are four methods being called from here:\n\n\n\n\nserveCustomer(sim, time, id)\n: called to start serving a customer with ID \nid\n\n\nmakeCustomerWait(sim, time, id)\n: called to make the customer with ID \nid\n wait\n\n\ncustomerLeaves(sim, time, id)\n: called when the customer with ID \nid\n who just arrived leaves immediately (as someone else is waiting)\n\n\nservedWaitingCustomer(sim, time)\n: called to start serving the customer that is currently waiting.\n\n\n\n\nYou should read through \nLabOneA.java\n and clarify if you are not sure about any part of the given code.\n\n\nInput and Output\n\n\nThe input consists of a sequence of double values, each is the arrival time of a customer (in any order).  We can read from standard input (if no command line argument is given)\n\n1\n2\njava LabOneA\njava LabOneA  < TESTDATA1.txt\n\n\n\n\nor read from a given filename\n\n1\njava LabOneA TESTDATA1\n\n\n\n\n\nGiven an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with input where no two events occur at exactly the same time.\n\n\nThe test cases and outputs\n1\n should be:\n\n\n\n\n\n\n\n\nTest Case\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.000 1 0\n\n\n\n\n\n\n2\n\n\n0.000 4 0\n\n\n\n\n\n\n3\n\n\n0.450 2 8\n\n\n\n\n\n\n4\n\n\n0.614 7 0\n\n\n\n\n\n\n5\n\n\n0.405 76 24\n\n\n\n\n\n\n\n\nNote that the skeleton we gave to you already produces the output above.  You just need to ensure that after changing the code to OO style, the output remains the same.  Of course, as usual, producing the correct output for five test cases does not guarantee that your code is correct.\n\n\nYour Task\n\n\nThe given \nLabOneA.java\n is written in C style, no minimal encapsulation.  As you read through the code, you should appreciate how messy and difficult to understand the code is.\n\n\nYour mission, in Lab 2, is to rewrite the code using encapsulation, applying OO paradigm, properly maintain the abstraction barrier when the objects interact.  See the Section on Goals above.  Here are some rules:\n\n\n\n\n\n\nYou can add as many classes as you like.  Each class must be in its own \n.java\n file\n\n\n\n\n\n\nThe \nmain\n method should remain in a class named \nLabOneA\n.  We must be able to run your code with:\n\n1\n2\njavac *.java\njava LabOneA < TESTDATA1.txt\n\n\n\n\n\n\n\n\n\nYou must not change the formatting of the \nlast line\n of output (\nSystem.out.printf(\"%.3f %d %d\", ..\")\n).  We rely on it to check for correctness of your logic.\n\n\n\n\n\n\nYour code should follow the \nCS2030 Coding Style\n\n\n\n\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit1a\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab1a\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nWe will run \ncheckstyle\n to check your code against the CS2030 Java Coding Convention upon submission. \n\n\nThis lab is not graded.  But do submit anyway so that we have a record that you have done the lab.\n\n\nTo get individual feedback on your lab solution, please talk to your lab TAs.\n\n\nExtra Java Stuff\n\n\nYou are exposed to three new Java syntax/class in this Lab:\n\n\n\n\nNested classes: In the code given to you, we define \nSimulator\n and \nEvent\n within the class \nLabOneA\n.  This is called \nnested class\n in Java.  Usually, this is useful if we need to create a class that is only useful to another class.  We can group logically relevant classes together.\n\n\nassert\n keyword: \nassert\n works like in C and Python.  You use \nassert\n to check for conditions that have to be true in your code.  If an assertion fails, the program will bail, informing you what went wrong.  This is useful to catch bugs quickly.  Use this by passing a \n-ea\n (enable assertions) flag when running a Java program e.g. \njava -ea LabOneA TESTDATA1.txt\n\n\nFileReader\n: a useful class for reading a stream of characters from a file.\n\n\n\n\n\n\n\n\n\n\n\n\nAfter piping through \ntail\n (e.g., \njava LabOneA < TESTDATA1.txt | tail -1\n)\u00a0\n\u21a9",
            "title": "1a. Simulator v1.0"
        },
        {
            "location": "/lab1a/index.html#lab-1a",
            "text": "Submission deadline: 2359, Friday, February 9, 2018.",
            "title": "Lab 1a"
        },
        {
            "location": "/lab1a/index.html#prerequisites",
            "text": "Assume that students are already familiar with:   the  CS2030 laboratory environment  how to  compile and run Java programs  comfortable with Java syntax  looking up Java API documentation  understand the concepts of encapsulation and using encapsulated objects",
            "title": "Prerequisites"
        },
        {
            "location": "/lab1a/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be more comfortable with looking at a complex problem and identify data and procedures that should be kept within an abstraction barrier.  In other words, be more comfortable with creating own encapsulated class.  be more comfortable with basic Java syntax and semantics, particularly when creating classes from scratch.  be comfortable with following a given coding convention.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab1a/index.html#setup",
            "text": "Login to  cs2030-i , copy the files from  ~cs2030/lab1a  to your local directory under your home  ~/lab1a .  You should see one java file ( LabOneA.java ) and a few data files ( TESTDATA1.txt ,  TESTDATA2.txt , ...,  TESTDATA5.txt )",
            "title": "Setup"
        },
        {
            "location": "/lab1a/index.html#goals",
            "text": "LabOneA.java  implements a working discrete event simulator that simulates customers being served by a server.  It is written in procedural style with  no encapsulation .  The goal, in this lab, is to rewrite this simulator with OO style, by properly using encapsulation to create abstraction barriers to the various variables and methods.  Here and some hints:   Think about the problem that you are solving: what are the nouns?  These are good candidates for classes.   For each class, what are the attributes/properties relevant to the class?  These are good candidates for fields in the class.  For each class, what are their responsibilities?  What can they  do ?  These are good candidates for methods in the class.  How do the objects of each class interact?  These are good candidates for public methods.   Note that the goal of this lab and, and of CS2030 in general, is  NOT  to solve the problem with the cleverest and the shortest piece of code possible.  For instance, you might notice that you can solve Lab 1a with only a few variables and an array.  But such solution is hard to extend and modify.  In CS2030, our goal is to produce a software that can easily evolve and be modified, with a reduced risk of introducing bugs while doing so.  Note that Lab 1a is the first of a series of labs, where we introduce new requirements or modify existing ones in every lab (not  unlike what software engineers face in the real world ).  We will slowly evolve the simulator into something more general and will simulate a more complex server and customer behaviors in our simulation.  Thus, making sure that your code will be able to adapt to new problem statements is the key.  Trying to solve the lab without considering this (such as coming up with a solution that computes the average waiting time in only tens of lines of code) and you will likely find yourself painted into a corner and have to re-write much of your solution to handle the new requirement.",
            "title": "Goals"
        },
        {
            "location": "/lab1a/index.html#grading",
            "text": "This lab is not graded.  But, it will be extended to Lab 1b, which is graded.  Coming out with a good encapsulation will make your Lab 1b much easier to solve. \nYou may be tempted to wait for Lab 1b to be released and solve Lab 1a and 1b together -- unless you are very sure you can handle it, do not do this.  The purpose of Lab 1a is to give you enough time to ponder \nover different designs and get feedback from your Lab TAs.",
            "title": "Grading"
        },
        {
            "location": "/lab1a/index.html#discrete-event-simulator",
            "text": "A discrete event simulator is a software that simulates a system (often modeled after the real world) with events and states.  An event occurs at a particular time, and each event alters the states of the system and may generate more events.  A discrete event simulator can be used to study many complex real-world systems.  The term  discrete  refers to the fact that, the states remain unchanged between two events, and therefore, the simulator can  jump  from the time of one event to another, instead of following the clock in real time.  The simulator typically keeps track of some statistics to measure the performance of the system.  In this lab, we start with simulating a specific situation:   We have a shop with a  server  (a person providing service to the customer).  The server can serve one customer at a time.  We assume for now that the server takes constant time to serve a customer.\n  The time taken to serve is called  service time .  When a customer arrives:  if the server is idle (not serving any customer), then the server serves the customer immediately (no waiting).  if the server is serving another customer, then the customer that just arrives waits.  if the server is serving one customer, and another customer is waiting, then the customer that just arrives just leave (no waiting) and go elsewhere.  In other words, there is at most one waiting customer.    When the server is done serving a customer:  the served customer leaves.  if there is another customer waiting, the server starts serving the waiting customer immediately.  if there is no waiting customer, then server becomes idle again.     We are interested in the following.  Given a sequence of customer arrivals (time of each arrival is given):   What is the average waiting time for customers that have been served?  How many customers are served?  How many customers left without being served?   In your Lab 1a, you are given a simple discrete event simulator to answer the questions above.  There are two classes:  Simulator  and  Event .",
            "title": "Discrete Event Simulator"
        },
        {
            "location": "/lab1a/index.html#class-event",
            "text": "The event class is written in a procedural style, not unlike a  struct  in C.  All members are public, and there is no method.  Each  Event  keeps track of two information: the  time  the event occurs, and  eventType , which signifies what type of events is this.  Instead of using time like 9:45 pm, we simply and represent time as a double value.  1\n2\n3\n4    static   class   Event   { \n     public   double   time ;   // The time this event will occur \n     public   int   eventType ;   // The type of event, indicates what should happen when an event occurs.  \n   }    We handle two types of events for this particular scenario: an event of type  CUSTOMER_ARRIVE  means that a customer arrives during this event; while an event of type  CUSTOMER_DONE  means that the customer is done being served.   CUSTOMER_ARRIVE  events are created based on the given input.   CUSTOMER_DONE  events are created and scheduled to occur sometime in the future when a customer is being served.  1\n2    public   static   final   int   CUSTOMER_ARRIVE   =   1 ; \n   public   static   final   int   CUSTOMER_DONE   =   2 ;",
            "title": "Class Event"
        },
        {
            "location": "/lab1a/index.html#class-simulator",
            "text": "The simulator class is again written in procedural style.  All members are public, and there is no method.  The  Simulator  class contains two configuration parameters,  MAX_NUMBER_OF_EVENTS  indicates the maximum number of events that the simulator can store at one time;  SERVICE_TIME  indicates the time the server takes to serve a customer. 1\n2      public   static   final   int   MAX_NUMBER_OF_EVENTS   =   100 ;   // Maximum number of events \n     public   static   final   double   SERVICE_TIME   =   1.0 ;   // Time spent serving a customer    The  events  is an array of  Event  that store all events scheduled for the future in the simulator. 1\n2      public   Event []   events ;   // Array of events, order of events not guaranteed. \n     public   int   numOfEvents ;   // The number of events in the event array.    The simulator needs to keep track of three states:   is a customer being served?  is a customer waiting?  if a customer is waiting, when did he start waiting?   These states are represented as:  1\n2\n3      public   boolean   customerBeingServed ;   // is a customer currently being served? \n     public   boolean   customerWaiting ;   // is a customer currently waiting? \n     public   double   timeStartedWaiting ;   // the time the current waiting customer started waiting    Remember we are interested in the following statistics:   What is the average waiting time for customers that have been served?  How many customers are served?  How many customers left without being served?   which can be computed from the following members:  1\n2\n3      public   double   totalWaitingTime ;   // total time everyone spent waiting \n     public   int   totalNumOfServedCustomer ;   // how many customer has waited \n     public   int   totalNumOfLostCustomer ;   // how many customer has been lost    Finally, for debugging purposes, the simulator assigns unique IDs 1, 2, 3, ... to the customers, in the order of their arrivals.  It then keeps track of the ID of the customer being served (if any) and the customer waiting to be served.  1\n2\n3      public   int   lastCustomerId ;   // starts from 0 and increases as customer arrives. \n     public   int   servedCustomerId ;   // id of the customer being served, if any \n     public   int   waitingCustomerId ;   // id of the customer currently waiting, if any",
            "title": "Class Simulator"
        },
        {
            "location": "/lab1a/index.html#interaction-between-simulator-and-event",
            "text": "We create a  Simulator  by calling the method: 1    static   Simulator   createSimulator ()   {..}   \nand an  Event  by calling the method, specifying  when  the event will occur, and the  type  of the event. 1    static   Event   createEvent ( double   when ,   int   type )    {..}    We can schedule the event  e  to be executed by simulator  sim  by calling: 1    static   boolean   scheduleEventInSimulator ( Event   e ,   Simulator   sim )   {..}   \nThis method will return  true  if the event is scheduled successfully,  false  if the simulator run out of space to store the event (i.e.,  MAX_NUMBER_OF_EVENTS  is reached).  We always execute the events in increasing sequence of their time.  Once the simulator starts running, it repeatedly finds the next event with the smallest timestamp (i.e., earliest event), removes it from the list of events, and execute the event.  The simulator stops when there is no more event to run.  1\n2\n3\n4\n5\n6    static   void   runSimulator ( Simulator   sim )   { \n     while   ( sim . numOfEvents   >   0 )   { \n       Event   e   =   getNextEarliestEvent ( sim ); \n       simulateEvent ( sim ,   e ); \n     } \n   }    Here,  e = getNextEarliestEvent(sim)  removes and returns the earliest event in the simulator, and  simulateEvent(sim, e)  update the states of the simulator according to the type of the event  e .",
            "title": "Interaction between Simulator and Event"
        },
        {
            "location": "/lab1a/index.html#simulated-system",
            "text": "The logic of the system being simulator (i.e., the behavior of customers and server) is implemented in  simulateEvent .  There are four methods being called from here:   serveCustomer(sim, time, id) : called to start serving a customer with ID  id  makeCustomerWait(sim, time, id) : called to make the customer with ID  id  wait  customerLeaves(sim, time, id) : called when the customer with ID  id  who just arrived leaves immediately (as someone else is waiting)  servedWaitingCustomer(sim, time) : called to start serving the customer that is currently waiting.   You should read through  LabOneA.java  and clarify if you are not sure about any part of the given code.",
            "title": "Simulated System"
        },
        {
            "location": "/lab1a/index.html#input-and-output",
            "text": "The input consists of a sequence of double values, each is the arrival time of a customer (in any order).  We can read from standard input (if no command line argument is given) 1\n2 java LabOneA\njava LabOneA  < TESTDATA1.txt  \nor read from a given filename 1 java LabOneA TESTDATA1   Given an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with input where no two events occur at exactly the same time.  The test cases and outputs 1  should be:     Test Case  Output      1  0.000 1 0    2  0.000 4 0    3  0.450 2 8    4  0.614 7 0    5  0.405 76 24     Note that the skeleton we gave to you already produces the output above.  You just need to ensure that after changing the code to OO style, the output remains the same.  Of course, as usual, producing the correct output for five test cases does not guarantee that your code is correct.",
            "title": "Input and Output"
        },
        {
            "location": "/lab1a/index.html#your-task",
            "text": "The given  LabOneA.java  is written in C style, no minimal encapsulation.  As you read through the code, you should appreciate how messy and difficult to understand the code is.  Your mission, in Lab 2, is to rewrite the code using encapsulation, applying OO paradigm, properly maintain the abstraction barrier when the objects interact.  See the Section on Goals above.  Here are some rules:    You can add as many classes as you like.  Each class must be in its own  .java  file    The  main  method should remain in a class named  LabOneA .  We must be able to run your code with: 1\n2 javac *.java\njava LabOneA < TESTDATA1.txt     You must not change the formatting of the  last line  of output ( System.out.printf(\"%.3f %d %d\", ..\") ).  We rely on it to check for correctness of your logic.    Your code should follow the  CS2030 Coding Style",
            "title": "Your Task"
        },
        {
            "location": "/lab1a/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit1a   which will copy all files matching  *.java  (and nothing else) from your  ~/lab1a  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  We will run  checkstyle  to check your code against the CS2030 Java Coding Convention upon submission.   This lab is not graded.  But do submit anyway so that we have a record that you have done the lab.  To get individual feedback on your lab solution, please talk to your lab TAs.",
            "title": "Submission"
        },
        {
            "location": "/lab1a/index.html#extra-java-stuff",
            "text": "You are exposed to three new Java syntax/class in this Lab:   Nested classes: In the code given to you, we define  Simulator  and  Event  within the class  LabOneA .  This is called  nested class  in Java.  Usually, this is useful if we need to create a class that is only useful to another class.  We can group logically relevant classes together.  assert  keyword:  assert  works like in C and Python.  You use  assert  to check for conditions that have to be true in your code.  If an assertion fails, the program will bail, informing you what went wrong.  This is useful to catch bugs quickly.  Use this by passing a  -ea  (enable assertions) flag when running a Java program e.g.  java -ea LabOneA TESTDATA1.txt  FileReader : a useful class for reading a stream of characters from a file.       After piping through  tail  (e.g.,  java LabOneA < TESTDATA1.txt | tail -1 )\u00a0 \u21a9",
            "title": "Extra Java Stuff"
        },
        {
            "location": "/lab1b/index.html",
            "text": "Lab 1b\n\n\nSubmission deadline: 2359, Sunday, February 18, 2018.\n\n\nPrerequisites\n\n\nThis lab assumes that students:\n\n\n\n\nhave already attempted Lab 1a\n\n\nhave an understanding of the customer/server system being simulated\n\n\nhave already encapsulated the given code into their appropriate classes\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should appreciate the importance of proper encapsulation and how it can help software engineers deal with changing requirements. \n\n\nSetup\n\n\nThere is no new skeleton code provided.  You are to build your Lab 1b solution based on your Lab 1a.  To setup Lab 1a, do the following.\n\n\n\n\nLogin to \ncs2030-i\n\n\nCopy \n~/lab1a\n to \n~/lab1b\n\n\nRename \nLabOneA.java\n to \nLabOneB.java\n\n\nRename the class \nLabOneA\n to \nLabOneB\n\n\nCopy the test data (\nTESTDATA1.txt\n .. \nTESTDATA7.txt\n) from \n~cs2030/lab1b\n to \n~/lab1b\n.\n\n\n\n\nIf you are still not familiar with how to do the above, please revisit the \nUNIX\n guide.\n\n\nGoals\n\n\nFor Lab 1b, you will be asked to make the following changes to the simulator:\n\n\n\n\nThe shop owner decides to hire more than one servers to avoid losing customers.  So your simulation should now support \nk\nk\n (\nk \\ge 1\nk \\ge 1\n) servers.\n\n\nIt still has enough space for only one waiting customer per server. \n\n\nThe servers are arranged in fixed order, from 1 to k.\n\n\nOnce a customer arrives at the shop:\n\n\nThe customer scans the servers, from 1 to k, and approaches the first idle server he/she found to be served immediately.\n\n\nIf there is no idle server, the customer scans the server, from 1 to k, and waits at the first busy server without a waiting customer that he/she found.  \n\n\nIf every server is busy and already has an existing customer waiting, the customer leaves the shop.\n\n\n\n\nAs a result of this, you might realize that there is a better way to encapsulate the data and the behavior of the various entities in the program.  In which case, you may want to reorganize your classes, create new classes, etc.  Depending on how \"changeable\" your Lab 1a solution is, you may have ended up with more than a trivial change.\n\n\nGrading\n\n\nThis lab contributes 6 marks to your final grade (100 marks).\n\n\n\n\n4 marks for proper abstraction and encapsulation of classes\n\n\n1 marks for coding style\n\n\n1 mark for correctness\n\n\n\n\nInput and Output\n\n\nThe input file format has changed.  The first line of the input file now is an integer, specifying the number of servers in the shop.  The remaining lines contain a sequence of double values, each is the arrival time of a customer (in any order).  \n\n\nRemember: you must not change the formatting of the \nlast line\n of output:\n\n1\nSystem\n.\nout\n.\nprintf\n(\n\"%.3f %d %d\"\n,\n \n..\n\"\n)\n\n\n\n\n\n\nGiven an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.\n\n\nThe test cases and outputs\n1\n should be:\n\n\n\n\n\n\n\n\nTest Case\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.000 1 0\n\n\n\n\n\n\n2\n\n\n0.000 4 0\n\n\n\n\n\n\n3\n\n\n0.350 6 4\n\n\n\n\n\n\n4\n\n\n0.000 7 0\n\n\n\n\n\n\n5\n\n\n0.210 99 1\n\n\n\n\n\n\n6\n\n\n0.664 39 41\n or \n0.665 39 41\n or \n0.667 39 41\n\n\n\n\n\n\n7\n\n\n0.653 46 54\n or \n0.672 46 54\n\n\n\n\n\n\n\n\nAs usual, producing the correct output for test cases above does not guarantee that your code is correct.\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit1b\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab1b\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\nThis is the only way we accept submission for your labs.  We are not able to accept lab submissions via email.\n\n\nPlease read our policies \npolicies\n on late submission and on plagiarism.\n\n\n\n\n\n\n\n\n\n\nAfter piping through \ntail\n (e.g., \njava LabOneB < TESTDATA1.txt | tail -1\n)\u00a0\n\u21a9",
            "title": "1b. Simulator v1.1"
        },
        {
            "location": "/lab1b/index.html#lab-1b",
            "text": "Submission deadline: 2359, Sunday, February 18, 2018.",
            "title": "Lab 1b"
        },
        {
            "location": "/lab1b/index.html#prerequisites",
            "text": "This lab assumes that students:   have already attempted Lab 1a  have an understanding of the customer/server system being simulated  have already encapsulated the given code into their appropriate classes",
            "title": "Prerequisites"
        },
        {
            "location": "/lab1b/index.html#learning-objectives",
            "text": "After completing this lab, students should appreciate the importance of proper encapsulation and how it can help software engineers deal with changing requirements.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab1b/index.html#setup",
            "text": "There is no new skeleton code provided.  You are to build your Lab 1b solution based on your Lab 1a.  To setup Lab 1a, do the following.   Login to  cs2030-i  Copy  ~/lab1a  to  ~/lab1b  Rename  LabOneA.java  to  LabOneB.java  Rename the class  LabOneA  to  LabOneB  Copy the test data ( TESTDATA1.txt  ..  TESTDATA7.txt ) from  ~cs2030/lab1b  to  ~/lab1b .   If you are still not familiar with how to do the above, please revisit the  UNIX  guide.",
            "title": "Setup"
        },
        {
            "location": "/lab1b/index.html#goals",
            "text": "For Lab 1b, you will be asked to make the following changes to the simulator:   The shop owner decides to hire more than one servers to avoid losing customers.  So your simulation should now support  k k  ( k \\ge 1 k \\ge 1 ) servers.  It still has enough space for only one waiting customer per server.   The servers are arranged in fixed order, from 1 to k.  Once a customer arrives at the shop:  The customer scans the servers, from 1 to k, and approaches the first idle server he/she found to be served immediately.  If there is no idle server, the customer scans the server, from 1 to k, and waits at the first busy server without a waiting customer that he/she found.    If every server is busy and already has an existing customer waiting, the customer leaves the shop.   As a result of this, you might realize that there is a better way to encapsulate the data and the behavior of the various entities in the program.  In which case, you may want to reorganize your classes, create new classes, etc.  Depending on how \"changeable\" your Lab 1a solution is, you may have ended up with more than a trivial change.",
            "title": "Goals"
        },
        {
            "location": "/lab1b/index.html#grading",
            "text": "This lab contributes 6 marks to your final grade (100 marks).   4 marks for proper abstraction and encapsulation of classes  1 marks for coding style  1 mark for correctness",
            "title": "Grading"
        },
        {
            "location": "/lab1b/index.html#input-and-output",
            "text": "The input file format has changed.  The first line of the input file now is an integer, specifying the number of servers in the shop.  The remaining lines contain a sequence of double values, each is the arrival time of a customer (in any order).    Remember: you must not change the formatting of the  last line  of output: 1 System . out . printf ( \"%.3f %d %d\" ,   .. \" )    Given an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.  The test cases and outputs 1  should be:     Test Case  Output      1  0.000 1 0    2  0.000 4 0    3  0.350 6 4    4  0.000 7 0    5  0.210 99 1    6  0.664 39 41  or  0.665 39 41  or  0.667 39 41    7  0.653 46 54  or  0.672 46 54     As usual, producing the correct output for test cases above does not guarantee that your code is correct.",
            "title": "Input and Output"
        },
        {
            "location": "/lab1b/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit1b   which will copy all files matching  *.java  (and nothing else) from your  ~/lab1b  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.  This is the only way we accept submission for your labs.  We are not able to accept lab submissions via email.  Please read our policies  policies  on late submission and on plagiarism.      After piping through  tail  (e.g.,  java LabOneB < TESTDATA1.txt | tail -1 )\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab2a/index.html",
            "text": "Lab 2a: Simulator v1.2\n\n\nSubmission deadline: 2359, Friday, March 2, 2018.\n\n\nPrerequisites\n\n\nThis lab assumes that students:\n\n\n\n\nare already familiar with \nsimple UNIX commands\n to copy files.\n\n\nhave already attempted Lab 1b\n\n\nhave an understanding of the customer/server system being simulated\n\n\nhave already encapsulated the given code into their appropriate classes\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe familiar with how to package a program the into a \njar\n application\n\n\nbe familiar with \njavadoc\n syntax\n and comfortable with documenting the code with \njavadoc\n\n\nbe comfortable reading a Java Collection Framework documentation and use one of the classes provided\n\n\nappreciate the usefulness of Java Collection Framework by seeing how much shorter and cleaner the resulting code is\n\n\nbe familiar with the \nRandomGenerator\n class provided\n\n\nbe ready for the next graded lab, Lab 2b.\n\n\n\n\nSetup\n\n\nSample code that solves \nLab 1b\n is provided (under \n~cs2030/lab1b/sample\n on the VM \ncs2030-i\n).   You are free to build on top of the given code, or build on top of your own Lab 1b solution.\n\n\n\n\nLogin to \ncs2030-i\n\n\nCopy \n~cs2030/lab2a\n to \n~/lab2a\n\n\n\n\nYou should see a file \nRandomGenerator.java\n, four test files (\nTESTDATA1.txt\n to \nTESTDATA4.txt\n) and four trace files (\nOUTPUT1.txt\n to \nOUTPUT2.txt\n).  You should copy either your solution or our sample solution for Lab 1b to \n~/lab2a\n.\n\n\nGoals\n\n\nFor Lab 2a, there are two sets of tasks.  The first involves learning more about the tools that Java Development Kit (JDK) provides to help us write and generate documentation, and to package our application into a single executable binary.  The second involves changing the code to use Java Collection Framework as well as to generate random events.\n\n\nWriting and Generating Javadoc\n\n\nFrom Lab 2a onwards, you are required to document your classes and methods with Javadoc comments.  You can see examples from the skeleton code given earlier.  For more details, see the \njavadoc\n guide.\n\n\nYou should document all your methods and classes (including private ones).\n\n\nPackaging and Creating JAR\n\n\nSo far, our application consists of a set of class files.  For others to run the application, they need a copy of all the class files.  One could zip up all the class files and share the zip file, but still, the others have to figure out which is that main class contains the \nmain\n method.\n\n\nJava has a tool that combines all the class files in one Java ARchive (JAR) file.  We can include a manifest (default name is \nmanifest.txt\n) in the JAR which specifies which is the main class with the \nmain\n method.  \n\n\nOnce the jar is created, we can disseminate the jar file to others to run.  You have seen an example -- the \ncheckstyle\n tool under \n~cs2030/bin\n is a \njar\n file!\n\n\nCreating a package\n\n\nRecall that Java has a higher-level of abstraction barrier called \npackage\n.  So far, our classes have been included in the default package.  In this lab, you will put your classes into a package called \ncs2030.simulator\n.  You can achieve this by adding the line \n\n\n1\npackage\n \ncs2030.simulator\n;\n\n\n\n\n\n\n\non top of every \n.java\n file.\n\n\nThe package name is typically written in a hierarchical manner using the \".\" notations.  The name also implies the location of the \n.java\n files and the \n.class\n files.  For this reason, you can no longer store the \n.java\n files under \n~/lab2a\n directly.  Instead, you should put them in the directory \n~/lab2a/cs2030/simulator\n. \n\n\nCreating and Executing a JAR\n\n\nTo create a jar, we first need to create a \nmanifest.txt\n file to tell JAR what is the main class.   To do this, create a new text file named \nmanifest.txt\n under \n~/lab2a\n and add the following lines:\n\n\n1\nMain-Class: cs2030.simulator.LabTwoA\n\n\n\n\n\n\n\n\nCommon Error\n\n\nThe whitespace after \n:\n is required.  Also, make sure that the line above\nends with a new line.  \n\n\n\n\nNow, to compile, create a jar file, and run, here is the typical workflow.  \n\n\nIn \n~/lab2a\n, run:\n\n\n1\njavac cs2030/simulator/*.java\n\n\n\n\n\n\nto compile the classes, followed by\n\n\n1\njar cvfm lab2a.jar manifest.txt cs2030/simulator/*class\n\n\n\n\n\n\nto create a JAR file called \nlab2a.jar\n containing \nmanifest.txt\n and the class files.  The flags \ncvfm\n stands for create (\nc\n), be verbose (\nv\n), use the file name (\nf\n) \nlab2a.jar\n, and use the manifest (\nm\n) \nmanifest.txt\n.\n\n\nNow that you have a \nlab2a.jar\n file, you can run it with:\n\n\n1\njava -cp . -jar lab2a.jar TESTDATA1.txt \n\n\n\n\n\n\nPriority Queuing\n\n\nThe next change you need to do in this assignment is to use one of the Java Collection classes to manage the events.  In \nLabOneB.java\n, we kept all the events in an array, and scanned through it to find the event with the smallest (i.e., earliest) timestamp.  This is not efficient, since scanning through all the events incurs a running time that increases linearly with the number of events\n1\n.\n\n\nJava Collection provides a class that is perfect for our use: \nPriorityQueue<E>\n.  A \nPriorityQueue\n keeps a collection of elements, the elements are given certain priority.  Elements can be added with \nadd(E e)\n method.  To retrieve and remove the element with the highest priority, we use the \npoll()\n method, which returns an object of type \nE\n, or \nnull\n is the queue is empty.\n\n\nIn our case, the event with the smallest timestamp has the highest priority.  To tell the \nPriorityQueue<E>\n class how to order the events so that smaller timestamp has higher priority, we use the \nPriorityQueue<E>\n constructor\n that takes in a \nComparator\n object, just like we see in \nLecture 6\n.\n\n\nIf you design is right, you should only change the code in four places: (i) initialize list of events, (ii) schedule an event, (iii) get the next event, (iv) checking if there is still an event.\n\n\n(Hint: You should be able to implement a \nComparator\n without getter \ngetTime()\n)\n\n\nYou should implement this change first\n, since you can do a sanity check of your correctness against the result of Lab 1b using the test data \nfrom\n Lab 1b.\n\n\nRandomized Arrival and Service Time\n\n\nNext, we are going to change how the arrival time and service time is specified, so that we can easily simulate different settings (e.g., a more efficient server with faster service time, more arrivals during weekends, etc).\n\n\nRandom\n\n\nFirst, an introduction to random number generation.  A random number generator is an entity that spews up one random number after another.  We, however, cannot generate a truly random number algorithmically.  We can only generate a \npseudo\n random number.  A pseudo-random number generator can be initialized with a \nseed\n.  A pseudo-random number generator, when initialized with the same \nseed\n, always produces the same sequence of (seemingly random) numbers.\n\n\nJava provides a class \njava.util.Random\n that encapsulates a pseudo-random number generator.  We can create a random number generator with a seed:\n\n\n1\nRandom\n \nrng\n \n=\n \nnew\n \nRandom\n(\n1\n);\n\n\n\n\n\n\n\nWe can then call \nrng.nextDouble()\n repeatedly to generate random numbers between 0 and 1.\n\n\nIn the demo below, we see that creating a \nRandom\n object with the same seed of 2 towards the end leads to the same sequence of random doubles being generated.\n\n\n\n\n\nUsing a fixed seed is important for testing, since the execution of the program will be deterministic, even when random numbers are involved.\n\n\nThe \nRandomGenerator\n class\n\n\nWe have written a \nRandomGenerator\n class that encapsulates different random number generators for use in our simulator.  Each random number generator generates a different stream of random numbers.  The constructor for \nRandomGenerator\n takes in three parameters:\n\n\n\n\nint seed\n is the base seed for the random number generators.  Each random number generator uses a different seed derived from this argument.\n\n\ndouble lambda\n is the arrival rate (see below).\n\n\ndouble mu\n is the service rate (see below).\n\n\n\n\nArrival Time\n\n\nIn Lab 1, the arrival time is given in the input text file.  This approach is less flexible and requires another program to generate the input file.  Further, the original code creates \nall\n the arrival events before the simulation starts, and therefore limits the total number of arrivals to the size of the initial array \nevents\n.\n\n\nWe are going to improve this part of the program, by generating the arrival one after another.  To do this, we need to generate a \nrandom inter-arrival time\n.  The inter-arrival time is usually modeled as an exponential random variable, characterized by a single parameter \n\\lambda\n\\lambda\n (\nlambda\n), known as \narrival rate\n.\n\n\nMathematically, the inter-arrival time can be generated with \n-\\ln(U)/\\lambda\n-\\ln(U)/\\lambda\n, where \nU\nU\n is a random variable between 0 and 1\n2\n.\n\n\n\n\nEvery time an arrival event is processed, it generates another arrival event and schedules it.\n\n\n\n\nIf there are still more customer to simulator, we generate the next arrival event with a timestamp of \nT\nT\n + now, where \nT\nT\n is generated with the method \ngenInterArrivalTime(lambda)\n of the class \nRandomGenerator\n.\n\n\n\n\n\n\nWhen we first start the simulator, we need to generate the first arrival event with timestamp 0.\n\n\n\n\n\n\nService Time\n\n\nIn Lab 1, the service time is constant, which is not always realistic. We are going to model the service time as an exponential random variable, characterized by a single parameter, \nservice rate\n \n\\mu\n\\mu\n (\nmu\n).  We can generate the service time with the method \ngenServiceTime(mu)\n from the class \nRandomGenerator\n.\n\n\n\n\nEvery time a customer is being served, we generate a \"done\" event and schedule it (just like we did it in Lab 1).\n\n\nThe \"done\" event generated will have a timestamp of \nT\nT\n + now, where \nT\nT\n is \nno longer constant \nSERVICE_TIME\n, but instead is generated with the method \ngenServiceTime\n from the class \nRandomGenerator\n.\n\n\n\n\n\n\nADDITIONAL REQUIREMENT\n\n\nHow long it takes to service a customer depends on the customer (what service is required or how many items is in the shopping cart).  Hence, in this lab, we would like the service time to be a property associated with the customer.  In other words, the service time should be a member of the \nCustomer\n class and is initialized when the customer arrives.\n\n\n\n\nNote that \nwe should only have a single random number generator\n in the simulation. (hint: what access modifier should we use?)\n\n\nGrading\n\n\nThis lab is ungraded.  But, you should complete it and submit it anyway for our records.  Completing this lab will get your ready for Lab 2b.\n\n\nInput and Output\n\n\nThe input file format has changed.  The input file for Lab 2a contains the following:\n\n\n\n\nThe first line is an integer, which is the base seed to the \nRandomGenerator\n object\n\n\nThe second line is an integer, which is the number of servers\n\n\nThe third line is an integer, which is the number of customers (i.e, the number of arrival events) to simulate\n\n\nThe fourth line is a double, which is the parameter \nlambda\nlambda\n\n\nThe last line is a double, which is the parameter \nmu\nmu\n\n\n\n\nRemember: you must not change the formatting of the \nlast line\n of output:\n\n1\nSystem\n.\nout\n.\nprintf\n(\n\"%.3f %d %d\"\n,\n \n..\n\"\n)\n\n\n\n\n\n\nGiven an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.\n\n\nThe test cases and outputs\n2\n should be:\n\n\n\n\n\n\n\n\nTest Case\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.000 5 0\n\n\n\n\n\n\n2\n\n\n0.217 8 2\n\n\n\n\n\n\n3\n\n\n1.188 14 6\n\n\n\n\n\n\n4\n\n\n5.263 667 333\n\n\n\n\n\n\n\n\nAs usual, producing the correct output for test cases above does not guarantee that your code is correct.\n\n\nWe have also included traces of the simulation for each of the test cases, which you can find in the files \nOUTPUT1.txt\n to \nOUTPUT4.txt\n.  This should help you debug should your output is different from ours.\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit2a\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab2a/cs2030/simulator\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  We will also check if your code generates javadoc with any warning (should have no warning) and follows the CS2030 Java style guide.\n\n\nYou can submit multiple times, but only the most recent submission will be stored.\n\n\n\n\n\n\n\n\n\n\nFor those who are taking CS2040, we say this is \nO(n)\nO(n)\n time.  A heap-based priority queue, on the other hand, takes \nO(log n)\nO(log n)\n time.\u00a0\n\u21a9\n\n\n\n\n\n\nAfter piping through \ntail\n (e.g., \njar -cp . lab2a.jar < TESTDATA1.txt | tail -1\n)\u00a0\n\u21a9\n\u21a9",
            "title": "2a. Simulator v1.2"
        },
        {
            "location": "/lab2a/index.html#lab-2a-simulator-v12",
            "text": "Submission deadline: 2359, Friday, March 2, 2018.",
            "title": "Lab 2a: Simulator v1.2"
        },
        {
            "location": "/lab2a/index.html#prerequisites",
            "text": "This lab assumes that students:   are already familiar with  simple UNIX commands  to copy files.  have already attempted Lab 1b  have an understanding of the customer/server system being simulated  have already encapsulated the given code into their appropriate classes",
            "title": "Prerequisites"
        },
        {
            "location": "/lab2a/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be familiar with how to package a program the into a  jar  application  be familiar with  javadoc  syntax  and comfortable with documenting the code with  javadoc  be comfortable reading a Java Collection Framework documentation and use one of the classes provided  appreciate the usefulness of Java Collection Framework by seeing how much shorter and cleaner the resulting code is  be familiar with the  RandomGenerator  class provided  be ready for the next graded lab, Lab 2b.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab2a/index.html#setup",
            "text": "Sample code that solves  Lab 1b  is provided (under  ~cs2030/lab1b/sample  on the VM  cs2030-i ).   You are free to build on top of the given code, or build on top of your own Lab 1b solution.   Login to  cs2030-i  Copy  ~cs2030/lab2a  to  ~/lab2a   You should see a file  RandomGenerator.java , four test files ( TESTDATA1.txt  to  TESTDATA4.txt ) and four trace files ( OUTPUT1.txt  to  OUTPUT2.txt ).  You should copy either your solution or our sample solution for Lab 1b to  ~/lab2a .",
            "title": "Setup"
        },
        {
            "location": "/lab2a/index.html#goals",
            "text": "For Lab 2a, there are two sets of tasks.  The first involves learning more about the tools that Java Development Kit (JDK) provides to help us write and generate documentation, and to package our application into a single executable binary.  The second involves changing the code to use Java Collection Framework as well as to generate random events.",
            "title": "Goals"
        },
        {
            "location": "/lab2a/index.html#writing-and-generating-javadoc",
            "text": "From Lab 2a onwards, you are required to document your classes and methods with Javadoc comments.  You can see examples from the skeleton code given earlier.  For more details, see the  javadoc  guide.  You should document all your methods and classes (including private ones).",
            "title": "Writing and Generating Javadoc"
        },
        {
            "location": "/lab2a/index.html#packaging-and-creating-jar",
            "text": "So far, our application consists of a set of class files.  For others to run the application, they need a copy of all the class files.  One could zip up all the class files and share the zip file, but still, the others have to figure out which is that main class contains the  main  method.  Java has a tool that combines all the class files in one Java ARchive (JAR) file.  We can include a manifest (default name is  manifest.txt ) in the JAR which specifies which is the main class with the  main  method.    Once the jar is created, we can disseminate the jar file to others to run.  You have seen an example -- the  checkstyle  tool under  ~cs2030/bin  is a  jar  file!",
            "title": "Packaging and Creating JAR"
        },
        {
            "location": "/lab2a/index.html#creating-a-package",
            "text": "Recall that Java has a higher-level of abstraction barrier called  package .  So far, our classes have been included in the default package.  In this lab, you will put your classes into a package called  cs2030.simulator .  You can achieve this by adding the line   1 package   cs2030.simulator ;    on top of every  .java  file.  The package name is typically written in a hierarchical manner using the \".\" notations.  The name also implies the location of the  .java  files and the  .class  files.  For this reason, you can no longer store the  .java  files under  ~/lab2a  directly.  Instead, you should put them in the directory  ~/lab2a/cs2030/simulator .",
            "title": "Creating a package"
        },
        {
            "location": "/lab2a/index.html#creating-and-executing-a-jar",
            "text": "To create a jar, we first need to create a  manifest.txt  file to tell JAR what is the main class.   To do this, create a new text file named  manifest.txt  under  ~/lab2a  and add the following lines:  1 Main-Class: cs2030.simulator.LabTwoA    Common Error  The whitespace after  :  is required.  Also, make sure that the line above\nends with a new line.     Now, to compile, create a jar file, and run, here is the typical workflow.    In  ~/lab2a , run:  1 javac cs2030/simulator/*.java   to compile the classes, followed by  1 jar cvfm lab2a.jar manifest.txt cs2030/simulator/*class   to create a JAR file called  lab2a.jar  containing  manifest.txt  and the class files.  The flags  cvfm  stands for create ( c ), be verbose ( v ), use the file name ( f )  lab2a.jar , and use the manifest ( m )  manifest.txt .  Now that you have a  lab2a.jar  file, you can run it with:  1 java -cp . -jar lab2a.jar TESTDATA1.txt",
            "title": "Creating and Executing a JAR"
        },
        {
            "location": "/lab2a/index.html#priority-queuing",
            "text": "The next change you need to do in this assignment is to use one of the Java Collection classes to manage the events.  In  LabOneB.java , we kept all the events in an array, and scanned through it to find the event with the smallest (i.e., earliest) timestamp.  This is not efficient, since scanning through all the events incurs a running time that increases linearly with the number of events 1 .  Java Collection provides a class that is perfect for our use:  PriorityQueue<E> .  A  PriorityQueue  keeps a collection of elements, the elements are given certain priority.  Elements can be added with  add(E e)  method.  To retrieve and remove the element with the highest priority, we use the  poll()  method, which returns an object of type  E , or  null  is the queue is empty.  In our case, the event with the smallest timestamp has the highest priority.  To tell the  PriorityQueue<E>  class how to order the events so that smaller timestamp has higher priority, we use the  PriorityQueue<E>  constructor  that takes in a  Comparator  object, just like we see in  Lecture 6 .  If you design is right, you should only change the code in four places: (i) initialize list of events, (ii) schedule an event, (iii) get the next event, (iv) checking if there is still an event.  (Hint: You should be able to implement a  Comparator  without getter  getTime() )  You should implement this change first , since you can do a sanity check of your correctness against the result of Lab 1b using the test data  from  Lab 1b.",
            "title": "Priority Queuing"
        },
        {
            "location": "/lab2a/index.html#randomized-arrival-and-service-time",
            "text": "Next, we are going to change how the arrival time and service time is specified, so that we can easily simulate different settings (e.g., a more efficient server with faster service time, more arrivals during weekends, etc).",
            "title": "Randomized Arrival and Service Time"
        },
        {
            "location": "/lab2a/index.html#random",
            "text": "First, an introduction to random number generation.  A random number generator is an entity that spews up one random number after another.  We, however, cannot generate a truly random number algorithmically.  We can only generate a  pseudo  random number.  A pseudo-random number generator can be initialized with a  seed .  A pseudo-random number generator, when initialized with the same  seed , always produces the same sequence of (seemingly random) numbers.  Java provides a class  java.util.Random  that encapsulates a pseudo-random number generator.  We can create a random number generator with a seed:  1 Random   rng   =   new   Random ( 1 );    We can then call  rng.nextDouble()  repeatedly to generate random numbers between 0 and 1.  In the demo below, we see that creating a  Random  object with the same seed of 2 towards the end leads to the same sequence of random doubles being generated.   Using a fixed seed is important for testing, since the execution of the program will be deterministic, even when random numbers are involved.",
            "title": "Random"
        },
        {
            "location": "/lab2a/index.html#the-randomgenerator-class",
            "text": "We have written a  RandomGenerator  class that encapsulates different random number generators for use in our simulator.  Each random number generator generates a different stream of random numbers.  The constructor for  RandomGenerator  takes in three parameters:   int seed  is the base seed for the random number generators.  Each random number generator uses a different seed derived from this argument.  double lambda  is the arrival rate (see below).  double mu  is the service rate (see below).",
            "title": "The RandomGenerator class"
        },
        {
            "location": "/lab2a/index.html#arrival-time",
            "text": "In Lab 1, the arrival time is given in the input text file.  This approach is less flexible and requires another program to generate the input file.  Further, the original code creates  all  the arrival events before the simulation starts, and therefore limits the total number of arrivals to the size of the initial array  events .  We are going to improve this part of the program, by generating the arrival one after another.  To do this, we need to generate a  random inter-arrival time .  The inter-arrival time is usually modeled as an exponential random variable, characterized by a single parameter  \\lambda \\lambda  ( lambda ), known as  arrival rate .  Mathematically, the inter-arrival time can be generated with  -\\ln(U)/\\lambda -\\ln(U)/\\lambda , where  U U  is a random variable between 0 and 1 2 .   Every time an arrival event is processed, it generates another arrival event and schedules it.   If there are still more customer to simulator, we generate the next arrival event with a timestamp of  T T  + now, where  T T  is generated with the method  genInterArrivalTime(lambda)  of the class  RandomGenerator .    When we first start the simulator, we need to generate the first arrival event with timestamp 0.",
            "title": "Arrival Time"
        },
        {
            "location": "/lab2a/index.html#service-time",
            "text": "In Lab 1, the service time is constant, which is not always realistic. We are going to model the service time as an exponential random variable, characterized by a single parameter,  service rate   \\mu \\mu  ( mu ).  We can generate the service time with the method  genServiceTime(mu)  from the class  RandomGenerator .   Every time a customer is being served, we generate a \"done\" event and schedule it (just like we did it in Lab 1).  The \"done\" event generated will have a timestamp of  T T  + now, where  T T  is  no longer constant  SERVICE_TIME , but instead is generated with the method  genServiceTime  from the class  RandomGenerator .    ADDITIONAL REQUIREMENT  How long it takes to service a customer depends on the customer (what service is required or how many items is in the shopping cart).  Hence, in this lab, we would like the service time to be a property associated with the customer.  In other words, the service time should be a member of the  Customer  class and is initialized when the customer arrives.   Note that  we should only have a single random number generator  in the simulation. (hint: what access modifier should we use?)",
            "title": "Service Time"
        },
        {
            "location": "/lab2a/index.html#grading",
            "text": "This lab is ungraded.  But, you should complete it and submit it anyway for our records.  Completing this lab will get your ready for Lab 2b.",
            "title": "Grading"
        },
        {
            "location": "/lab2a/index.html#input-and-output",
            "text": "The input file format has changed.  The input file for Lab 2a contains the following:   The first line is an integer, which is the base seed to the  RandomGenerator  object  The second line is an integer, which is the number of servers  The third line is an integer, which is the number of customers (i.e, the number of arrival events) to simulate  The fourth line is a double, which is the parameter  lambda lambda  The last line is a double, which is the parameter  mu mu   Remember: you must not change the formatting of the  last line  of output: 1 System . out . printf ( \"%.3f %d %d\" ,   .. \" )    Given an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.  The test cases and outputs 2  should be:     Test Case  Output      1  0.000 5 0    2  0.217 8 2    3  1.188 14 6    4  5.263 667 333     As usual, producing the correct output for test cases above does not guarantee that your code is correct.  We have also included traces of the simulation for each of the test cases, which you can find in the files  OUTPUT1.txt  to  OUTPUT4.txt .  This should help you debug should your output is different from ours.",
            "title": "Input and Output"
        },
        {
            "location": "/lab2a/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit2a   which will copy all files matching  *.java  (and nothing else) from your  ~/lab2a/cs2030/simulator  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  We will also check if your code generates javadoc with any warning (should have no warning) and follows the CS2030 Java style guide.  You can submit multiple times, but only the most recent submission will be stored.      For those who are taking CS2040, we say this is  O(n) O(n)  time.  A heap-based priority queue, on the other hand, takes  O(log n) O(log n)  time.\u00a0 \u21a9    After piping through  tail  (e.g.,  jar -cp . lab2a.jar < TESTDATA1.txt | tail -1 )\u00a0 \u21a9 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab2b/index.html",
            "text": "Lab 2b: Simulator v1.3\n\n\nSubmission deadline: 2359, Sunday, March 11, 2018.\n\n\n(Special extension due to Week 7 being the midterms week)\n\n\nPrerequisites\n\n\nThis lab assumes that students:\n\n\n\n\nhave already attempted Lab 2a\n\n\nhave an understanding of the customer/server system being simulated\n\n\nhave an understanding of inheritance and polymorphism\n\n\nare familiar the basic interfaces with Java Collections Framework\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe more comfortable exploring Java Collections Framework API to look for suitable implementation for a particular data structure\n\n\nbe able to model IS-A relationship with inheritance and differences in behavior with polymorphism\n\n\nappreciate how inheritance and polymorphism makes it easier to extend the code with new behavior\n\n\n\n\nSetup\n\n\nNo new skeleton is given.  You are to build on top of your Lab 2a solution.\n\n\n\n\nLogin to \ncs2030-i\n\n\nCreate a new directory \n~/lab2b\n\n\nCopy the test data and trace output from \n~cs2030/lab2b\n to \n~/lab2b\n\n\nCopy the new \nRandomGenerator.java\n from \n~cs2030/lab2b\n to \n~/lab2b\n\n\nCopy your solution from \n~/lab2a\n to \n~/lab2b\n\n\nRename the class \nLabTwoA\n to \nLabTwoB\n and the file \nLabTwoA.java\n to \nLabTwoB.java\n\n\nUpdate your manifest file to point to the new main class\n\n\n\n\nThere should be 12 test files (\nTESTDATA1.txt\n to \nTESTDATA12.txt\n) and trace files (\nOUTPUT1.txt\n to \nOUTPUT12.txt\n).  \n\n\nGoals\n\n\nFor Lab 2b, you will extend the code to model the more complex behavior of shops, servers, and customers.\n\n\nWriting and Generating Javadoc\n\n\nRemember that from Lab 2a onwards, you are required to document your classes and methods with Javadoc comments.  You can see examples from the skeleton code given earlier.  For more details, see the \njavadoc\n guide.\n\n\nYou should document all your methods and classes (including private ones).\n\n\nPackage\n\n\nAll your classes should be in the \ncs2030.simulator\n package.\n\n\nCustomer Queues\n\n\nThe shop owner noticed that the shop is still losing customers.  As such, he expanded the shop area, so that more customers can queue up.\n\n\nIn your simulator, you should change the shop so that multiple customers can queue up and wait.  Each server should now have a queue of customers.  A customer that chooses to join a queue joins at the tail.  When a server finishes serving a customer, it will serve the next waiting customer at the head of the queue.  The queue is a first-in-first-out (FIFO) structure.  \n\n\n\n\nThink about which interface from Java Collections Framework should you use for this?  Which implementation of this interface is the best?\n\n\n\n\nEach queue has a maximum size \nQ_{max}\nQ_{max}\n.  A customer cannot join a queue that is \nfull\n, i.e., has \nQ_{max}\nQ_{max}\n customers inside. (Note: a customer that is being served is not inside the queue).  \n\n\nWhen a customer arrives, if every queue in the shop is full, then the customer leaves.\n\n\nNote that if \nQ_{max}\nQ_{max}\n is 1, it is the same scenario that you have been working on for Lab 2a.\n\n\n\n\nEvent Queue vs. Customer Queue\n\n\nYour program will have two types of queues, a priority queue for events, and FIFO queues for customers.  Do not mix up the two.  You do not need a priority queue for customers.\n\n\n\n\nTaking A Rest\n\n\nThe (human) servers have to take a rest now and then.  When a server finishes serving a customer, there is a probability \nP_{r}\nP_{r}\n that the server takes a rest for a random amount of time \nT_{r}\nT_{r}\n.   During the resting break, the server does not serve the next waiting customer, but upon returning from the break, the server serves the next customer in queue immediately. \n\n\nP_{r}\nP_{r}\n is a parameter read from the input file.  To decide if the server should rest, we generate a random number uniformly drawn from between 0 and 1, with \nRandomGenerator\n's method \ngenRandomRest()\n.   If the returned value is less than \nP_{r}\nP_{r}\n, the server rests, otherwise, it continues serving the next customer.\n\n\nT_{r}\nT_{r}\n is a random number generated by \nRandomGenerator\n 's method \ngenRestPeriod()\n.  This variable is again an exponential random variable, governed by the resting rate \n\\rho\n\\rho\n.  \n\\rho\n\\rho\n is another parameter to be read from the input file.\n\n\nTo implement this behavior, you should introduce a new event, a \"back\" event, to signify that the server is back from a rest.  This event should be generated and scheduled in the simulator when the server decides to rest.\n\n\nSelf-Checkout\n\n\nTo improve the customer experience and reduce the waiting time, the owner is setting up a number of self-checkout counters, for customers who just need a quick service.  The advantage of self-checkout counters is that they never rest!  Customers queue up for the self-checkout counter just like for the (human) servers.  There is one queue per self-checkout counter.  However, only customers with service time lower than a \nT_{self}\nT_{self}\n can join self-checkout queue.  \nT_{self}\nT_{self}\n is a parameter to be read from the input file.\n\n\nThere are \nN_{self}\nN_{self}\n self-checkout counters in the shop now.  \nN_{self}\nN_{self}\n is a parameter to be read from the input file.\n\n\nCustomer: Choosing Which Queue\n\n\nWhen a customer arrives, he or she has to decide which queue to join.  \n\n\nLike before, the customer will scan through the servers (in order, from 1 to \nk\nk\n) to see if there is an idle server.  If there is one, the customer will go to the server to be served.  In this lab, however, the notion of idle is expanded: a server is idle if it is not serving a customer and is not resting.\n\n\nBut, the customers' behavior differs when there is no idle server.\n\n\nWe model two types of customer behavior.  A greedy customer always chooses the queue with the fewest customers to join.  If there are more than one queues of the same shortest length, the customer breaks a tie by preferring the server with the lowest id (remember that customer scans from 1 to \nk\nk\n).\n\n\nA typical, non-greedy, customer just chooses the first queue among all the queues that are still not full to join.   An arriving customer is a greedy customer with probability \nP_{g}\nP_{g}\n.\n\n\nP_{g}\nP_{g}\n is a parameter read from the input file.  To decide if we should create a typical or greedy customer, we generate a random number uniformly drawn from between 0 and 1, with \nRandomGenerator\n's method \ngenCustomerType()\n.   If the returned value is less than \nP_{g}\nP_{g}\n, a new greedy customer is generated, otherwise, a typical customer is generated.\n\n\n\n\nDebugging\n\n\nTo help with debugging, it would be useful to print out the greedy customer and a typical customer in a different way.\n\n\n\n\nIf the customer requires a service time less then \nT_{self}\nT_{self}\n, it will look for an idle self-checkout counter first.  Failing which it will look for an idle human server.  If the customer fails to find any idle server (self-checkout and human server), it will try to join a queue at the self-checkout counters.  The behavior of a customer joining a queue at the self-checkout counters is \nexactly the same as if the self-checkout counters are human servers\n.\n\n\nIf all the queues at the self-checkout counters are full, or the customer requires a longer service (service time is no less than \nT_{self}\nT_{self}\n, then the customer joins one of the queues of the (human) servers.  The same greedy / no-greedy behavior applies.\n\n\n\n\nGreedy Customer and Self-Checkouts\n\n\nA greedy customer who is eligible for self-checkout counters will prefer the shortest queue among the self-checkout counters over an even shorter queue for human servers.\n\n\n\n\n\n\nAbstraction Principle\n\n\nYou should avoid duplicating your code for customer choosing self-checkout counters and human servers as much as possible.  One way is to treat the self-checkout counters and the human servers as in two different (virtual) shops.\n\n\n\n\nIf a customer cannot find any queue to join, it will leave the shop.\n\n\nSummary\n\n\nTo summarize, you need to handle the following additions.  The additions below are listed in the order you are recommended to work on.\n\n\n\n\nFIFO queues for customers with a capacity of \nQ_{max}\nQ_{max}\n.\n\n\nTwo types of customers, \"greedy\" customers and \"typical\" customers.\n\n\nTwo types of servers, \"human\" servers who may rest after serving a customer and self-checkout counters who never rest.\n\n\nSelf-checkout counters can only be used by, and always be preferred by, customers with small service time.\n\n\nA new type of event, a \"back\" event for when a server comes back from resting.\n\n\n\n\n\n\nModifiability of OO Programs\n\n\nWhile the number of additions above seems like there is a lot of work, using Java Collections Framework, inheritance, and polymorphism, the work needed to extend Lab2a to Lab2b should not be much.  Our solution adds only ~250 lines of code (excluding comments) to implement all these complex behaviors of customers, servers, and shops.\n\n\n\n\nThe \nRandomGenerator\n class\n\n\nThe new \nRandomGenerator\n class now has more methods as shown above.  Its constructor now takes in a new parameter \n\\rho\n\\rho\n.  The list of parameters are:\n\n\n\n\nint seed\n is the base seed for the random number generators.  Each random number generator uses a different seed derived from this argument.\n\n\ndouble lambda\n is the arrival rate.\n\n\ndouble mu\n is the service rate.\n\n\ndouble rho\n is the resting rate.\n\n\n\n\nGrading\n\n\nThis lab is graded and is worth 7% of your final grade.\n\n\n\n\n1 mark for proper javadoc documentation\n\n\n2 marks for correctness\n\n\n4 marks for proper use of OO concepts in modeling the complex shop, customer, and server behaviors.\n\n\n\n\nYou no longer receive marks for following Java coding style, but you will be deducted up to 1 marks if you deviate significantly from the required coding style.\n\n\nInput and Output\n\n\nThe input file format has changed.  The input file for Lab 2b contains the following:\n\n\n\n\nThe first line is an integer, which is the base seed to the \nRandomGenerator\n object\n\n\nThe next line is an integer, which is the number of (human) servers\n\n\nThe next line is an integer, which is the number of self-checkout counters \nN_{self}\nN_{self}\n\n\nThe next line is an integer, which is the maximum queue length \nQ_{max}\nQ_{max}\n\n\nThe next line is an integer, which is the number of customers (i.e, the number of arrival events) to simulate\n\n\nThe next line is a double, which is the parameter \nlambda\nlambda\n\n\nThe next line is a double, which is the parameter \nmu\nmu\n\n\nThe next line is a double, which is the parameter \nrho\nrho\n\n\nThe next line is a double, which is the parameter \nP_{r}\nP_{r}\n\n\nThe next line is a double, which is the parameter \nP_{g}\nP_{g}\n\n\nThe last line is a double, which is the parameter \nT_{self}\nT_{self}\n\n\n\n\nRemember: you must not change the formatting of the \nlast line\n of output:\n\n1\nSystem\n.\nout\n.\nprintf\n(\n\"%.3f %d %d%n\"\n,\n \n..\n\"\n)\n\n\n\n\n\n\nGiven an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.\n\n\nThe test cases and outputs\n1\n should be:\n\n\n\n\n\n\n\n\nTest\n\n\nOutput\n\n\nCustomer Types\n\n\nQ_{max}\nQ_{max}\n\n\nServer Types\n\n\nCan Human Server Rest?\n\n\nRemarks\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.706 4 1\n\n\nTypical\n\n\n1\n\n\nHuman\n\n\nNo\n\n\n\n\n\n\n\n\n2\n\n\n1.042 3 1\n\n\nTypical\n\n\n> 1\n\n\nHuman\n\n\nNo\n\n\n\n\n\n\n\n\n3\n\n\n0.679 4 0\n\n\nGreedy\n\n\n> 1\n\n\nHuman\n\n\nNo\n\n\n\n\n\n\n\n\n4\n\n\n8.725 765 235\n\n\nMixed\n\n\n> 1\n\n\nHuman\n\n\nNo\n\n\n\n\n\n\n\n\n5\n\n\n0.706 4 1\n\n\nTypical\n\n\n1\n\n\nSelf-checkouts\n\n\nNo\n\n\nEveryone uses self-checkouts\n\n\n\n\n\n\n6\n\n\n0 2 3\n\n\nTypical\n\n\n1\n\n\nSelf-checkouts\n\n\nNo\n\n\n\n\n\n\n\n\n7\n\n\n1.049 20 0\n\n\nMixed\n\n\n> 1\n\n\nMixed\n\n\nNo\n\n\n\n\n\n\n\n\n8\n\n\n5.299 867 133\n\n\nMixed\n\n\n> 1\n\n\nMixed\n\n\nNo\n\n\nBased on Test 4\n\n\n\n\n\n\n9\n\n\n1.391 4 1\n\n\nTypical\n\n\n1\n\n\nHuman\n\n\nAlways\n\n\nBased on Test 1\n\n\n\n\n\n\n10\n\n\n1.930 20 0\n\n\nMixed\n\n\n> 1\n\n\nMixed\n\n\nAlways\n\n\nBased on Test 7\n\n\n\n\n\n\n11\n\n\n6.275 792 208\n\n\nMixed\n\n\n> 1\n\n\nMixed\n\n\nAlways\n\n\nBased on Test 8\n\n\n\n\n\n\n12\n\n\n5.608 843 157\n\n\nMixed\n\n\n> 1\n\n\nMixed\n\n\nMaybe\n\n\nBased on Test 11\n\n\n\n\n\n\n\n\nWe suggest that you implement the required additions one-by-one, and use the appropriate test cases above to verify that one addition is working before moving on to implement the next addition.  You can create additional test cases to help you debug.\n\n\nTo help you understand the relatively large number of test cases and parameters above, we have created an Excel spreadsheet, which you can find under \n~cs2030/lab2b\n as well.\n\n\nAs usual, producing the correct output for test cases above does not guarantee that your code is correct.\n\n\nWe have also included traces of the simulation for each of the test cases, which you can find in the files \nOUTPUT1.txt\n to \nOUTPUT12.txt\n.  This should help you debug should your output is different from ours.\n\n\n\n\nUsing \ngrep\n\n\nIf you want to focus on a particular server, say, \nHS4\n, or a customer, say, \nGC180\n, you can use the UNIX \ngrep\n command to filter out lines containing them from a long output or traces.  E.g., \n    \n1\njava lab2b.jar < TESTDATA11.txt | grep HS4\n\n\n\n\n    or\n    \n1\ngrep CS180 OUTPUT12.txt\n\n\n\n\n\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit2b\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab2b/cs2030/simulator\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  We will also check if your code generates javadoc with any warning (should have no warning) and follows the CS2030 Java style guide.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\n\n\n\n\n\n\n\n\nAfter piping through \ntail\n (e.g., \njar -cp . lab2b.jar < TESTDATA1.txt | tail -1\n)\u00a0\n\u21a9",
            "title": "2b. Simulator v1.3"
        },
        {
            "location": "/lab2b/index.html#lab-2b-simulator-v13",
            "text": "Submission deadline: 2359, Sunday, March 11, 2018.  (Special extension due to Week 7 being the midterms week)",
            "title": "Lab 2b: Simulator v1.3"
        },
        {
            "location": "/lab2b/index.html#prerequisites",
            "text": "This lab assumes that students:   have already attempted Lab 2a  have an understanding of the customer/server system being simulated  have an understanding of inheritance and polymorphism  are familiar the basic interfaces with Java Collections Framework",
            "title": "Prerequisites"
        },
        {
            "location": "/lab2b/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be more comfortable exploring Java Collections Framework API to look for suitable implementation for a particular data structure  be able to model IS-A relationship with inheritance and differences in behavior with polymorphism  appreciate how inheritance and polymorphism makes it easier to extend the code with new behavior",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab2b/index.html#setup",
            "text": "No new skeleton is given.  You are to build on top of your Lab 2a solution.   Login to  cs2030-i  Create a new directory  ~/lab2b  Copy the test data and trace output from  ~cs2030/lab2b  to  ~/lab2b  Copy the new  RandomGenerator.java  from  ~cs2030/lab2b  to  ~/lab2b  Copy your solution from  ~/lab2a  to  ~/lab2b  Rename the class  LabTwoA  to  LabTwoB  and the file  LabTwoA.java  to  LabTwoB.java  Update your manifest file to point to the new main class   There should be 12 test files ( TESTDATA1.txt  to  TESTDATA12.txt ) and trace files ( OUTPUT1.txt  to  OUTPUT12.txt ).",
            "title": "Setup"
        },
        {
            "location": "/lab2b/index.html#goals",
            "text": "For Lab 2b, you will extend the code to model the more complex behavior of shops, servers, and customers.",
            "title": "Goals"
        },
        {
            "location": "/lab2b/index.html#writing-and-generating-javadoc",
            "text": "Remember that from Lab 2a onwards, you are required to document your classes and methods with Javadoc comments.  You can see examples from the skeleton code given earlier.  For more details, see the  javadoc  guide.  You should document all your methods and classes (including private ones).",
            "title": "Writing and Generating Javadoc"
        },
        {
            "location": "/lab2b/index.html#package",
            "text": "All your classes should be in the  cs2030.simulator  package.",
            "title": "Package"
        },
        {
            "location": "/lab2b/index.html#customer-queues",
            "text": "The shop owner noticed that the shop is still losing customers.  As such, he expanded the shop area, so that more customers can queue up.  In your simulator, you should change the shop so that multiple customers can queue up and wait.  Each server should now have a queue of customers.  A customer that chooses to join a queue joins at the tail.  When a server finishes serving a customer, it will serve the next waiting customer at the head of the queue.  The queue is a first-in-first-out (FIFO) structure.     Think about which interface from Java Collections Framework should you use for this?  Which implementation of this interface is the best?   Each queue has a maximum size  Q_{max} Q_{max} .  A customer cannot join a queue that is  full , i.e., has  Q_{max} Q_{max}  customers inside. (Note: a customer that is being served is not inside the queue).    When a customer arrives, if every queue in the shop is full, then the customer leaves.  Note that if  Q_{max} Q_{max}  is 1, it is the same scenario that you have been working on for Lab 2a.   Event Queue vs. Customer Queue  Your program will have two types of queues, a priority queue for events, and FIFO queues for customers.  Do not mix up the two.  You do not need a priority queue for customers.",
            "title": "Customer Queues"
        },
        {
            "location": "/lab2b/index.html#taking-a-rest",
            "text": "The (human) servers have to take a rest now and then.  When a server finishes serving a customer, there is a probability  P_{r} P_{r}  that the server takes a rest for a random amount of time  T_{r} T_{r} .   During the resting break, the server does not serve the next waiting customer, but upon returning from the break, the server serves the next customer in queue immediately.   P_{r} P_{r}  is a parameter read from the input file.  To decide if the server should rest, we generate a random number uniformly drawn from between 0 and 1, with  RandomGenerator 's method  genRandomRest() .   If the returned value is less than  P_{r} P_{r} , the server rests, otherwise, it continues serving the next customer.  T_{r} T_{r}  is a random number generated by  RandomGenerator  's method  genRestPeriod() .  This variable is again an exponential random variable, governed by the resting rate  \\rho \\rho .   \\rho \\rho  is another parameter to be read from the input file.  To implement this behavior, you should introduce a new event, a \"back\" event, to signify that the server is back from a rest.  This event should be generated and scheduled in the simulator when the server decides to rest.",
            "title": "Taking A Rest"
        },
        {
            "location": "/lab2b/index.html#self-checkout",
            "text": "To improve the customer experience and reduce the waiting time, the owner is setting up a number of self-checkout counters, for customers who just need a quick service.  The advantage of self-checkout counters is that they never rest!  Customers queue up for the self-checkout counter just like for the (human) servers.  There is one queue per self-checkout counter.  However, only customers with service time lower than a  T_{self} T_{self}  can join self-checkout queue.   T_{self} T_{self}  is a parameter to be read from the input file.  There are  N_{self} N_{self}  self-checkout counters in the shop now.   N_{self} N_{self}  is a parameter to be read from the input file.",
            "title": "Self-Checkout"
        },
        {
            "location": "/lab2b/index.html#customer-choosing-which-queue",
            "text": "When a customer arrives, he or she has to decide which queue to join.    Like before, the customer will scan through the servers (in order, from 1 to  k k ) to see if there is an idle server.  If there is one, the customer will go to the server to be served.  In this lab, however, the notion of idle is expanded: a server is idle if it is not serving a customer and is not resting.  But, the customers' behavior differs when there is no idle server.  We model two types of customer behavior.  A greedy customer always chooses the queue with the fewest customers to join.  If there are more than one queues of the same shortest length, the customer breaks a tie by preferring the server with the lowest id (remember that customer scans from 1 to  k k ).  A typical, non-greedy, customer just chooses the first queue among all the queues that are still not full to join.   An arriving customer is a greedy customer with probability  P_{g} P_{g} .  P_{g} P_{g}  is a parameter read from the input file.  To decide if we should create a typical or greedy customer, we generate a random number uniformly drawn from between 0 and 1, with  RandomGenerator 's method  genCustomerType() .   If the returned value is less than  P_{g} P_{g} , a new greedy customer is generated, otherwise, a typical customer is generated.   Debugging  To help with debugging, it would be useful to print out the greedy customer and a typical customer in a different way.   If the customer requires a service time less then  T_{self} T_{self} , it will look for an idle self-checkout counter first.  Failing which it will look for an idle human server.  If the customer fails to find any idle server (self-checkout and human server), it will try to join a queue at the self-checkout counters.  The behavior of a customer joining a queue at the self-checkout counters is  exactly the same as if the self-checkout counters are human servers .  If all the queues at the self-checkout counters are full, or the customer requires a longer service (service time is no less than  T_{self} T_{self} , then the customer joins one of the queues of the (human) servers.  The same greedy / no-greedy behavior applies.   Greedy Customer and Self-Checkouts  A greedy customer who is eligible for self-checkout counters will prefer the shortest queue among the self-checkout counters over an even shorter queue for human servers.    Abstraction Principle  You should avoid duplicating your code for customer choosing self-checkout counters and human servers as much as possible.  One way is to treat the self-checkout counters and the human servers as in two different (virtual) shops.   If a customer cannot find any queue to join, it will leave the shop.",
            "title": "Customer: Choosing Which Queue"
        },
        {
            "location": "/lab2b/index.html#summary",
            "text": "To summarize, you need to handle the following additions.  The additions below are listed in the order you are recommended to work on.   FIFO queues for customers with a capacity of  Q_{max} Q_{max} .  Two types of customers, \"greedy\" customers and \"typical\" customers.  Two types of servers, \"human\" servers who may rest after serving a customer and self-checkout counters who never rest.  Self-checkout counters can only be used by, and always be preferred by, customers with small service time.  A new type of event, a \"back\" event for when a server comes back from resting.    Modifiability of OO Programs  While the number of additions above seems like there is a lot of work, using Java Collections Framework, inheritance, and polymorphism, the work needed to extend Lab2a to Lab2b should not be much.  Our solution adds only ~250 lines of code (excluding comments) to implement all these complex behaviors of customers, servers, and shops.",
            "title": "Summary"
        },
        {
            "location": "/lab2b/index.html#the-randomgenerator-class",
            "text": "The new  RandomGenerator  class now has more methods as shown above.  Its constructor now takes in a new parameter  \\rho \\rho .  The list of parameters are:   int seed  is the base seed for the random number generators.  Each random number generator uses a different seed derived from this argument.  double lambda  is the arrival rate.  double mu  is the service rate.  double rho  is the resting rate.",
            "title": "The RandomGenerator class"
        },
        {
            "location": "/lab2b/index.html#grading",
            "text": "This lab is graded and is worth 7% of your final grade.   1 mark for proper javadoc documentation  2 marks for correctness  4 marks for proper use of OO concepts in modeling the complex shop, customer, and server behaviors.   You no longer receive marks for following Java coding style, but you will be deducted up to 1 marks if you deviate significantly from the required coding style.",
            "title": "Grading"
        },
        {
            "location": "/lab2b/index.html#input-and-output",
            "text": "The input file format has changed.  The input file for Lab 2b contains the following:   The first line is an integer, which is the base seed to the  RandomGenerator  object  The next line is an integer, which is the number of (human) servers  The next line is an integer, which is the number of self-checkout counters  N_{self} N_{self}  The next line is an integer, which is the maximum queue length  Q_{max} Q_{max}  The next line is an integer, which is the number of customers (i.e, the number of arrival events) to simulate  The next line is a double, which is the parameter  lambda lambda  The next line is a double, which is the parameter  mu mu  The next line is a double, which is the parameter  rho rho  The next line is a double, which is the parameter  P_{r} P_{r}  The next line is a double, which is the parameter  P_{g} P_{g}  The last line is a double, which is the parameter  T_{self} T_{self}   Remember: you must not change the formatting of the  last line  of output: 1 System . out . printf ( \"%.3f %d %d%n\" ,   .. \" )    Given an input, the output might not be deterministic, since if two events occur at exactly the same time, we break the ties arbitrarily.  For this reason, we will only test your code with test inputs where no two events occur at exactly the same time.  The test cases and outputs 1  should be:     Test  Output  Customer Types  Q_{max} Q_{max}  Server Types  Can Human Server Rest?  Remarks      1  0.706 4 1  Typical  1  Human  No     2  1.042 3 1  Typical  > 1  Human  No     3  0.679 4 0  Greedy  > 1  Human  No     4  8.725 765 235  Mixed  > 1  Human  No     5  0.706 4 1  Typical  1  Self-checkouts  No  Everyone uses self-checkouts    6  0 2 3  Typical  1  Self-checkouts  No     7  1.049 20 0  Mixed  > 1  Mixed  No     8  5.299 867 133  Mixed  > 1  Mixed  No  Based on Test 4    9  1.391 4 1  Typical  1  Human  Always  Based on Test 1    10  1.930 20 0  Mixed  > 1  Mixed  Always  Based on Test 7    11  6.275 792 208  Mixed  > 1  Mixed  Always  Based on Test 8    12  5.608 843 157  Mixed  > 1  Mixed  Maybe  Based on Test 11     We suggest that you implement the required additions one-by-one, and use the appropriate test cases above to verify that one addition is working before moving on to implement the next addition.  You can create additional test cases to help you debug.  To help you understand the relatively large number of test cases and parameters above, we have created an Excel spreadsheet, which you can find under  ~cs2030/lab2b  as well.  As usual, producing the correct output for test cases above does not guarantee that your code is correct.  We have also included traces of the simulation for each of the test cases, which you can find in the files  OUTPUT1.txt  to  OUTPUT12.txt .  This should help you debug should your output is different from ours.   Using  grep  If you want to focus on a particular server, say,  HS4 , or a customer, say,  GC180 , you can use the UNIX  grep  command to filter out lines containing them from a long output or traces.  E.g., \n     1 java lab2b.jar < TESTDATA11.txt | grep HS4  \n    or\n     1 grep CS180 OUTPUT12.txt",
            "title": "Input and Output"
        },
        {
            "location": "/lab2b/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit2b   which will copy all files matching  *.java  (and nothing else) from your  ~/lab2b/cs2030/simulator  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  We will also check if your code generates javadoc with any warning (should have no warning) and follows the CS2030 Java style guide.  You can submit multiple times, but only the most recent submission will be graded.      After piping through  tail  (e.g.,  jar -cp . lab2b.jar < TESTDATA1.txt | tail -1 )\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab3/index.html",
            "text": "Lab 3: Infinite List\n\n\nSubmission deadline: 2359, Friday, March 23, 2018.\n\n\nPrerequisites\n\n\nThis lab assumes that students are\n\n\n\n\nfamiliar with the concept of possibly infinite, lazily evaluated, list\n\n\nfamiliar with the \nStream\n operations \nmap\n, \nfilter\n, \nlimit\n, \nreduce\n, \ncount\n, \ntakeWhile\n, \ntoArray\n\n\nfamiliar with creating, passing, storing, and invoking various lambda functions \nPredicate\n \nSupplier\n \nConsumer\n \nFunction\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe comfortable with implementing a lazily evaluated list using lambdas.\n\n\nbe familiar with the concept of memoization in implementing a lazily evaluated list. \n\n\n\n\nSetup\n\n\nThe skeleton code from Lab 3 is available on \ncs2030-i\n under the directory \n~cs2030/lab3\n.  There are two files, \ncs2030/lambda/InfiniteList.java\n, which you are asked to complete, and \nLabThree.java\n, which contains test code to test the behavior of InfiniteList.\n\n\nTask\n\n\nFor Lab 3, you are asked to implement a bunch of methods for the class \nInfiniteList\n, a simple list that supports various lambda operations.  See Grading section below for a (finite) list of methods to complete.\n\n\nYou are still required to\n\n\n\n\nfollow the \nCS2030 Coding Style\n\n\nclearly document your code with \njavadoc\n\n\n\n\nInfiniteList\n\n\nA \nInfiniteList<T>\n is a generic list that can store elements of type \nT\n in order.  Duplicates are allowed.  \n\n\nAn \nInfiniteList\n is similar to \nStream\n in Java, and so, you are \nNOT ALLOWED\n to solve this lab using \nStream\n.\n\n\nYou have seen a simple version of \nInfiniteList\n in class on Monday.  We are going to implement a better and more complicated version of that (so that code from Lecture 8 is not directly usable).\n\n\nThe main differences are:\n\n\n\n\n\n\nLab 3's version of \nInfiniteList\n is not always infinite.  It can be truncated just like a \nStream\n with \nlimit\n and \ntakeWhile\n operations.  So methods such as \nfindFirst\n need to consider the possibility of a finite list, including an empty list.\n\n\n\n\n\n\nWe need to be as lazy as possible and only generate the elements (i.e., invoke the \nSupplier\n's \nget()\n method) when necessary.  Once we generate an element, we should not generate it again.  So, we cache a copy of the value if it has been generated before.  This logic has been written in the \nhead()\n and \ntail()\n method for you.\n\n\n\n\n\n\nDebugging Lazy Operations\n\n\nIn addition, to help with debugging what value has been cached, a \ntoString\n method has been written and provided.  It shows the value of an element if it has been cached, and \n?\n if a value has not been generated.  E.g., from \njshell\n\n\n1\n2\n3\n4\n5\n6\n7\n8\njshell> InfiniteList<Integer> list = InfiniteList.iterate(5, x -> x + 5)\nlist ==> 5,?\n\njshell> list.takeWhile(x -> x < 40).count()\n$22 ==> 7\n\njshell> list\nlist ==> 5,10,15,20,25,30,35,40,?\n\n\n\n\n\n\nThe Grader\n\n\nWe have also provided you with a class \nInfiniteListGrader\n, which is a subclass of \nInfiniteList\n.  This grader class augments the \nSupplier\n for \ngenerate\n and the \nFunction\n for \niterate\n with a \nstatic\n counter, to count how many times these lambdas are invoked.  To be lazy, your code should invoke them only when necessary, reusing existing values for head and tails whenever possible.  \n\n\nThe counter can be retrieved with the \nnumOfEvals()\n method and reset to 0 with the \nreset\n method.  Example,\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\njshell> InfiniteList<Integer> list = InfiniteListGrader.iterate(5, x -> x + 5)\nlist ==> 5,?\n\njshell> list.takeWhile(x -> x < 40).count()\n$26 ==> 7\n\njshell> InfiniteListGrader.numOfEvals();\n$27 ==> 7\n\njshell> InfiniteListGrader.reset();\n\njshell> list.limit(4).toArray()\n$31 ==> Object[4] { 5, 10, 15, 20 }\n\njshell> InfiniteListGrader.numOfEvals();\n$32 ==> 0\n\n\n\n\n\n\nNote that the output of \nnumOfEvals\n depends on the order of invocations, due to caching (aka memoization) of values.  For instance, you will get a different output if you run \nlimit(4).toArray()\n first before \ntakeWhile(x -> x < 40).count()\n in the example above.\n\n\nThe \ncs2030.lambda\n Package\n\n\nBoth \nInfiniteList\n and \nInfiniteListGrader\n belong to the \ncs2030.lambda\n package.  \nLabThree\n imports them for testing.\n\n\nGrading\n\n\nThis lab contributes another 7 marks to your final grade.  Correctly implementing each of the following items get you 1 marks:\n\n\n\n\ngenerate\n, \niterate\n, \nfindFirst\n\n\nreduce\n, \ntoArray\n\n\nmap\n \n\n\nlimit\n\n\nfilter\n \n\n\ntakeWhile\n\n\ncount\n\n\n\n\nYou can get up to 1 mark deduction for violation of style.  Note that \"correct\" here not only means it gives the correct output, but it should be lazy.\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit3\n\n\n\n\n\nwhich will copy the files matching \ncs2030/lambda/*.java\n (and nothing else) from your \n~/lab3\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.",
            "title": "3.  Infinite List"
        },
        {
            "location": "/lab3/index.html#lab-3-infinite-list",
            "text": "Submission deadline: 2359, Friday, March 23, 2018.",
            "title": "Lab 3: Infinite List"
        },
        {
            "location": "/lab3/index.html#prerequisites",
            "text": "This lab assumes that students are   familiar with the concept of possibly infinite, lazily evaluated, list  familiar with the  Stream  operations  map ,  filter ,  limit ,  reduce ,  count ,  takeWhile ,  toArray  familiar with creating, passing, storing, and invoking various lambda functions  Predicate   Supplier   Consumer   Function",
            "title": "Prerequisites"
        },
        {
            "location": "/lab3/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be comfortable with implementing a lazily evaluated list using lambdas.  be familiar with the concept of memoization in implementing a lazily evaluated list.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab3/index.html#setup",
            "text": "The skeleton code from Lab 3 is available on  cs2030-i  under the directory  ~cs2030/lab3 .  There are two files,  cs2030/lambda/InfiniteList.java , which you are asked to complete, and  LabThree.java , which contains test code to test the behavior of InfiniteList.",
            "title": "Setup"
        },
        {
            "location": "/lab3/index.html#task",
            "text": "For Lab 3, you are asked to implement a bunch of methods for the class  InfiniteList , a simple list that supports various lambda operations.  See Grading section below for a (finite) list of methods to complete.  You are still required to   follow the  CS2030 Coding Style  clearly document your code with  javadoc",
            "title": "Task"
        },
        {
            "location": "/lab3/index.html#infinitelist",
            "text": "A  InfiniteList<T>  is a generic list that can store elements of type  T  in order.  Duplicates are allowed.    An  InfiniteList  is similar to  Stream  in Java, and so, you are  NOT ALLOWED  to solve this lab using  Stream .  You have seen a simple version of  InfiniteList  in class on Monday.  We are going to implement a better and more complicated version of that (so that code from Lecture 8 is not directly usable).  The main differences are:    Lab 3's version of  InfiniteList  is not always infinite.  It can be truncated just like a  Stream  with  limit  and  takeWhile  operations.  So methods such as  findFirst  need to consider the possibility of a finite list, including an empty list.    We need to be as lazy as possible and only generate the elements (i.e., invoke the  Supplier 's  get()  method) when necessary.  Once we generate an element, we should not generate it again.  So, we cache a copy of the value if it has been generated before.  This logic has been written in the  head()  and  tail()  method for you.",
            "title": "InfiniteList"
        },
        {
            "location": "/lab3/index.html#debugging-lazy-operations",
            "text": "In addition, to help with debugging what value has been cached, a  toString  method has been written and provided.  It shows the value of an element if it has been cached, and  ?  if a value has not been generated.  E.g., from  jshell  1\n2\n3\n4\n5\n6\n7\n8 jshell> InfiniteList<Integer> list = InfiniteList.iterate(5, x -> x + 5)\nlist ==> 5,?\n\njshell> list.takeWhile(x -> x < 40).count()\n$22 ==> 7\n\njshell> list\nlist ==> 5,10,15,20,25,30,35,40,?",
            "title": "Debugging Lazy Operations"
        },
        {
            "location": "/lab3/index.html#the-grader",
            "text": "We have also provided you with a class  InfiniteListGrader , which is a subclass of  InfiniteList .  This grader class augments the  Supplier  for  generate  and the  Function  for  iterate  with a  static  counter, to count how many times these lambdas are invoked.  To be lazy, your code should invoke them only when necessary, reusing existing values for head and tails whenever possible.    The counter can be retrieved with the  numOfEvals()  method and reset to 0 with the  reset  method.  Example,   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 jshell> InfiniteList<Integer> list = InfiniteListGrader.iterate(5, x -> x + 5)\nlist ==> 5,?\n\njshell> list.takeWhile(x -> x < 40).count()\n$26 ==> 7\n\njshell> InfiniteListGrader.numOfEvals();\n$27 ==> 7\n\njshell> InfiniteListGrader.reset();\n\njshell> list.limit(4).toArray()\n$31 ==> Object[4] { 5, 10, 15, 20 }\n\njshell> InfiniteListGrader.numOfEvals();\n$32 ==> 0   Note that the output of  numOfEvals  depends on the order of invocations, due to caching (aka memoization) of values.  For instance, you will get a different output if you run  limit(4).toArray()  first before  takeWhile(x -> x < 40).count()  in the example above.",
            "title": "The Grader"
        },
        {
            "location": "/lab3/index.html#the-cs2030lambda-package",
            "text": "Both  InfiniteList  and  InfiniteListGrader  belong to the  cs2030.lambda  package.   LabThree  imports them for testing.",
            "title": "The cs2030.lambda Package"
        },
        {
            "location": "/lab3/index.html#grading",
            "text": "This lab contributes another 7 marks to your final grade.  Correctly implementing each of the following items get you 1 marks:   generate ,  iterate ,  findFirst  reduce ,  toArray  map    limit  filter    takeWhile  count   You can get up to 1 mark deduction for violation of style.  Note that \"correct\" here not only means it gives the correct output, but it should be lazy.",
            "title": "Grading"
        },
        {
            "location": "/lab3/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit3   which will copy the files matching  cs2030/lambda/*.java  (and nothing else) from your  ~/lab3  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/lab4a/index.html",
            "text": "Lab 4a: Simulator 2.0\n\n\nSubmission deadline: 2359, Friday, March 30, 2018.\n\n\nPrerequisites\n\n\nThis lab assumes that students:\n\n\n\n\nhave an understanding of the customer/server system being simulated in Lab 1b\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should be able to write classes that are immutable and free from side effects.\n\n\nSetup\n\n\nA skeleton code for Lab 4a is provided.  To setup Lab 4a, do the following.\n\n\n\n\nLogin to \ncs2030-i\n\n\nCopy \n~cs2030/lab4a\n to \n~/lab4a\n\n\n\n\nIf you are still not familiar with how to do the above, please revisit the \nUNIX\n guide.\n\n\nGoals\n\n\nThe skeleton code provided solves Lab 1b in OO style.  The design of the class, however, have been adapted for Lab 4a and 4b, where the goal is to re-implement the solution in a functional style.\n\n\nIn Lab 4a, your task is to change the classes provided so that they become (i) immutable, and (ii)  no side effects.  \n\n\nYou should use the provided skeleton code as the base for modification.  If you wish to modify your own solution to Lab 1b, please feel free to do so as an additional exercise, but do not submit that for Lab 4a/4b.\n\n\nImmutable\n\n\nRecall that immutable does not mean an object cannot be modified, but rather, modifying the state of the object always cause a new version of the object with the updated state to be returned. \nAs such you will see that the return type of all methods that changes the state of a class is an object of the class itself.  For instance,\n\n\n1\n2\n3\n  \npublic\n \nStatistics\n \nserveOneCustomer\n()\n \n{\n\n    \n:\n\n  \n}\n\n\n\n\n\n\n\nWhen we update the state inside \nStatistics\n by incrementing \ntotalNumOfServedCustomers\n by 1, we should return a \nnew\n object with this value incremented, instead of changing the object calling \nserveOneCustomer\n.\n\n\nThe classes you need to make into immutable classes are:\n\n\n\n\nPriorityQueue\n, from the package \ncs2030.util\n.\n\n\nServer\n, \nShop,\nSimState\n,\nStatistics\n, from the package\ncs2030.simulator`. \n\n\n\n\nYou should be familiar with the classes, except for \n- \nPriorityQueue\n, which is our own version of immutable priority queue built on top of \njava.util.PriorityQueue\n;\n- \nSimState\n, the simulation state, which encapsulates three things: the event queue, the statistics, and the shop (states of the servers).\n\n\n\n\nimport java.util.*;\n\n\nWhile it is convenient to do a mass import with \nimport\n \njava.util.\n*\n or similar expression, it increases the chances of name clashes.  In this case, we use the same name \nPriorityQueue\n as \njava.util\n.  So you should always import only specific classes that you want to use.  The \ncheckstyle\n configuration on \ncs2030-i\n has been updated to check for this.\n\n\n\n\nNo Side Effects\n\n\nBy making the classes immutable, updating the state of one object does not lead to side effects, as a new object is created with the updated state, the existing object remains unchanged.\n\n\nThe remaining side effects in the code after you make the classes immutable, are reading of arrival time from either a file or standard input, and printing of debugging statements to the standard output.  In functional-style programming, to keep our functions pure without side effects, we can quarantine these input/output statements to the main function.  \n\n\nFor Lab 4a, one way to do this, is to include all the string printed as \npart of the simulation state\n.  Instead of printing a string to standard output immediately, we append this string to the simulation state.  At the end of the simulation, we print out all strings (along with the average waiting time, number of customers served, and number of customers lost). \n\n\nBy doing so, we achieve pure functional code in all parts of our program except the input and output operations in the \nmain\n method.  \n\n\nReferential Transparency\n\n\nBy making your classes immutable and your code free from side effects (except in \nmain\n), you achieve the property of \nreferential transparency\n:  \nAny expression can be replaced by the resulting value of that expression, without changing the property of the program\n.\n\n\nSimulation Scenario\n\n\nThe scenario is the same as what you solved for Lab 1b (multiple servers, each server has at most one waiting customer).\n\n\n\n\nThe shop has \nk\nk\n (\nk \\ge 1\nk \\ge 1\n) servers. \n\n\nEach server has enough space for only one waiting customer.\n\n\nThe servers are arranged in fixed order, from 1 to k.\n\n\nOnce a customer arrives at the shop:\n\n\nThe customer scans the servers, from 1 to k, and approaches the first idle server he/she found to be served immediately.\n\n\nIf there is no idle server, the customer scans the server, from 1 to k, and waits at the first busy server without a waiting customer that he/she found.  \n\n\nIf every server is busy and already has a customer waiting, the customer leaves the shop.\n\n\n\n\nGrading\n\n\nThis is an ungraded lab.  But, submit it anyway as a record that you have attempted the lab.  \n\n\nInput and Output\n\n\nThe input file format is exactly the same as that from \nLab 1b\n.  The first line of the input file now is an integer, specifying the number of servers in the shop.  The remaining lines contain a sequence of double values, each is the arrival time of a customer (in any order).  \n\n\nRemember: you must not change the formatting of the \nlast line\n of output.\n\n\nThe test cases and outputs\n1\n should be:\n\n\n\n\n\n\n\n\nTest Case\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n1\n\n\n0.000 1 0\n\n\n\n\n\n\n2\n\n\n0.000 4 0\n\n\n\n\n\n\n3\n\n\n0.350 6 4\n\n\n\n\n\n\n4\n\n\n0.000 7 0\n\n\n\n\n\n\n5\n\n\n0.210 99 1\n\n\n\n\n\n\n6\n\n\n0.664 39 41\n or \n0.665 39 41\n or \n0.667 39 41\n\n\n\n\n\n\n\n\nWe removed Test Case 7 (which tested for the limit of 100 in event queue, which no longer applies as we are using PriorityQueue.)\n\n\nThe code given already provides the correct answer.  Checking against this answer just makes sure that you did not introduce new bugs while making your code immutable and side effects free.  \n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit4a\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab4a\n directory and its subdirectory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\n\n\n\n\n\n\n\n\nAfter piping through \ntail\n (e.g., \njava LabFourA < TESTDATA1.txt | tail -1\n)\u00a0\n\u21a9",
            "title": "4a. Simulator v2.0"
        },
        {
            "location": "/lab4a/index.html#lab-4a-simulator-20",
            "text": "Submission deadline: 2359, Friday, March 30, 2018.",
            "title": "Lab 4a: Simulator 2.0"
        },
        {
            "location": "/lab4a/index.html#prerequisites",
            "text": "This lab assumes that students:   have an understanding of the customer/server system being simulated in Lab 1b",
            "title": "Prerequisites"
        },
        {
            "location": "/lab4a/index.html#learning-objectives",
            "text": "After completing this lab, students should be able to write classes that are immutable and free from side effects.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab4a/index.html#setup",
            "text": "A skeleton code for Lab 4a is provided.  To setup Lab 4a, do the following.   Login to  cs2030-i  Copy  ~cs2030/lab4a  to  ~/lab4a   If you are still not familiar with how to do the above, please revisit the  UNIX  guide.",
            "title": "Setup"
        },
        {
            "location": "/lab4a/index.html#goals",
            "text": "The skeleton code provided solves Lab 1b in OO style.  The design of the class, however, have been adapted for Lab 4a and 4b, where the goal is to re-implement the solution in a functional style.  In Lab 4a, your task is to change the classes provided so that they become (i) immutable, and (ii)  no side effects.    You should use the provided skeleton code as the base for modification.  If you wish to modify your own solution to Lab 1b, please feel free to do so as an additional exercise, but do not submit that for Lab 4a/4b.",
            "title": "Goals"
        },
        {
            "location": "/lab4a/index.html#immutable",
            "text": "Recall that immutable does not mean an object cannot be modified, but rather, modifying the state of the object always cause a new version of the object with the updated state to be returned. \nAs such you will see that the return type of all methods that changes the state of a class is an object of the class itself.  For instance,  1\n2\n3    public   Statistics   serveOneCustomer ()   { \n     : \n   }    When we update the state inside  Statistics  by incrementing  totalNumOfServedCustomers  by 1, we should return a  new  object with this value incremented, instead of changing the object calling  serveOneCustomer .  The classes you need to make into immutable classes are:   PriorityQueue , from the package  cs2030.util .  Server ,  Shop, SimState , Statistics , from the package cs2030.simulator`.    You should be familiar with the classes, except for \n-  PriorityQueue , which is our own version of immutable priority queue built on top of  java.util.PriorityQueue ;\n-  SimState , the simulation state, which encapsulates three things: the event queue, the statistics, and the shop (states of the servers).   import java.util.*;  While it is convenient to do a mass import with  import   java.util. *  or similar expression, it increases the chances of name clashes.  In this case, we use the same name  PriorityQueue  as  java.util .  So you should always import only specific classes that you want to use.  The  checkstyle  configuration on  cs2030-i  has been updated to check for this.",
            "title": "Immutable"
        },
        {
            "location": "/lab4a/index.html#no-side-effects",
            "text": "By making the classes immutable, updating the state of one object does not lead to side effects, as a new object is created with the updated state, the existing object remains unchanged.  The remaining side effects in the code after you make the classes immutable, are reading of arrival time from either a file or standard input, and printing of debugging statements to the standard output.  In functional-style programming, to keep our functions pure without side effects, we can quarantine these input/output statements to the main function.    For Lab 4a, one way to do this, is to include all the string printed as  part of the simulation state .  Instead of printing a string to standard output immediately, we append this string to the simulation state.  At the end of the simulation, we print out all strings (along with the average waiting time, number of customers served, and number of customers lost).   By doing so, we achieve pure functional code in all parts of our program except the input and output operations in the  main  method.",
            "title": "No Side Effects"
        },
        {
            "location": "/lab4a/index.html#referential-transparency",
            "text": "By making your classes immutable and your code free from side effects (except in  main ), you achieve the property of  referential transparency :   Any expression can be replaced by the resulting value of that expression, without changing the property of the program .",
            "title": "Referential Transparency"
        },
        {
            "location": "/lab4a/index.html#simulation-scenario",
            "text": "The scenario is the same as what you solved for Lab 1b (multiple servers, each server has at most one waiting customer).   The shop has  k k  ( k \\ge 1 k \\ge 1 ) servers.   Each server has enough space for only one waiting customer.  The servers are arranged in fixed order, from 1 to k.  Once a customer arrives at the shop:  The customer scans the servers, from 1 to k, and approaches the first idle server he/she found to be served immediately.  If there is no idle server, the customer scans the server, from 1 to k, and waits at the first busy server without a waiting customer that he/she found.    If every server is busy and already has a customer waiting, the customer leaves the shop.",
            "title": "Simulation Scenario"
        },
        {
            "location": "/lab4a/index.html#grading",
            "text": "This is an ungraded lab.  But, submit it anyway as a record that you have attempted the lab.",
            "title": "Grading"
        },
        {
            "location": "/lab4a/index.html#input-and-output",
            "text": "The input file format is exactly the same as that from  Lab 1b .  The first line of the input file now is an integer, specifying the number of servers in the shop.  The remaining lines contain a sequence of double values, each is the arrival time of a customer (in any order).    Remember: you must not change the formatting of the  last line  of output.  The test cases and outputs 1  should be:     Test Case  Output      1  0.000 1 0    2  0.000 4 0    3  0.350 6 4    4  0.000 7 0    5  0.210 99 1    6  0.664 39 41  or  0.665 39 41  or  0.667 39 41     We removed Test Case 7 (which tested for the limit of 100 in event queue, which no longer applies as we are using PriorityQueue.)  The code given already provides the correct answer.  Checking against this answer just makes sure that you did not introduce new bugs while making your code immutable and side effects free.",
            "title": "Input and Output"
        },
        {
            "location": "/lab4a/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit4a   which will copy all files matching  *.java  (and nothing else) from your  ~/lab4a  directory and its subdirectory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.      After piping through  tail  (e.g.,  java LabFourA < TESTDATA1.txt | tail -1 )\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab4b/index.html",
            "text": "Lab 4b: Simulator 2.1\n\n\nSubmission deadline: 2359, Friday, April 6, 2018.\n\n\nPrerequisites\n\n\nThis lab assumes that students are\n\n\n\n\nfamiliar with the monads \nStream\n and \nOptional\n;\n\n\nfamiliar with using lambda expressions as higher-order functions.\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe comfortable with replacing loops with streams.\n\n\nbe comfortable with replacing variables that could be \nnull\n with \nOptional\n \n\n\nbe comfortable with using lambda expressions to customize the behavior of a class (instead of using polymorphism)\n\n\nbe able to write more general methods by passing in lambda expressions\n\n\n\n\nSetup\n\n\nYou will build on top of your Lab 4a solution.  To setup Lab 4b, do the following:\n\n\n\n\ncopy \n~/lab4a\n to \n~/lab4b\n.\n\n\nrename \nLabFourA.java\n to \nLabFourB.java\n\n\nrename the class \nLabFourA\n to \nLabFourB\n\n\n\n\nNo new test data nor skeleton code is given.\n\n\nTask\n\n\nFor Lab 4b, you are as several specific changes to make in the Lab 4a solution.\n\n\nReplace Polymorphism with Lambda Expressions\n\n\nAs you have seen in \nLecture 9\n, we can simplify the code written in OO-fashion, by replacing polymorphism with lambda expressions.\n\n\nIn this lab, your first task is to replace \nArrivalEvent\n and \nDoneEvent\n with lambda expressions that you can store inside the \nEvent\n class as a field.\n\n\nYou may find that you need to use variable capture to carry around variables that are used in the lambda expression.  You need to do this carefully since the objects in your program are now immutable, so a reference that your lambda expression captures might not be referring to the latest version of the object!\n\n\nReplace Loops with Streams\n\n\nYour second task is to replace \nall\n while loops and for loops (and possible loops that disguised as recursion) with stream operations (including that in \nLabFourB.java\n).  The only loop that can exist in your code after this lab is the while loop inside \nrun\n of \nSimulator\n:\n\n1\n2\n3\n    \nwhile\n \n(\np\n.\nfirst\n \n!=\n \nnull\n)\n \n{\n\n      \n:\n\n    \n}\n\n\n\n\n\n\nIn doing so, you may notice that the methods \nfindIdleServer\n and \nfindServerWithNoWaitingCustomer\n in \nShop\n can be refactored and simplified, if you abstract out the common parts of the code and represent the difference part with a \nPredicate\n.  Go ahead and change that as well.\n\n\n\n\nHint\n\n\nRemember to replace the loops in \nLabFourB.java\n as well.  The \nScanner\n class has a \ntokens()\n method that returns a stream of delimiter-separated tokens from a scanner.\n\n\n\n\nNo More \nnull\n!  No More \nnull\n!\n\n\nYour final task for this lab is to use \nOptional\n for all variables that could be \nnull\n.  Such variables include those representing a customer, a server, an event, the scanner, etc. \n\n\nAs we mentioned, the \nget()\n method of \nOptional\n in Java defeats the purpose of \nOptional\n since it could raise an exception.  As such, you should use \nget()\n (and the corresponding \nisPresent\n checks) sparingly. \n\n\nCoding Style and Documentation\n\n\nRemember that you should still\n\n\n\n\nfollow the \nCS2030 Coding Style\n\n\nclearly document your code with \njavadoc\n\n\n\n\nGrading\n\n\nThis lab contributes another 6 marks to your final grade:\n\n\n\n\nMaking every class immutable and side-effect free (1 marks)\n\n\nReplacing polymorphism with lambda expression and using variable capture correctly (1 marks)\n\n\nUse \nOptional\n for any variable that might be \nnull\n (2 marks)\n\n\nReplacing all loops with streams (except \nrun()\n in \nSimulator\n) (2 marks)\n\n\n\n\nYou can get up to 1 mark deduction for violation of style; up to another 1 mark for lack of javadoc documentation.  \n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit4b\n\n\n\n\n\nwhich will copy the files matching \n*.java\n (and nothing else) from your \n~/lab4b\n directory (and its subdirectory \ncs2030/simulator\n and \ncs2030/util\n on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.",
            "title": "4b. Simulator v2.1"
        },
        {
            "location": "/lab4b/index.html#lab-4b-simulator-21",
            "text": "Submission deadline: 2359, Friday, April 6, 2018.",
            "title": "Lab 4b: Simulator 2.1"
        },
        {
            "location": "/lab4b/index.html#prerequisites",
            "text": "This lab assumes that students are   familiar with the monads  Stream  and  Optional ;  familiar with using lambda expressions as higher-order functions.",
            "title": "Prerequisites"
        },
        {
            "location": "/lab4b/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be comfortable with replacing loops with streams.  be comfortable with replacing variables that could be  null  with  Optional    be comfortable with using lambda expressions to customize the behavior of a class (instead of using polymorphism)  be able to write more general methods by passing in lambda expressions",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab4b/index.html#setup",
            "text": "You will build on top of your Lab 4a solution.  To setup Lab 4b, do the following:   copy  ~/lab4a  to  ~/lab4b .  rename  LabFourA.java  to  LabFourB.java  rename the class  LabFourA  to  LabFourB   No new test data nor skeleton code is given.",
            "title": "Setup"
        },
        {
            "location": "/lab4b/index.html#task",
            "text": "For Lab 4b, you are as several specific changes to make in the Lab 4a solution.",
            "title": "Task"
        },
        {
            "location": "/lab4b/index.html#replace-polymorphism-with-lambda-expressions",
            "text": "As you have seen in  Lecture 9 , we can simplify the code written in OO-fashion, by replacing polymorphism with lambda expressions.  In this lab, your first task is to replace  ArrivalEvent  and  DoneEvent  with lambda expressions that you can store inside the  Event  class as a field.  You may find that you need to use variable capture to carry around variables that are used in the lambda expression.  You need to do this carefully since the objects in your program are now immutable, so a reference that your lambda expression captures might not be referring to the latest version of the object!",
            "title": "Replace Polymorphism with Lambda Expressions"
        },
        {
            "location": "/lab4b/index.html#replace-loops-with-streams",
            "text": "Your second task is to replace  all  while loops and for loops (and possible loops that disguised as recursion) with stream operations (including that in  LabFourB.java ).  The only loop that can exist in your code after this lab is the while loop inside  run  of  Simulator : 1\n2\n3      while   ( p . first   !=   null )   { \n       : \n     }    In doing so, you may notice that the methods  findIdleServer  and  findServerWithNoWaitingCustomer  in  Shop  can be refactored and simplified, if you abstract out the common parts of the code and represent the difference part with a  Predicate .  Go ahead and change that as well.   Hint  Remember to replace the loops in  LabFourB.java  as well.  The  Scanner  class has a  tokens()  method that returns a stream of delimiter-separated tokens from a scanner.",
            "title": "Replace Loops with Streams"
        },
        {
            "location": "/lab4b/index.html#no-more-null-no-more-null",
            "text": "Your final task for this lab is to use  Optional  for all variables that could be  null .  Such variables include those representing a customer, a server, an event, the scanner, etc.   As we mentioned, the  get()  method of  Optional  in Java defeats the purpose of  Optional  since it could raise an exception.  As such, you should use  get()  (and the corresponding  isPresent  checks) sparingly.",
            "title": "No More null!  No More null!"
        },
        {
            "location": "/lab4b/index.html#coding-style-and-documentation",
            "text": "Remember that you should still   follow the  CS2030 Coding Style  clearly document your code with  javadoc",
            "title": "Coding Style and Documentation"
        },
        {
            "location": "/lab4b/index.html#grading",
            "text": "This lab contributes another 6 marks to your final grade:   Making every class immutable and side-effect free (1 marks)  Replacing polymorphism with lambda expression and using variable capture correctly (1 marks)  Use  Optional  for any variable that might be  null  (2 marks)  Replacing all loops with streams (except  run()  in  Simulator ) (2 marks)   You can get up to 1 mark deduction for violation of style; up to another 1 mark for lack of javadoc documentation.",
            "title": "Grading"
        },
        {
            "location": "/lab4b/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit4b   which will copy the files matching  *.java  (and nothing else) from your  ~/lab4b  directory (and its subdirectory  cs2030/simulator  and  cs2030/util  on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/lab5/index.html",
            "text": "Lab 5: Parallel Matrix Multiplication\n\n\nSubmission deadline: 2359, Sunday, April 15, 2018.  \n\n\n(The deadline is pre-extended to Sunday :))\n\n\nSetup\n\n\nThe skeleton code from Lab 5 is available on \ncs2030-i\n under the directory \n~cs2030/lab5\n.  There are three files:\n\n\n\n\nMatrixMultiplication.java\n is the file that you need to edit to parallelize the matrix multiplication inside;\n\n\nLabFive.java\n is the main file;\n\n\nMatrix.java\n is the matrix class\n\n\n\n\nTo run \nLabFive\n, you should:\n\n\n1\njava LabFive <n>\n\n\n\n\n\n\nwhere \n2^n\n2^n\n is the dimension of the matrices.  For instance, to run with matrices of size 32x32, \n\n\n1\njava LabFive 5\n\n\n\n\n\n\nBackground: Matrix Multiplication\n\n\nMatrix multiplication is a fundamental operation on matrices with many applications in physics, engineering, mathematics, and computer science. \n\n\nGiven a matrix \nA\nA\n of \nn \\times m\nn \\times m\n (\nn\nn\n rows, \nm\nm\n columns), and a matrix \nB\nB\n of \nm \\times p\nm \\times p\n, the matrix produce \nC = AB\nC = AB\n is an \nn \\times p\nn \\times p\n matrix, where \nelements \nc_{ij}\nc_{ij}\n in \nC\nC\n is given by: \nc_{ij} = \\sum_{k=1}^m a_{ik}b_{kj}\nc_{ij} = \\sum_{k=1}^m a_{ik}b_{kj}\n._\n\n\nIn this lab, we are interested in parallelizing the following divide-and-conquer algorithm for matrix multiplication:\n\n\nLet \nA = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix}\nA = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix}\n,\n\nB = \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix}\nB = \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix}\n,\n\nC = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix}\nC = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix}\n\n\nwhere \nA_{11}, A_{12}\nA_{11}, A_{12}\n etc. are block partitioned matrices of equal sizes.\n\n\nIf \nC = AB\nC = AB\n, then:\n\n\nC = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22} \\end{pmatrix}\nC = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22} \\end{pmatrix}\n\n\nTask\n\n\nPlease implement the above divide-and-conquer algorithm as a \nRecursiveTask\n and submit it to \nForkJoinPool\n for execution.  For simplicity, we only need to handle \nsquare matrices\n of size \n2^n\n2^n\n for \nn\nn\n up to 11.\n\n\nA skeleton file \nMatrixMultiplication.java\n has been given to you.  The class \nMatrixMultiplication\n is mostly empty, except that it inherits from \nRecursiveTask<Matrix>\n.  You should fill in the class with necessary fields and method.\n\n\nThe file \nMatrix.java\n is also given to you.  It implements a matrix with double values,\n\nand stores the values of the matrix in a 2D \ndouble\n array \nm\n.  It also stores the dimension of the matrix in a field \ndimension\n.  This file includes two methods to multiply two matrices, one sequentially with triple for loops, and another (also sequentially) with the recursive divide-and-conquer algorithms.  There is a method to compare if two matrices are equals.  \n\n\nA method \nmultiplyParallely\n exists in the class \nMatrix\n but at the moment it calls the non-parallel version of \nmultiplyRecursively\n.  You should change this to appropriately invoke the parallel version of \nMatrixMultiplication\n. \n\n\nYou are still required to\n\n\n\n\nfollows the \nCS2030 Coding Style\n\n\nclearly documented with \njavadoc\n\n\n\n\nRunning on \nsunfire\n\n\nYou need to get the code and submit your solution on \ncs2030-i\n per usual.  The VM \ncs2030-i\n, however, has only one processor and therefore it is not much fun to run parallel programs on it.\n\n\nFortunately, the host \nsunfire\n, has 256 processors\n1\n.  We will run your submitted solution on \nsunfire\n, and you can test your code on \nsunfire\n as well.  You can \nssh\n into \nsunfire\n just like \ncs2030-i\n.\n\n\nOn \nsunfire\n, you should be able to get a speed up of at least \n70\n (i.e., parallel version is 70x faster than the sequential version) when running with \nn=11\nn=11\n.\n\n\nNote that \nsunfire\n still uses Java 8.  You won't need features from Java 9 or 10 in this lab in any case.\n\n\nTips:\n\n\n\n\nTry with small matrices first.  Make sure the code is correct before you go for the larger matrices.\n\n\nTry running locally on your own machine first to make sure the code is correct and does not throw exceptions.  Optimize for speed up on your machine, before moving the code to sunfire to measure the final speed up.\n\n\nThe method in \nLabFive\n that measures the time runs a given multiplication three times before taking the average.  It can take around 100-120 seconds to multiply sequentially.  When you debug for correctness and optimize for speed up for the parallel version, there is no need to multiply sequentially three times.  Feel free to change this part of the code while you are debugging/optimizing your code.\n\n\nFor matrices of dimension \n2^{10}\n2^{10}\n and \n2^{11}\n2^{11}\n, you need to run \njava\n with the argument \n-Xmx<size>\n to increase the heap memory to \nsize\n on \nsunfire\n.  \n-Xmx1g\n increases the heap memory to up to 1GB, and should work well for both cases.\n\n\nIf you grow impatient while waiting and want to stop the running process, type \nControl-C\n in your ssh window.  You may have to wait up to a few seconds (depending on how slow is \nsunfire\n) for the process to stop.\n\n\n\n\nChallenges:\n\n\nChallenges for this lab include: \n\n\n\n\nFinding the right fork threshold so that you gain the maximum speed up for a matrix of size \n2^{11} \\times 2^{11}\n2^{11} \\times 2^{11}\n;\n\n\nNot spawning too many tasks that block, which will in turns lead to too many compensation threads being created in \nForkJoinPool\n, and a \nRejectedExecutionException\n being thrown: \nCaused by: java.util.concurrent.RejectedExecutionException: Thread limit exceeded replacing blocked worker\n.  The order of \nfork\n and \njoin\n becomes important here.\n\n\nNot creating too many unnecessary copies of the matrices (you will ran out of heap space even with \n-Xmx1g\n\n\nNot letting multiple tasks update the same matrix in place.  Such side effects may lead to a incorrect result.\n\n\nWaiting \npatiently\n for the multiplication to complete :)\n\n\n\n\nGrading\n\n\nThis lab contributes another 6 marks to your final grade.\n\n\nWe will still grade your code based on your implementation (not the resulting speed up), but as a guideline, using matrix of size \n2^{11}\n2^{11}\n as the benchmark on \nsunfire\n with 1GB of heap space, you get:\n\n\n\n\n2 mark if you parallelize the code but achieve a slow down in performance.\n\n\n3 marks if your speed up is aronud 1 - 30x\n\n\n4 marks if your speed up is around 30x - 50x\n\n\n5 marks if your speed up is around 50x - 60x\n\n\n6 marks if your speed up is beyond 60x\n\n\n\n\nYou can get -0.5 mark deduction for a serious violation of style.  \n\n\nIf you matrix multiplication output is incorrect or your code throws an exception, you will get deduction depending on how serious your bug is. Possible bugs, include:\n\n\n\n\nIncorrect order of fork and join (-3)\n\n\nLetting multiple tasks update the same location of the matrix at the same time (-2)\n\n\nCareless mistakes in referring to matrices or its indices (-1)\n\n\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit5\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab5\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\nMay the \nfork()\ns be with you.\n\n\n\n\n\n\n\n\n\n\nYou can find out by calling \nRuntime.getRuntime().availableProcessors();\n in Java.\u00a0\n\u21a9",
            "title": "5.  Matrix Multiplication"
        },
        {
            "location": "/lab5/index.html#lab-5-parallel-matrix-multiplication",
            "text": "Submission deadline: 2359, Sunday, April 15, 2018.    (The deadline is pre-extended to Sunday :))",
            "title": "Lab 5: Parallel Matrix Multiplication"
        },
        {
            "location": "/lab5/index.html#setup",
            "text": "The skeleton code from Lab 5 is available on  cs2030-i  under the directory  ~cs2030/lab5 .  There are three files:   MatrixMultiplication.java  is the file that you need to edit to parallelize the matrix multiplication inside;  LabFive.java  is the main file;  Matrix.java  is the matrix class   To run  LabFive , you should:  1 java LabFive <n>   where  2^n 2^n  is the dimension of the matrices.  For instance, to run with matrices of size 32x32,   1 java LabFive 5",
            "title": "Setup"
        },
        {
            "location": "/lab5/index.html#background-matrix-multiplication",
            "text": "Matrix multiplication is a fundamental operation on matrices with many applications in physics, engineering, mathematics, and computer science.   Given a matrix  A A  of  n \\times m n \\times m  ( n n  rows,  m m  columns), and a matrix  B B  of  m \\times p m \\times p , the matrix produce  C = AB C = AB  is an  n \\times p n \\times p  matrix, where \nelements  c_{ij} c_{ij}  in  C C  is given by:  c_{ij} = \\sum_{k=1}^m a_{ik}b_{kj} c_{ij} = \\sum_{k=1}^m a_{ik}b_{kj} ._  In this lab, we are interested in parallelizing the following divide-and-conquer algorithm for matrix multiplication:  Let  A = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} A = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} , B = \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} B = \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} , C = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix} C = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix}  where  A_{11}, A_{12} A_{11}, A_{12}  etc. are block partitioned matrices of equal sizes.  If  C = AB C = AB , then:  C = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22} \\end{pmatrix} C = \\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{pmatrix} \\begin{pmatrix} B_{11} & B_{12} \\\\ B_{21} & B_{22} \\end{pmatrix} = \\begin{pmatrix} A_{11}B_{11} + A_{12}B_{21} & A_{11}B_{12} + A_{12}B_{22} \\\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22} \\end{pmatrix}",
            "title": "Background: Matrix Multiplication"
        },
        {
            "location": "/lab5/index.html#task",
            "text": "Please implement the above divide-and-conquer algorithm as a  RecursiveTask  and submit it to  ForkJoinPool  for execution.  For simplicity, we only need to handle  square matrices  of size  2^n 2^n  for  n n  up to 11.  A skeleton file  MatrixMultiplication.java  has been given to you.  The class  MatrixMultiplication  is mostly empty, except that it inherits from  RecursiveTask<Matrix> .  You should fill in the class with necessary fields and method.  The file  Matrix.java  is also given to you.  It implements a matrix with double values, \nand stores the values of the matrix in a 2D  double  array  m .  It also stores the dimension of the matrix in a field  dimension .  This file includes two methods to multiply two matrices, one sequentially with triple for loops, and another (also sequentially) with the recursive divide-and-conquer algorithms.  There is a method to compare if two matrices are equals.    A method  multiplyParallely  exists in the class  Matrix  but at the moment it calls the non-parallel version of  multiplyRecursively .  You should change this to appropriately invoke the parallel version of  MatrixMultiplication .   You are still required to   follows the  CS2030 Coding Style  clearly documented with  javadoc",
            "title": "Task"
        },
        {
            "location": "/lab5/index.html#running-on-sunfire",
            "text": "You need to get the code and submit your solution on  cs2030-i  per usual.  The VM  cs2030-i , however, has only one processor and therefore it is not much fun to run parallel programs on it.  Fortunately, the host  sunfire , has 256 processors 1 .  We will run your submitted solution on  sunfire , and you can test your code on  sunfire  as well.  You can  ssh  into  sunfire  just like  cs2030-i .  On  sunfire , you should be able to get a speed up of at least  70  (i.e., parallel version is 70x faster than the sequential version) when running with  n=11 n=11 .  Note that  sunfire  still uses Java 8.  You won't need features from Java 9 or 10 in this lab in any case.",
            "title": "Running on sunfire"
        },
        {
            "location": "/lab5/index.html#tips",
            "text": "Try with small matrices first.  Make sure the code is correct before you go for the larger matrices.  Try running locally on your own machine first to make sure the code is correct and does not throw exceptions.  Optimize for speed up on your machine, before moving the code to sunfire to measure the final speed up.  The method in  LabFive  that measures the time runs a given multiplication three times before taking the average.  It can take around 100-120 seconds to multiply sequentially.  When you debug for correctness and optimize for speed up for the parallel version, there is no need to multiply sequentially three times.  Feel free to change this part of the code while you are debugging/optimizing your code.  For matrices of dimension  2^{10} 2^{10}  and  2^{11} 2^{11} , you need to run  java  with the argument  -Xmx<size>  to increase the heap memory to  size  on  sunfire .   -Xmx1g  increases the heap memory to up to 1GB, and should work well for both cases.  If you grow impatient while waiting and want to stop the running process, type  Control-C  in your ssh window.  You may have to wait up to a few seconds (depending on how slow is  sunfire ) for the process to stop.",
            "title": "Tips:"
        },
        {
            "location": "/lab5/index.html#challenges",
            "text": "Challenges for this lab include:    Finding the right fork threshold so that you gain the maximum speed up for a matrix of size  2^{11} \\times 2^{11} 2^{11} \\times 2^{11} ;  Not spawning too many tasks that block, which will in turns lead to too many compensation threads being created in  ForkJoinPool , and a  RejectedExecutionException  being thrown:  Caused by: java.util.concurrent.RejectedExecutionException: Thread limit exceeded replacing blocked worker .  The order of  fork  and  join  becomes important here.  Not creating too many unnecessary copies of the matrices (you will ran out of heap space even with  -Xmx1g  Not letting multiple tasks update the same matrix in place.  Such side effects may lead to a incorrect result.  Waiting  patiently  for the multiplication to complete :)",
            "title": "Challenges:"
        },
        {
            "location": "/lab5/index.html#grading",
            "text": "This lab contributes another 6 marks to your final grade.  We will still grade your code based on your implementation (not the resulting speed up), but as a guideline, using matrix of size  2^{11} 2^{11}  as the benchmark on  sunfire  with 1GB of heap space, you get:   2 mark if you parallelize the code but achieve a slow down in performance.  3 marks if your speed up is aronud 1 - 30x  4 marks if your speed up is around 30x - 50x  5 marks if your speed up is around 50x - 60x  6 marks if your speed up is beyond 60x   You can get -0.5 mark deduction for a serious violation of style.    If you matrix multiplication output is incorrect or your code throws an exception, you will get deduction depending on how serious your bug is. Possible bugs, include:   Incorrect order of fork and join (-3)  Letting multiple tasks update the same location of the matrix at the same time (-2)  Careless mistakes in referring to matrices or its indices (-1)",
            "title": "Grading"
        },
        {
            "location": "/lab5/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit5   which will copy all files matching  *.java  (and nothing else) from your  ~/lab5  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.  May the  fork() s be with you.      You can find out by calling  Runtime.getRuntime().availableProcessors();  in Java.\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab6/index.html",
            "text": "Lab 6: Querying Web API with Async Calls\n\n\nSubmission deadline: 2359, Friday, April 20, 2018.\n\n\n(No late penalty imposed until 2359, April 22, 2018)\n\n\nSetup\n\n\nThe skeleton code from Lab 6 is available on \ncs2030-i\n under the directory \n~cs2030/lab6\n.   \n\n\nInside, the directory, you will find two other files: \nsample.txt\n shows sample inputs and outputs; \nbus-stops.txt\n gives a list of bus stop IDs with names.  Both files are for your information only.\n\n\nFinding Bus Routes\n\n\nThe given program, \nLabSix\n, takes in two arguments.  The first is the ID of a bus stop (you can look up this ID at a physical bus stop, or look at the file \nbus-stops.txt\n given in \n~cs2030/lab6\n. The second is a search string, which will be used to naively match the name of another bus stop.  Multiple matches are possible.  The program will then output the list of bus services running between the bus stop with the given ID and the bus stop with matching name.\n\n\nFor instance, suppose you are in Clementi Interchange (ID 17009), and you want to go somewhere in NUS.  Running the query:\n\n\n1\njava LabSix 17009 NUS\n\n\n\n\n\n\nwill produce the following output:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n- Take 156 to:\n  - 41011 NUS Bt Timah Campus\n- Take 96 to:\n  - 16169 NUS Raffles Hall\n  - 16199 NUS Fac Of Design & Env\n  - 16149 NUS Fac Of Architecture\n  - 16159 NUS Fac Of Engrg\n- Take 196 to:\n  - 17191 NUS High Sch\n\n\n\n\n\nThe order of the bus services in the output does not matter; the order of bus stops does not matter as well.\n\n\nThe skeleton code given is already functional, but it uses \nsynchronous calls\n to make query to a Web API for bus information.  \n\n\nThe Web API\n\n\nA Web API is an API where you invoke through HTTP protocol by specifying the parameters through the URL.  We have setup a Web API with the following interface:\n\n\nhttps://cs2030-bus-api.herokuapp.com/bus_services/<bus service id>\n returns a list of bus stops served by a given bus.  Each bus stop occupies a line.  Each line contains the bus stop ID and its name, separated by a comma \n,\n.\n\nExample\n\n\nhttps://cs2030-bus-api.herokuapp.com/bus_stops/<bus stop id>\n returns two lines.  The first line is the name of the bus stop.  The second line is a list of bus service IDs that serves a given bus stop.  \nExample\n\n\nThe basic code to query the Web API is provided in the skeleton code.  See \nBusStop.java\n and \nBusService.java\n.\n\n\nThe results of the query are encapsulated in \nBusRoutes\n.  \n\n\nThe main logic, which you need to modify, is implemented in \nBusSg.java\n.  The lines that you need to convert into asynchronous calls have been marked with \nTODO\n.\n\n\nTask\n\n\nThe goal of this lab is to change the code from synchronous to asynchronous, using \nCompletableFuture\n.  All methods that involve querying the Web API should be asynchronous, since they are typically slow.  In this lab, besides the network latency, we also introduce some artificial latency in the code with \nThread.sleep\n.\n\n\nThe code that queries the Web API would throw an exception if it fails to query the API (e.g., if there is no Internet connection).  In your code, you should handle the exception using the \nhandle\n method of \nCompletableFuture\n, returning an empty set if an exception is thrown and printing an appropriate message to \nSystem.err\n.\n\n\nBefore you begin modifying the code in \nBusSg\n, you should read the code given in \nBusStop.java\n, \nBusService.java\n, \nBusRoutes.java\n, \nBusSg.java\n, and \nLabSix.java\n to understand how the code answer the query.\n\n\nAs usual, you should also:\n\n\n\n\nfollows the \nCS2030 Coding Style\n\n\nclearly documented with \njavadoc\n\n\n\n\nGrading\n\n\nThis lab contributes another 6 marks to your final grade (100 marks).  \n\n\nYou get:\n\n\n\n\n1 marks for calling \ngetBusServices()\n asynchronously\n\n\n4 marks for calling \nfindStopsWith(name)\n asynchronously and correctly in a loop\n\n\n1 marks for handling exceptions with \nhandle()\n \n\n\n\n\nYou can get -0.5 mark deduction for serious violation of style.  \n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit6\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab6\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\n\n\nWarning\n\n\nMake sure your code are in the right place -- it must be in subdirectory named \nlab6\n, directly under your home directory, in other words \n~/lab6\n.  If you place it anywhere else, it will not get submitted.",
            "title": "6.  Async Web API"
        },
        {
            "location": "/lab6/index.html#lab-6-querying-web-api-with-async-calls",
            "text": "Submission deadline: 2359, Friday, April 20, 2018.  (No late penalty imposed until 2359, April 22, 2018)",
            "title": "Lab 6: Querying Web API with Async Calls"
        },
        {
            "location": "/lab6/index.html#setup",
            "text": "The skeleton code from Lab 6 is available on  cs2030-i  under the directory  ~cs2030/lab6 .     Inside, the directory, you will find two other files:  sample.txt  shows sample inputs and outputs;  bus-stops.txt  gives a list of bus stop IDs with names.  Both files are for your information only.",
            "title": "Setup"
        },
        {
            "location": "/lab6/index.html#finding-bus-routes",
            "text": "The given program,  LabSix , takes in two arguments.  The first is the ID of a bus stop (you can look up this ID at a physical bus stop, or look at the file  bus-stops.txt  given in  ~cs2030/lab6 . The second is a search string, which will be used to naively match the name of another bus stop.  Multiple matches are possible.  The program will then output the list of bus services running between the bus stop with the given ID and the bus stop with matching name.  For instance, suppose you are in Clementi Interchange (ID 17009), and you want to go somewhere in NUS.  Running the query:  1 java LabSix 17009 NUS   will produce the following output: 1\n2\n3\n4\n5\n6\n7\n8\n9 - Take 156 to:\n  - 41011 NUS Bt Timah Campus\n- Take 96 to:\n  - 16169 NUS Raffles Hall\n  - 16199 NUS Fac Of Design & Env\n  - 16149 NUS Fac Of Architecture\n  - 16159 NUS Fac Of Engrg\n- Take 196 to:\n  - 17191 NUS High Sch   The order of the bus services in the output does not matter; the order of bus stops does not matter as well.  The skeleton code given is already functional, but it uses  synchronous calls  to make query to a Web API for bus information.",
            "title": "Finding Bus Routes"
        },
        {
            "location": "/lab6/index.html#the-web-api",
            "text": "A Web API is an API where you invoke through HTTP protocol by specifying the parameters through the URL.  We have setup a Web API with the following interface:  https://cs2030-bus-api.herokuapp.com/bus_services/<bus service id>  returns a list of bus stops served by a given bus.  Each bus stop occupies a line.  Each line contains the bus stop ID and its name, separated by a comma  , . Example  https://cs2030-bus-api.herokuapp.com/bus_stops/<bus stop id>  returns two lines.  The first line is the name of the bus stop.  The second line is a list of bus service IDs that serves a given bus stop.   Example  The basic code to query the Web API is provided in the skeleton code.  See  BusStop.java  and  BusService.java .  The results of the query are encapsulated in  BusRoutes .    The main logic, which you need to modify, is implemented in  BusSg.java .  The lines that you need to convert into asynchronous calls have been marked with  TODO .",
            "title": "The Web API"
        },
        {
            "location": "/lab6/index.html#task",
            "text": "The goal of this lab is to change the code from synchronous to asynchronous, using  CompletableFuture .  All methods that involve querying the Web API should be asynchronous, since they are typically slow.  In this lab, besides the network latency, we also introduce some artificial latency in the code with  Thread.sleep .  The code that queries the Web API would throw an exception if it fails to query the API (e.g., if there is no Internet connection).  In your code, you should handle the exception using the  handle  method of  CompletableFuture , returning an empty set if an exception is thrown and printing an appropriate message to  System.err .  Before you begin modifying the code in  BusSg , you should read the code given in  BusStop.java ,  BusService.java ,  BusRoutes.java ,  BusSg.java , and  LabSix.java  to understand how the code answer the query.  As usual, you should also:   follows the  CS2030 Coding Style  clearly documented with  javadoc",
            "title": "Task"
        },
        {
            "location": "/lab6/index.html#grading",
            "text": "This lab contributes another 6 marks to your final grade (100 marks).    You get:   1 marks for calling  getBusServices()  asynchronously  4 marks for calling  findStopsWith(name)  asynchronously and correctly in a loop  1 marks for handling exceptions with  handle()     You can get -0.5 mark deduction for serious violation of style.",
            "title": "Grading"
        },
        {
            "location": "/lab6/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit6   which will copy all files matching  *.java  (and nothing else) from your  ~/lab6  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.   Warning  Make sure your code are in the right place -- it must be in subdirectory named  lab6 , directly under your home directory, in other words  ~/lab6 .  If you place it anywhere else, it will not get submitted.",
            "title": "Submission"
        },
        {
            "location": "/lec01/index.html",
            "text": "Lecture 1: Abstraction and Encapsulation\n\n\nLearning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nrecap some fundamental programming concepts, including the execution model of a program, abstractions over code and data, primitive and composite data types.\n\n\nappreciate the importance of maintaining abstraction barrier in software development\n\n\nunderstand the differences between statically and dynamically typed languages\n\n\nunderstand the concepts of object-oriented programming, including encapsulation, data hiding, fields and methods, constructors, mutators/accessors, classes and objects, and their purposes of introducing them as a method of programming.\n\n\nknow the purpose and usage of Java keywords \nclass\n, \npublic\n, \nprivate\n, \nfinal\n, \nstatic\n, \nimport\n, \nnew\n\n\nunderstand that Java is a type-safe language, in contrast to C\n\n\nbe familiar with Java variable and primitive types\n\n\n\n\nWhat Exactly is a \nProgram\n?\n\n\nA program is a set of instructions we issue to computers to manipulate data.  A programming language is a formal language that helps programmers specify precisely what are the instructions we issue to computers, using code that are often made up of keywords, symbols, and names.  Computers execute the instructions in their \nprocessing units\n, and store the instructions and data in their \nmemory\n1\n.  The processing units recognize the instructions based on the specific patterns of bits and manipulate data as a sequence of bits.  A programming language, however, is written at a higher level of \nabstraction\n (i.e., at a higher conceptual level), so that as a programmer, we only need to write a few lines of code to give complex instructions to the computer.  A \ncompiler\n or \ninterpreter\n is responsible for translating these programs written in high level language to \nassembly code\n or \nmachine code\n, i.e., bit patterns that the processing units can understand.\n\n\nThere are thousands of programming languages in existence.  \nC\n is one of the languages that is a \nlow-level language\n -- i.e., it provides a very thin layer of abstractions on top of machine code.  On the other hand, languages such as \nPython\n and \nJavaScript\n are high-level languages.  As an example, in C, you can directly manage memory allocation.  In JavaScript and Python, you cannot.\n\n\nAbstraction: Variable and Type\n\n\nOne of the important abstractions that is provided by a programming language is \nvariable\n.  Data are stored in some location in the computer memory.  But we should not be referring to the memory location all the time.  First, referring to something like \n0xFA49130E\n is not user-friendly; Second, the location may change.  A \nvariable\n is an abstraction that allows us to give a user-friendly name to a piece of data in memory.  We use the \nvariable name\n whenever we want to access the \nvalue\n in that location, and \npointer to the variable\n or \nreference to the variable\n whenever we want to refer to the address of the location.\n\n\nLet's think a bit more about how a sequence of bits is abstracted as data in a programming language.  At the machine level, these bits are just, well, bits.  We give the bits a \nsemantic\n at the program level, e.g., we want to interpret the sequence of bits as numbers, letters, etc.  E.g., the number (integer, to be exact) \n65\n and the letter \nA\n all share the same sequence of bits \n0100 0001\n but are interpreted differently and possibly manipulated differently.  \n\n\nThe \ntype\n of a variable tells the compiler or the interpreter how to interpret the variable and how to manipulate the variable.  \n\n\nFor instance, supposed that in Python, if you have two variables \nx\n and \ny\n storing the values \n4\n and \n5\n respectively, if you \nprint x + y\n, you would get \n45\n if \nx\n and \ny\n are strings; you would get \n9\n if \nx\n and \ny\n are integers; you would get an error if \n4\n is an integer and \n5\n is a string.  \n\n\nIn the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation \n+\n is not defined over an integer and a string in Python\n2\n.\n\n\nPython is a \ndynamically typed\n language.  The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program.  Note that, the type is associated with the \nvalues\n, and the type of the variable changes depending on the value it holds.\n\n\nC, on the other hand, is a \nstatically typed\n language.  We need to \ndeclare\n every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type \nint\n.  We check if the right type is used during the compilation of the program.\n\n\n1\n2\nint\n \nx\n \n=\n \n4\n;\n \n// ok\n\n\nint\n \ny\n \n=\n \n\"5\"\n;\n \n// error\n\n\n\n\n\n\n\nBy annotating each variable with its type, the C compiler also knows how much memory space is needed to store a variable.  \n\n\nAbstraction: Functions\n\n\nAnother important abstraction provided by a programming language is \nfunction\n (or \nprocedure\n).  This abstraction allows programmers to group a set of instructions and give it a name.  The named set of instructions may take one or more variables as input parameters, and return one or more values.   \n\n\nLike all other abstractions, defining functions allow us to think at a higher conceptual level.  By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity.\n\n\nDefining functions allow us to abstract away the implementation details from the caller.  Once a function is defined, we can change the way the function is implemented without affecting the code that calls the function, as long as the semantic and the \ninterface\n of the function remains the same.\n\n\nFunction, therefore, is a critical mechanism for achieving \nseparation of concerns\n in a program.  We separate the concerns about how a particular function is implemented, from the concerns about how the function is used to perform a higher-level task.\n\n\nDefining functions also allow us to \nreuse\n code.  We do not have to repeatedly write the same chunk of code if we group the sequence of code into a function -- then we just need to call the function to invoke this sequence of code every time we need it.  If this chunk of code is properly written and debugged, then we can be pretty sure that everywhere the function is invoked, the code is correct\n3\n.\n\n\nC is a \nprocedural language\n.  A C program consists of functions, with the \nmain()\n function serves as the entry point to the program.  Since C is a statically typed language, a C function has a return type, and each  function parameter (or \nargument\n) has a type as well.  (Note that this statement does not mean that a C function must return a \nvalue\n.  If the function does not return a value, we define its return type as \nvoid\n.)\n\n\nRecall that the bits representing the instructions are also stored in the computer memory in an area separated from the data.  The instructions that belong to the same function are stored in adjacent memory locations.  Just like we can refer to a variable using its memory address through its \nreference\n (or \npointer\n), we can refer to a function using the memory address of the entry point to the function.\n\n\nAbstraction: Composite Data Type\n\n\nJust like functions allow programmers to group instructions, give it a name, and refer to it later, a \ncomposite data type\n allows programmers to group \nprimitive types\n together, give it a name (a new type), and refer to it later.  This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or every day objects such as a person, a product, etc.\n\n\nDefining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented.\n\n\nFor instance, a circle on a 2D plane can be represented by the center (\nx\n, \ny\n) and its radius \nr\n, or it can be represented by the top left corner (\nx\n,\ny\n) and the width \nw\n of the bounding square.\n\n\nIn C, we build composite data type with \nstruct\n.  For example,\n\n\n1\n2\n3\n4\nstruct\n \ncircle\n \n{\n\n  \nfloat\n \nx\n,\n \ny\n;\n \n// (x,y) coordinate of the center.\n\n  \nfloat\n \nr\n;\n \n// radius\n\n\n}\n\n\n\n\n\n\n\nOnce we have the \nstruct\n defined, we are not completely shielded from its representation, until we write a set of functions that operates on the \ncircle\n composite type.  For instance,\n\n\n1\n2\n3\nfloat\n \ncircle_area\n(\ncircle\n \nc\n)\n \n{\n \n...\n \n};\n\n\nbool\n  \ncircle_contains_point\n(\ncircle\n \nc\n,\n \npoint\n \np\n)\n \n{\n \n...\n \n};\n\n  \n:\n\n\n\n\n\n\n\nImplementing these functions obviously requires the knowledge of how a circle is represented.  Once the set of functions that operates on and manipulates circles is available, we can use \ncircle\n type without worrying about the internal representation.  \n\n\nIf we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.\n\n\nWe can imagine an \nabstraction barrier\n between the code that uses a composite data type along with its associated set of functions, and the code that define the data type along with the implementation of the functions.  Above the barrier, the concern is about using the composite data type to do useful things, while below the barrier, the concern is about how to represent and manipulate the composite data type.\n\n\nWhile many of you are used to writing a program solo, in practice, you rarely write a program with contributions from a single person.  The abstraction barrier separates the role of the programmer into two: (i) an \nimplementer\n, which define that data type and provide the implementation, and (ii) a \nclient\n, which uses the composite data type to perform a higher level task\n4\n.  Part of my aim in CS2030 is to switch your mindset into thinking in terms of these two roles.  Note that the implementer and the client may very well be the same programmer.\n\n\nAbstraction: Class and Object (or, Encapsulation)\n\n\nWe can further bundle the composite data type and its associated functions together in another abstraction, called a \nclass\n.  A class is a data type with a group of functions associated with it.  We call the functions as \nmethods\n and the data in the class as \nfields\n (or \nmembers\n, or \nstates\n, or \nattributes\n4\n).   A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right \ninterface\n for others to use.\n\n\nJust like we can create variables of a given type, we can create \nobjects\n of a given class.  Objects are \ninstances\n of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.\n\n\nRecall that programs written in a procedural language such as a C consists of functions, with a \nmain()\n function as the entry point.  A program written in an \nobject-oriented language\n such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods.\n\n\nOne could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has certain properties, exhibit certain behavior, and they allow certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used everyday (unless we try to repair it)\n5\n.  \n\n\nThe concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called \nencapsulation\n.\n\n\nBreaking the Abstraction Barrier\n\n\nIn the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier.  \n\n\nConsider the case of implementing \ncircle\n as a C \nstruct\n.  Suppose someone wants to move the center of the circle \nc\n to a new position (\nx\n, \ny\n), instead of implementing a function \ncircle_move_to(c, x, y)\n (which would still keep the representation used under the barrier), the person wrote:\n\n\n1\n2\nc\n.\nx\n \n=\n \nx\n;\n\n\nc\n.\ny\n \n=\n \ny\n;\n\n\n\n\n\n\n\nThis code would still be correct, but the abstraction barrier is broken since we now make explicit assumption that there are two variables \nx\n and \ny\n inside the \ncircle\n data type that corresponds to the center of the circle.  If one day, we want to represent a circle differently, then we have to carefully change all the code that read and write these variables \nx\n and \ny\n and update them.\n\n\n\n\nBreaking Python's Abstraction Barrier\n\n\nPython tries to prevent \naccidental\n access to internal representation by having a convention of prefixing the internal variables with \n_\n (one underscore) or \n__\n (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.\n\n\n\n\nData Hiding\n\n\nMany OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, supports \nprivate\n and \npublic\n access modifiers\n5\n.  A field or a method that is declared as \nprivate\n cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a \npublic\n field or method can be accessed, modified, or invoked from outside the class.\n\n\nSuch mechanism to protect the abstraction barrier from being broken is called \ndata hiding\n or \ninformation hiding\n.  This protection is enforced by the \ncompiler\n at compile time.\n\n\nExample: The Circle class\n\n\nLet's put together the concepts of encapsulation and data hiding to define a \nCircle\n class in Java:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n\n\n * A Circle object encapsulates a circle on a 2D plane.  \n\n\n */\n\n\nclass\n \nCircle\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n  \n// x-coordinate of the center\n\n  \nprivate\n \ndouble\n \ny\n;\n  \n// y-coordinate of the center\n\n  \nprivate\n \ndouble\n \nr\n;\n  \n// the length of the radius\n\n\n  \n/**\n\n\n   * Return the area of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \n3.1415926\n \n*\n \nr\n \n*\n \nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Move the center of the circle to the new position (newX, newY)\n\n\n   */\n\n  \npublic\n \nvoid\n \nmoveTo\n(\ndouble\n \nnewX\n,\n \ndouble\n \nnewY\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n    \ny\n \n=\n \nnewY\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nHere, we define \nx\n, \ny\n, and \nr\n as three private fields inside the class \nCircle\n.  Note that these fields are not accessible and modifiable outside of the class \nCircle\n, but they can be accessed and modified within \nCircle\n (inside the abstraction barrier), such as in the methods \ngetArea\n and \nmoveTo\n.\n\n\nConstructors, Accessors, and Mutators\n\n\nWith data hiding, we completely isolate the internal representation of a class using an abstraction barrier.  With no way for the user of the class to modify the fields directly, it is common for a class to provide methods to initialize and modify these internal fields (such as the \nmoveTo()\n method above).  A method that initializes an object is called a \nconstructor\n, and a method that retrieves or modifies the properties of the object is called the \naccessor\n (or \ngetter\n) or \nmutator\n (or \nsetter\n).\n\n\nA constructor method is a special method within the class.  It cannot be called directly but is invoked automatically when an object is instantiated.   In Java, a constructor method \nhas the same name as the class\n and \nhas no return type\n.  A constructor can take in arguments just like other functions.  The class \nCircle\n can have a constructor such as the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nclass\n \nCircle\n \n{\n\n    \n:\n\n  \n/**\n\n\n   * Create a circle centered on (centerX, centerY) with given radius\n\n\n  */\n\n  \npublic\n \nCircle\n(\ndouble\n \ncenterX\n,\n \ndouble\n \ncenterY\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nx\n \n=\n \ncenterX\n;\n\n    \ny\n \n=\n \ncenterY\n;\n\n    \nr\n \n=\n \nradius\n;\n\n  \n}\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThe use of accessor and mutator methods is a bit controversial.   Suppose that we provide an accessor method and a mutator method for every private field, then we are actually exposing the internal representation, therefore breaking the encapsulation.  For instance:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nclass\n \nCircle\n \n{\n\n    \n:\n\n\n  \npublic\n \ndouble\n \ngetX\n()\n \n{\n\n    \nreturn\n \nx\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetX\n(\ndouble\n \nnewX\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n  \n}\n\n\n  \npublic\n \ndouble\n \ngetY\n()\n \n{\n\n    \nreturn\n \ny\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetY\n(\ndouble\n \nnewY\n)\n \n{\n\n    \ny\n \n=\n \nnewY\n:\n\n  \n}\n\n\n  \npublic\n \ndouble\n \ngetR\n()\n \n{\n\n    \nreturn\n \nr\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetR\n(\ndouble\n \nnewR\n)\n \n{\n\n    \nr\n \n=\n \nnewR\n;\n\n  \n}\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThe examples above are pretty pointless.  If we need to know the internal and do something with it, we are doing it wrong.  The right approach is to implement a method within the class that do whatever we want the class to do.   For instance, suppose that we want to know the circumference of the circle \nc\n, one approach would be:\n\n\n1\n   \ndouble\n \ncircumference\n \n=\n \n2\n*\nc\n.\ngetR\n()*\n3.1415926\n;\n\n\n\n\n\n\n\nwhere \nc\n is a \nCircle\n object.\n\n\nA better approach would be to add a new method \ngetCircumference()\n in the \nCircle\n class, and call it instead:\n\n1\n   \ndouble\n \ncircumference\n \n=\n \nc\n.\ngetCircumference\n();\n\n\n\n\n\n\nThe better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact.  If one fine day, the implementer of \nCircle\n decided to store the diameter of the circle instead of the radius, then only the implementer needs to change the implementation of \ngetCircumference\n.  The client does not have to change anything.  \n\n\n\n\nConstructor in Python and JavaScript\n\n\nIn Python, the constructor is the \n__init__\n method.   In JavaScript, the constructor is simply called \nconstructor\n.\n\n\n\n\nClass Fields and Methods\n\n\nLet's look at the implementation of \ngetArea()\n above.  We use the constant \n\\pi\n\\pi\n but hardcoded it as 3.1415926.  Hardcoding such a magic number is a \nno-no\n in terms of coding style.  This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence.  Every time we need to use \n\\pi\n\\pi\n, we have to remember or look up what is the precision that we use.  Not only does this practice introduce more work, it is also likely to introduce bugs.  \n\n\nIn C, we define \n\\pi\n\\pi\n as a macro constant \nM_PI\n.  But how should we do this in Java?  This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining.  The constant \n\\pi\n\\pi\n is universal, and does not really belong to any object (the value of \n\\pi\n\\pi\n is the same for every circle!).  Another example: if we define a method \nsqrt()\n that computes the square root of a given number, this is a general function that is not associated with any object as well.\n\n\nA solution to this is to associate these \nglobal\n values and functions with a \nclass\n instead of with an \nobject\n.  For instance. Java predefines a \nMath\n class\n6\n that is populated with constants \nPI\n and \nE\n (for Euler's number \ne\ne\n), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the \nstatic\n keyword.  We can additionally add a keyword \nfinal\n to indicate that the value of the field will not change\n7\n.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nMath\n \n{\n\n  \n:\n\n  \npublic\n \nstatic\n \nfinal\n \ndouble\n \nPI\n \n=\n \n3.141592653589793\n;\n\n  \n:\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nWe call these fields and methods that are associated with a class as \nclass fields\n and \nclass methods\n, and fields and methods that are associated with an object as \ninstance fields\n and \ninstance methods\n.\n\n\n\n\nClass Fields and Methods in Python\n\n\nNote that, in Python, any variable declared within a \nclass\n block is a class field:\n\n1\n2\n3\nclass\n \nCircle\n:\n\n  \nx\n \n=\n \n0\n\n  \ny\n \n=\n \n0\n\n\n\n\n\nIn the above example, \nx\n and \ny\n are class fields, not instance fields.\n\n\n\n\nExample: The Circle class\n\n\nNow, let revise our \nCircle\n class to improve the code and make it a little more complete:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\nimport\n \njava.lang.Math\n;\n\n\n\n/**\n\n\n * A Circle object encapsulates a circle on a 2D plane.  \n\n\n */\n\n\nclass\n \nCircle\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n  \n// x-coordinate of the center\n\n  \nprivate\n \ndouble\n \ny\n;\n  \n// y-coordinate of the center\n\n  \nprivate\n \ndouble\n \nr\n;\n  \n// the length of the radius\n\n\n  \n/**\n\n\n   * Create a circle centered on (centerX, centerY) with given radius\n\n\n  */\n\n  \npublic\n \nCircle\n(\ndouble\n \ncenterX\n,\n \ndouble\n \ncenterY\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nx\n \n=\n \ncenterX\n;\n\n    \ny\n \n=\n \ncenterY\n;\n\n    \nr\n \n=\n \nradius\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return the area of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n*\nr\n*\nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return the circumference of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetCircumference\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n*\n2\n*\nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Move the center of the circle to the new position (newX, newY)\n\n\n   */\n\n  \npublic\n \nvoid\n \nmoveTo\n(\ndouble\n \nnewX\n,\n \ndouble\n \nnewY\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n    \ny\n \n=\n \nnewY\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return true if the given point (testX, testY) is within the circle.\n\n\n   */\n\n  \npublic\n \nboolean\n \ncontains\n(\ndouble\n \ntestX\n,\n \ndouble\n \ntestY\n)\n \n{\n\n    \nreturn\n \nfalse\n;\n\n    \n// TODO: left as an exercise  \n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nCreating and Interacting with \nCircle\n objects\n\n\nTo use the \nCircle\n class, we can either:\n\n\n\n\ncreate a \nmain()\n function, compile and link with the \nCircle\n class, and create an executable program, just like we usually do with a C program, OR\n\n\nuse \njshell\n, which is part of Java 9 (but not earlier versions). \njshell\n provides a \nread-evaluate-print loop\n (REPL) to help us quickly try out various features of Java.\n\n\n\n\nWe will write a complete Java program with \nmain()\n later in this class, but for now, we will use \njshell\n to demonstrate the various language features of Java\n7\n.\n\n\nThe demonstration below loads the \nCircle\n class written above (with the \ncontains\n method completed) from a file named \nCircle.java\n8\n, and creates two \nCircle\n objects, \nc1\n and \nc2\n.  We use the \nnew\n keyword to tell Java to create an object of type \nCircle\n here, passing in the center and the radius.\n\n\n1\nCircle\n \nc1\n \n=\n \nnew\n \nCircle\n(\n0\n,\n \n0\n,\n \n100\n);\n\n\n\n\n\n\n\n\n\n\nReference Type vs. Primitive Type\n\n\nThe variable \nc1\n actually stores an abstraction over a \nreference\n to the Circle object, instead of the object itself.\n\nAll objects are stored as references in Java\n.\n\n\nThe other variable type supported in Java is \nprimitive\n type.  A variable of primitive type stores the \nvalue\n instead of a reference to the value.\nJava supports eight \nprimitive\n data types: \nbyte\n, \nshort\n, \nint\n, \nlong\n, \nfloat\n, \ndouble\n, \nboolean\n and \nchar\n.  If you are familiar with C, these data types should not be foreign to you.  One important difference is that a \nchar\n variable stores a 16-bit Unicode character, not an 8-bit character like in C.  Java uses the type \nbyte\n for that.  The other notable difference is that Java defines \ntrue\n and \nfalse\n as possible value to a \nboolean\n, unlike C which uses \n0\n for false and non-\n0\n for true.  \n\n\nYou can read all about Java \nvariables\n and \nprimitive data types\n in Oracle's Java Tutorial.\n\n\nType Safety\n\n\nSome languages are stricter in terms of type \"compatibility\" than others.  C compilers, however, are not very strict.  If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and runs.\n\n\nTake:\n\n\n1\n2\n3\n4\n5\n#include\n \n<stdio.h>\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nprintf\n(\n\"%d\n\\n\n\"\n,\n \n\"cs2030\"\n);\n\n\n}\n\n\n\n\n\n\n\nIn Line 4, we treat the address to a string as integer.  This generates a compiler's warning.\n\n\nIn C, you can \ntype cast\n a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type.  The compiler would listen and do that for you.  The following code would print out gibberish and would compile perfectly without error.\n\n\n1\n2\n3\n4\n5\n#include\n \n<stdio.h>\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nprintf\n(\n\"%d\n\\n\n\"\n,\n \n(\nint\n)\n\"cs2030\"\n);\n\n\n}\n\n\n\n\n\n\n\nSuch flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on.\n\n\nJava is very strict when it comes to type checking, and is one of the \ntype-safe\n languages. Java ensures that basic operations (such as \n+\n, \n-\n, etc) and method calls apply to values in a way that makes sense.  If you try to pull the same trick as above, you will receive an error:\n\n\n\n\n\nExercise\n\n\n\n\n\n\nIn the example above, we implemented a class \nCircle\n.  There, we store and pass around two \ndouble\n variables that correspond to the x-coordinate and y-coordinate of a point.  The code would be neater if we create a second class \nPoint\n that encapsulates the concept of a point on a 2D plane and the operations on points.\n\n\nImplement a new class \nPoint\n and modify the class \nCircle\n to use the class \nPoint\n.  Pay attention to what methods and fields (if any) you expose as \npublic\n outside of the abstraction barrier of a \nPoint\n object.\n\n\nYou will need to use \njshell\n from Java 1.9 (or JDK 9) to interact with your new classes.\n\n\n\n\n\n\nUse \njshell\n to try out the following.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nA\n \n{\n\n  \npublic\n \nstatic\n \nint\n \nx\n \n=\n \n1\n;\n\n  \npublic\n \nint\n \ny\n \n=\n \n5\n;\n\n\n  \nvoid\n \nincrX\n()\n \n{\n\n    \nx\n \n=\n \nx\n \n+\n \n1\n;\n\n  \n}\n\n\n  \nvoid\n \nincrY\n()\n \n{\n\n    \ny\n \n=\n \ny\n \n+\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\nA\n \na1\n \n=\n \nnew\n \nA\n();\n\n\nA\n \na2\n \n=\n \nnew\n \nA\n();\n\n\n\n\n\n\n\nAfter executing \na1.x = 10\n, what is the value of \na2.x\n?\n\n\nAfter executing \na1.y = 10\n, what is the value of \na2.y\n?\n\n\nIs \nA.x = 3\n a valid statement?  Is \nA.y = 3\n a valid statement?  \n\n\nNote: Even though \na1.x\n is valid, it is considered a bad programming practice to access a class field through an instance variable (e.g., \na1.x\n).  The proper way to do it is to use the class name \nA.x\n).\n\n\n\n\n\n\nConsider the following two classes:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n;\n\n  \npublic\n \nvoid\n \nchangeSelf\n()\n \n{\n\n    \nx\n \n=\n \n1\n;\n\n  \n}\n\n  \npublic\n \nvoid\n \nchangeAnother\n(\nA\n \na\n)\n \n{\n\n    \na\n.\nx\n \n=\n \n1\n;\n\n  \n}\n\n\n\n}\n\n\n\nclass\n \nB\n \n{\n\n  \npublic\n \nvoid\n \nchangeAnother\n(\nA\n \na\n)\n \n{\n\n    \na\n.\nx\n \n=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWhich line(s) above violate the \nprivate\n access modifier of \nx\n?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOften, the instructions and data are stored in different regions of the memory.\u00a0\n\u21a9\n\n\n\n\n\n\nJavascript would happily convert \n4\n into a string for you, and return \n45\n.\u00a0\n\u21a9\n\n\n\n\n\n\nassuming the parameters are passed correctly.\u00a0\n\u21a9\n\n\n\n\n\n\nComputer scientists just can't decide on what to call this!\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nOthers include \nprotected\n and the \ndefault\n modifier.  For beginners, it is better that we explicitly specify something as \nprivate\n or \npublic\n.\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nThe class \nMath\n is provided by the package \njava.lang\n in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  To use this class, we need to add the line \nimport\n \njava.lang.Math\n at the beginning of our program.\u00a0\n\u21a9\n\n\n\n\n\n\nYou can download and install \njshell\n yourself, as part of \nJava Development Kit version 9 (JDK 9)\n\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nWe use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension \n.java\n to the filename.\u00a0\n\u21a9",
            "title": "1. Abstraction & Encapsulation"
        },
        {
            "location": "/lec01/index.html#lecture-1-abstraction-and-encapsulation",
            "text": "",
            "title": "Lecture 1: Abstraction and Encapsulation"
        },
        {
            "location": "/lec01/index.html#learning-objectives",
            "text": "After this lecture, students should:   recap some fundamental programming concepts, including the execution model of a program, abstractions over code and data, primitive and composite data types.  appreciate the importance of maintaining abstraction barrier in software development  understand the differences between statically and dynamically typed languages  understand the concepts of object-oriented programming, including encapsulation, data hiding, fields and methods, constructors, mutators/accessors, classes and objects, and their purposes of introducing them as a method of programming.  know the purpose and usage of Java keywords  class ,  public ,  private ,  final ,  static ,  import ,  new  understand that Java is a type-safe language, in contrast to C  be familiar with Java variable and primitive types",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec01/index.html#what-exactly-is-a-program",
            "text": "A program is a set of instructions we issue to computers to manipulate data.  A programming language is a formal language that helps programmers specify precisely what are the instructions we issue to computers, using code that are often made up of keywords, symbols, and names.  Computers execute the instructions in their  processing units , and store the instructions and data in their  memory 1 .  The processing units recognize the instructions based on the specific patterns of bits and manipulate data as a sequence of bits.  A programming language, however, is written at a higher level of  abstraction  (i.e., at a higher conceptual level), so that as a programmer, we only need to write a few lines of code to give complex instructions to the computer.  A  compiler  or  interpreter  is responsible for translating these programs written in high level language to  assembly code  or  machine code , i.e., bit patterns that the processing units can understand.  There are thousands of programming languages in existence.   C  is one of the languages that is a  low-level language  -- i.e., it provides a very thin layer of abstractions on top of machine code.  On the other hand, languages such as  Python  and  JavaScript  are high-level languages.  As an example, in C, you can directly manage memory allocation.  In JavaScript and Python, you cannot.",
            "title": "What Exactly is a Program?"
        },
        {
            "location": "/lec01/index.html#abstraction-variable-and-type",
            "text": "One of the important abstractions that is provided by a programming language is  variable .  Data are stored in some location in the computer memory.  But we should not be referring to the memory location all the time.  First, referring to something like  0xFA49130E  is not user-friendly; Second, the location may change.  A  variable  is an abstraction that allows us to give a user-friendly name to a piece of data in memory.  We use the  variable name  whenever we want to access the  value  in that location, and  pointer to the variable  or  reference to the variable  whenever we want to refer to the address of the location.  Let's think a bit more about how a sequence of bits is abstracted as data in a programming language.  At the machine level, these bits are just, well, bits.  We give the bits a  semantic  at the program level, e.g., we want to interpret the sequence of bits as numbers, letters, etc.  E.g., the number (integer, to be exact)  65  and the letter  A  all share the same sequence of bits  0100 0001  but are interpreted differently and possibly manipulated differently.    The  type  of a variable tells the compiler or the interpreter how to interpret the variable and how to manipulate the variable.    For instance, supposed that in Python, if you have two variables  x  and  y  storing the values  4  and  5  respectively, if you  print x + y , you would get  45  if  x  and  y  are strings; you would get  9  if  x  and  y  are integers; you would get an error if  4  is an integer and  5  is a string.    In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation  +  is not defined over an integer and a string in Python 2 .  Python is a  dynamically typed  language.  The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program.  Note that, the type is associated with the  values , and the type of the variable changes depending on the value it holds.  C, on the other hand, is a  statically typed  language.  We need to  declare  every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type  int .  We check if the right type is used during the compilation of the program.  1\n2 int   x   =   4 ;   // ok  int   y   =   \"5\" ;   // error    By annotating each variable with its type, the C compiler also knows how much memory space is needed to store a variable.",
            "title": "Abstraction: Variable and Type"
        },
        {
            "location": "/lec01/index.html#abstraction-functions",
            "text": "Another important abstraction provided by a programming language is  function  (or  procedure ).  This abstraction allows programmers to group a set of instructions and give it a name.  The named set of instructions may take one or more variables as input parameters, and return one or more values.     Like all other abstractions, defining functions allow us to think at a higher conceptual level.  By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity.  Defining functions allow us to abstract away the implementation details from the caller.  Once a function is defined, we can change the way the function is implemented without affecting the code that calls the function, as long as the semantic and the  interface  of the function remains the same.  Function, therefore, is a critical mechanism for achieving  separation of concerns  in a program.  We separate the concerns about how a particular function is implemented, from the concerns about how the function is used to perform a higher-level task.  Defining functions also allow us to  reuse  code.  We do not have to repeatedly write the same chunk of code if we group the sequence of code into a function -- then we just need to call the function to invoke this sequence of code every time we need it.  If this chunk of code is properly written and debugged, then we can be pretty sure that everywhere the function is invoked, the code is correct 3 .  C is a  procedural language .  A C program consists of functions, with the  main()  function serves as the entry point to the program.  Since C is a statically typed language, a C function has a return type, and each  function parameter (or  argument ) has a type as well.  (Note that this statement does not mean that a C function must return a  value .  If the function does not return a value, we define its return type as  void .)  Recall that the bits representing the instructions are also stored in the computer memory in an area separated from the data.  The instructions that belong to the same function are stored in adjacent memory locations.  Just like we can refer to a variable using its memory address through its  reference  (or  pointer ), we can refer to a function using the memory address of the entry point to the function.",
            "title": "Abstraction: Functions"
        },
        {
            "location": "/lec01/index.html#abstraction-composite-data-type",
            "text": "Just like functions allow programmers to group instructions, give it a name, and refer to it later, a  composite data type  allows programmers to group  primitive types  together, give it a name (a new type), and refer to it later.  This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or every day objects such as a person, a product, etc.  Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented.  For instance, a circle on a 2D plane can be represented by the center ( x ,  y ) and its radius  r , or it can be represented by the top left corner ( x , y ) and the width  w  of the bounding square.  In C, we build composite data type with  struct .  For example,  1\n2\n3\n4 struct   circle   { \n   float   x ,   y ;   // (x,y) coordinate of the center. \n   float   r ;   // radius  }    Once we have the  struct  defined, we are not completely shielded from its representation, until we write a set of functions that operates on the  circle  composite type.  For instance,  1\n2\n3 float   circle_area ( circle   c )   {   ...   };  bool    circle_contains_point ( circle   c ,   point   p )   {   ...   }; \n   :    Implementing these functions obviously requires the knowledge of how a circle is represented.  Once the set of functions that operates on and manipulates circles is available, we can use  circle  type without worrying about the internal representation.    If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.  We can imagine an  abstraction barrier  between the code that uses a composite data type along with its associated set of functions, and the code that define the data type along with the implementation of the functions.  Above the barrier, the concern is about using the composite data type to do useful things, while below the barrier, the concern is about how to represent and manipulate the composite data type.  While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from a single person.  The abstraction barrier separates the role of the programmer into two: (i) an  implementer , which define that data type and provide the implementation, and (ii) a  client , which uses the composite data type to perform a higher level task 4 .  Part of my aim in CS2030 is to switch your mindset into thinking in terms of these two roles.  Note that the implementer and the client may very well be the same programmer.",
            "title": "Abstraction: Composite Data Type"
        },
        {
            "location": "/lec01/index.html#abstraction-class-and-object-or-encapsulation",
            "text": "We can further bundle the composite data type and its associated functions together in another abstraction, called a  class .  A class is a data type with a group of functions associated with it.  We call the functions as  methods  and the data in the class as  fields  (or  members , or  states , or  attributes 4 ).   A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right  interface  for others to use.  Just like we can create variables of a given type, we can create  objects  of a given class.  Objects are  instances  of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.  Recall that programs written in a procedural language such as a C consists of functions, with a  main()  function as the entry point.  A program written in an  object-oriented language  such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods.  One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has certain properties, exhibit certain behavior, and they allow certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used everyday (unless we try to repair it) 5 .    The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called  encapsulation .",
            "title": "Abstraction: Class and Object (or, Encapsulation)"
        },
        {
            "location": "/lec01/index.html#breaking-the-abstraction-barrier",
            "text": "In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier.    Consider the case of implementing  circle  as a C  struct .  Suppose someone wants to move the center of the circle  c  to a new position ( x ,  y ), instead of implementing a function  circle_move_to(c, x, y)  (which would still keep the representation used under the barrier), the person wrote:  1\n2 c . x   =   x ;  c . y   =   y ;    This code would still be correct, but the abstraction barrier is broken since we now make explicit assumption that there are two variables  x  and  y  inside the  circle  data type that corresponds to the center of the circle.  If one day, we want to represent a circle differently, then we have to carefully change all the code that read and write these variables  x  and  y  and update them.   Breaking Python's Abstraction Barrier  Python tries to prevent  accidental  access to internal representation by having a convention of prefixing the internal variables with  _  (one underscore) or  __  (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.",
            "title": "Breaking the Abstraction Barrier"
        },
        {
            "location": "/lec01/index.html#data-hiding",
            "text": "Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, supports  private  and  public  access modifiers 5 .  A field or a method that is declared as  private  cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a  public  field or method can be accessed, modified, or invoked from outside the class.  Such mechanism to protect the abstraction barrier from being broken is called  data hiding  or  information hiding .  This protection is enforced by the  compiler  at compile time.",
            "title": "Data Hiding"
        },
        {
            "location": "/lec01/index.html#example-the-circle-class",
            "text": "Let's put together the concepts of encapsulation and data hiding to define a  Circle  class in Java:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 /**   * A Circle object encapsulates a circle on a 2D plane.     */  class   Circle   { \n   private   double   x ;    // x-coordinate of the center \n   private   double   y ;    // y-coordinate of the center \n   private   double   r ;    // the length of the radius \n\n   /**     * Return the area of the circle.     */ \n   public   double   getArea ()   { \n     return   3.1415926   *   r   *   r ; \n   } \n\n   /**     * Move the center of the circle to the new position (newX, newY)     */ \n   public   void   moveTo ( double   newX ,   double   newY )   { \n     x   =   newX ; \n     y   =   newY ; \n   }  }    Here, we define  x ,  y , and  r  as three private fields inside the class  Circle .  Note that these fields are not accessible and modifiable outside of the class  Circle , but they can be accessed and modified within  Circle  (inside the abstraction barrier), such as in the methods  getArea  and  moveTo .",
            "title": "Example: The Circle class"
        },
        {
            "location": "/lec01/index.html#constructors-accessors-and-mutators",
            "text": "With data hiding, we completely isolate the internal representation of a class using an abstraction barrier.  With no way for the user of the class to modify the fields directly, it is common for a class to provide methods to initialize and modify these internal fields (such as the  moveTo()  method above).  A method that initializes an object is called a  constructor , and a method that retrieves or modifies the properties of the object is called the  accessor  (or  getter ) or  mutator  (or  setter ).  A constructor method is a special method within the class.  It cannot be called directly but is invoked automatically when an object is instantiated.   In Java, a constructor method  has the same name as the class  and  has no return type .  A constructor can take in arguments just like other functions.  The class  Circle  can have a constructor such as the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 class   Circle   { \n     : \n   /**     * Create a circle centered on (centerX, centerY) with given radius    */ \n   public   Circle ( double   centerX ,   double   centerY ,   double   radius )   { \n     x   =   centerX ; \n     y   =   centerY ; \n     r   =   radius ; \n   } \n     :  }    The use of accessor and mutator methods is a bit controversial.   Suppose that we provide an accessor method and a mutator method for every private field, then we are actually exposing the internal representation, therefore breaking the encapsulation.  For instance:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 class   Circle   { \n     : \n\n   public   double   getX ()   { \n     return   x ; \n   } \n\n   public   void   setX ( double   newX )   { \n     x   =   newX ; \n   } \n\n   public   double   getY ()   { \n     return   y ; \n   } \n\n   public   void   setY ( double   newY )   { \n     y   =   newY : \n   } \n\n   public   double   getR ()   { \n     return   r ; \n   } \n\n   public   void   setR ( double   newR )   { \n     r   =   newR ; \n   } \n     :  }    The examples above are pretty pointless.  If we need to know the internal and do something with it, we are doing it wrong.  The right approach is to implement a method within the class that do whatever we want the class to do.   For instance, suppose that we want to know the circumference of the circle  c , one approach would be:  1     double   circumference   =   2 * c . getR ()* 3.1415926 ;    where  c  is a  Circle  object.  A better approach would be to add a new method  getCircumference()  in the  Circle  class, and call it instead: 1     double   circumference   =   c . getCircumference ();    The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact.  If one fine day, the implementer of  Circle  decided to store the diameter of the circle instead of the radius, then only the implementer needs to change the implementation of  getCircumference .  The client does not have to change anything.     Constructor in Python and JavaScript  In Python, the constructor is the  __init__  method.   In JavaScript, the constructor is simply called  constructor .",
            "title": "Constructors, Accessors, and Mutators"
        },
        {
            "location": "/lec01/index.html#class-fields-and-methods",
            "text": "Let's look at the implementation of  getArea()  above.  We use the constant  \\pi \\pi  but hardcoded it as 3.1415926.  Hardcoding such a magic number is a  no-no  in terms of coding style.  This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence.  Every time we need to use  \\pi \\pi , we have to remember or look up what is the precision that we use.  Not only does this practice introduce more work, it is also likely to introduce bugs.    In C, we define  \\pi \\pi  as a macro constant  M_PI .  But how should we do this in Java?  This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining.  The constant  \\pi \\pi  is universal, and does not really belong to any object (the value of  \\pi \\pi  is the same for every circle!).  Another example: if we define a method  sqrt()  that computes the square root of a given number, this is a general function that is not associated with any object as well.  A solution to this is to associate these  global  values and functions with a  class  instead of with an  object .  For instance. Java predefines a  Math  class 6  that is populated with constants  PI  and  E  (for Euler's number  e e ), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the  static  keyword.  We can additionally add a keyword  final  to indicate that the value of the field will not change 7 .  1\n2\n3\n4\n5\n6 class   Math   { \n   : \n   public   static   final   double   PI   =   3.141592653589793 ; \n   : \n   :  }    We call these fields and methods that are associated with a class as  class fields  and  class methods , and fields and methods that are associated with an object as  instance fields  and  instance methods .   Class Fields and Methods in Python  Note that, in Python, any variable declared within a  class  block is a class field: 1\n2\n3 class   Circle : \n   x   =   0 \n   y   =   0   \nIn the above example,  x  and  y  are class fields, not instance fields.",
            "title": "Class Fields and Methods"
        },
        {
            "location": "/lec01/index.html#example-the-circle-class_1",
            "text": "Now, let revise our  Circle  class to improve the code and make it a little more complete:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49 import   java.lang.Math ;  /**   * A Circle object encapsulates a circle on a 2D plane.     */  class   Circle   { \n   private   double   x ;    // x-coordinate of the center \n   private   double   y ;    // y-coordinate of the center \n   private   double   r ;    // the length of the radius \n\n   /**     * Create a circle centered on (centerX, centerY) with given radius    */ \n   public   Circle ( double   centerX ,   double   centerY ,   double   radius )   { \n     x   =   centerX ; \n     y   =   centerY ; \n     r   =   radius ; \n   } \n\n   /**     * Return the area of the circle.     */ \n   public   double   getArea ()   { \n     return   Math . PI * r * r ; \n   } \n\n   /**     * Return the circumference of the circle.     */ \n   public   double   getCircumference ()   { \n     return   Math . PI * 2 * r ; \n   } \n\n   /**     * Move the center of the circle to the new position (newX, newY)     */ \n   public   void   moveTo ( double   newX ,   double   newY )   { \n     x   =   newX ; \n     y   =   newY ; \n   } \n\n   /**     * Return true if the given point (testX, testY) is within the circle.     */ \n   public   boolean   contains ( double   testX ,   double   testY )   { \n     return   false ; \n     // TODO: left as an exercise   \n   }  }",
            "title": "Example: The Circle class"
        },
        {
            "location": "/lec01/index.html#creating-and-interacting-with-circle-objects",
            "text": "To use the  Circle  class, we can either:   create a  main()  function, compile and link with the  Circle  class, and create an executable program, just like we usually do with a C program, OR  use  jshell , which is part of Java 9 (but not earlier versions).  jshell  provides a  read-evaluate-print loop  (REPL) to help us quickly try out various features of Java.   We will write a complete Java program with  main()  later in this class, but for now, we will use  jshell  to demonstrate the various language features of Java 7 .  The demonstration below loads the  Circle  class written above (with the  contains  method completed) from a file named  Circle.java 8 , and creates two  Circle  objects,  c1  and  c2 .  We use the  new  keyword to tell Java to create an object of type  Circle  here, passing in the center and the radius.  1 Circle   c1   =   new   Circle ( 0 ,   0 ,   100 );",
            "title": "Creating and Interacting with Circle objects"
        },
        {
            "location": "/lec01/index.html#reference-type-vs-primitive-type",
            "text": "The variable  c1  actually stores an abstraction over a  reference  to the Circle object, instead of the object itself. All objects are stored as references in Java .  The other variable type supported in Java is  primitive  type.  A variable of primitive type stores the  value  instead of a reference to the value.\nJava supports eight  primitive  data types:  byte ,  short ,  int ,  long ,  float ,  double ,  boolean  and  char .  If you are familiar with C, these data types should not be foreign to you.  One important difference is that a  char  variable stores a 16-bit Unicode character, not an 8-bit character like in C.  Java uses the type  byte  for that.  The other notable difference is that Java defines  true  and  false  as possible value to a  boolean , unlike C which uses  0  for false and non- 0  for true.    You can read all about Java  variables  and  primitive data types  in Oracle's Java Tutorial.",
            "title": "Reference Type vs. Primitive Type"
        },
        {
            "location": "/lec01/index.html#type-safety",
            "text": "Some languages are stricter in terms of type \"compatibility\" than others.  C compilers, however, are not very strict.  If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and runs.  Take:  1\n2\n3\n4\n5 #include   <stdio.h>  int   main ()  { \n     printf ( \"%d \\n \" ,   \"cs2030\" );  }    In Line 4, we treat the address to a string as integer.  This generates a compiler's warning.  In C, you can  type cast  a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type.  The compiler would listen and do that for you.  The following code would print out gibberish and would compile perfectly without error.  1\n2\n3\n4\n5 #include   <stdio.h>  int   main ()  { \n     printf ( \"%d \\n \" ,   ( int ) \"cs2030\" );  }    Such flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on.  Java is very strict when it comes to type checking, and is one of the  type-safe  languages. Java ensures that basic operations (such as  + ,  - , etc) and method calls apply to values in a way that makes sense.  If you try to pull the same trick as above, you will receive an error:",
            "title": "Type Safety"
        },
        {
            "location": "/lec01/index.html#exercise",
            "text": "In the example above, we implemented a class  Circle .  There, we store and pass around two  double  variables that correspond to the x-coordinate and y-coordinate of a point.  The code would be neater if we create a second class  Point  that encapsulates the concept of a point on a 2D plane and the operations on points.  Implement a new class  Point  and modify the class  Circle  to use the class  Point .  Pay attention to what methods and fields (if any) you expose as  public  outside of the abstraction barrier of a  Point  object.  You will need to use  jshell  from Java 1.9 (or JDK 9) to interact with your new classes.    Use  jshell  to try out the following.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   A   { \n   public   static   int   x   =   1 ; \n   public   int   y   =   5 ; \n\n   void   incrX ()   { \n     x   =   x   +   1 ; \n   } \n\n   void   incrY ()   { \n     y   =   y   +   1 ; \n   }  }  A   a1   =   new   A ();  A   a2   =   new   A ();    After executing  a1.x = 10 , what is the value of  a2.x ?  After executing  a1.y = 10 , what is the value of  a2.y ?  Is  A.x = 3  a valid statement?  Is  A.y = 3  a valid statement?    Note: Even though  a1.x  is valid, it is considered a bad programming practice to access a class field through an instance variable (e.g.,  a1.x ).  The proper way to do it is to use the class name  A.x ).    Consider the following two classes:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   private   int   x ; \n   public   void   changeSelf ()   { \n     x   =   1 ; \n   } \n   public   void   changeAnother ( A   a )   { \n     a . x   =   1 ; \n   }  }  class   B   { \n   public   void   changeAnother ( A   a )   { \n     a . x   =   1 ; \n   }  }    Which line(s) above violate the  private  access modifier of  x ?        Often, the instructions and data are stored in different regions of the memory.\u00a0 \u21a9    Javascript would happily convert  4  into a string for you, and return  45 .\u00a0 \u21a9    assuming the parameters are passed correctly.\u00a0 \u21a9    Computer scientists just can't decide on what to call this!\u00a0 \u21a9 \u21a9    Others include  protected  and the  default  modifier.  For beginners, it is better that we explicitly specify something as  private  or  public .\u00a0 \u21a9 \u21a9    The class  Math  is provided by the package  java.lang  in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  To use this class, we need to add the line  import   java.lang.Math  at the beginning of our program.\u00a0 \u21a9    You can download and install  jshell  yourself, as part of  Java Development Kit version 9 (JDK 9) \u00a0 \u21a9 \u21a9    We use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension  .java  to the filename.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec02/index.html",
            "text": "Lecture 2: Inheritance & Polymorphism\n\n\nLearning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nbe able to build a mental model for how objects and classes are represented in Java\n\n\nunderstand the concepts of object-oriented programming, including interface, polymorphism, late binding, inheritance, method overloading, and the usage of these concepts in programming.\n\n\nknow the purpose and usage of Java keywords \nimplements\n, \nextends\n, \nsuper\n, \nthis\n, and \n@Override\n\n\nunderstand Java concepts of arrays, enhanced \nfor\n loop, and method signature.\n\n\n\n\nMemory Model for Objects\n\n\nTo help understand how classes and objects work, it is useful to visualize how they are stored in the memory.  We mentioned last week that data (e.g., fields) and code (e.g., methods) are stored in two different regions in the memory.  Since an object contains both fields and methods, where do we keep an object?\n\n\nIt turned out that different implementations of Java may store the objects differently, but here is one way that we will follow for CS2030:\n\n\n\n\nIn the figure above, there are two objects of the same class.  An object is referred to through its reference, which is a pointer to the memory location where the instance fields for the object is stored, along with a pointer to a \nmethod table\n.  A method table stores a table of pointers to the methods, along with a table to the class fields.    \n\n\nAs an example, consider the following class:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n;\n\n  \nstatic\n \npublic\n \nint\n \ny\n;\n\n\n  \npublic\n \nvoid\n \nfoo\n()\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nbar\n()\n \n{\n\n    \n:\n\n  \n}\n\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nIf we have two instances of A, \na1\n and \na2\n, with \nA.y = 1\n, \na1.x = 9\n, \na2.x = 40\n, then the memory layout looks like:\n\n\n\n\nNote that, we have only one copy of the \nstatic\n class field \ny\n, regardless of how many instances of \nA\n we create.\n\n\nEnforcing Abstraction Barrier with Interface\n\n\nRecall the concept of encapsulation. When we develop a large piece of software, it is important to hide the details on data representation and implementation, and only expose certain \npublic\n methods for the users to use.  We can imagine that there is an abstraction barrier between the code that implements the internals of a class (called the \nimplementer\n) and the code that uses the class (called the \nclient\n) to achieve a higher level task.\n\n\nWe have seen that we use \nprivate\n to enforce data hiding -- to hide certain fields and methods from outside of the barrier.  Now, we are going to see how we can enforce that the right set of methods are defined, implemented, and used on both sides of the barrier.\n\n\nThe mechanism to do this is through defining an \ninterface\n (aka a \nprotocol\n as it is called in Objective-C or Swift).  An interface is like a contract between the implementer of a class and the client of a class.  If a class promises to implement an interface, then we are guaranteed that the methods defined in the interface are already implemented in the class.  Otherwise, the code would not compile.\n\n\nIn Java, we can define an interface using \ninterface\n keyword:\n\n\n1\n2\n3\n4\n5\ninterface\n \nShape\n \n{\n\n  \npublic\n \ndouble\n \ngetArea\n();\n\n  \npublic\n \ndouble\n \ngetPerimeter\n();\n\n  \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n);\n\n\n}\n\n\n\n\n\n\n\nThe example interface \nShape\n above contains only the declaration of the methods, not the implementation.  \n\n\nNow, let's see how the implementer would implement a class using the interface.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nimport\n \njava.lang.Math\n;\n\n\n\nclass\n \nCircle\n \nimplements\n \nShape\n \n{\n\n  \nprivate\n \nPoint\n \ncenter\n;\n\n  \nprivate\n \ndouble\n \nradius\n;\n\n\n  \npublic\n \nCircle\n(\nPoint\n \ncenter\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nthis\n.\ncenter\n \n=\n \ncenter\n;\n\n    \nthis\n.\nradius\n \n=\n \nradius\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nmoveTo\n(\nPoint\n \np\n)\n \n{\n\n    \ncenter\n \n=\n \np\n;\n\n  \n}\n\n\n  \n@Override\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n \n*\n \nradius\n \n*\n \nradius\n;\n\n  \n}\n\n\n  \n@Override\n\n  \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n)\n \n{\n\n    \nreturn\n \n(\np\n.\ndistance\n(\ncenter\n)\n \n<\n \nradius\n);\n\n  \n}\n\n\n  \n@Override\n\n  \npublic\n \ndouble\n \ngetPerimeter\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n \n*\n \n2\n \n*\n \nradius\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThis is very similar to the code you saw in Lecture 1, except that in Line 2, we say \nclass\n \nCircle\n \nimplements\n \nShape\n.  This line informs the compiler that the programmer intends to implement all the methods included in the interface \nShape\n exactly as declared (in terms of names, the number of arguments, the types of arguments, returned type, and access modifier).  The rest of the class is the same, except that we renamed \ngetCircumference\n with \ngetPerimeter\n, which is more general and applies to all shapes.  We also added \nannotations\n to our code by adding the line \n@Override\n before methods in \nCircle\n that implement the methods declared in \nShape\n.  This annotation is optional, but it informs the compiler of our intention and helps make the intention of the programmer clearer to others who read the code.\n\n\n\n\nJava Annotation\n\n\nAnnotations are metadata that is not part of the code.  They do not affect execution.  They are useful to compilers and other software tools, as well as humans who read the code.  While we can similarly make the code more human-friendly with comments, an annotation is structured and so can be easily parsed by software.  You will see 1-2 more useful annotations in this module.\n\n\n\n\n\n\nthis\n\n\nThe \nthis\n keyword in Java that refers to the current object.  In the example above, we use \nthis\n to disambiguate the argument \ncenter\n and the field \ncenter\n.  In general, it is a good practice to use \nthis\n when referring the instance variable of the current object to make your intention clear.\n\n\n\n\nNote that we can have other methods (such as \nmoveTo\n) in the class beyond what is promised in the interface the class implements.\n\n\nA class can implement more than one interface.\n  For instance, let's say that we have another interface called \nPrintable\n[^1] with a single method defined:\n\n\n1\n2\n3\ninterface\n \nPrintable\n \n{\n\n  \npublic\n \nvoid\n \nprint\n();\n\n\n}\n\n\n\n\n\n\n\nThe implementer of \nCircle\n wants to inform the clients that the method \nvoid print()\n is implemented, it can do the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n     \n:\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nprint\n()\n \n{\n\n     \nSystem\n.\nout\n.\nprintf\n(\n\"radius: %f\\n\"\n,\n \nradius\n);\n\n     \nSystem\n.\nout\n.\nprintf\n(\n\"center:\"\n);\n\n     \ncenter\n.\nprint\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\nIn the above, we call \nprint()\n on the \nPoint\n object as well.  How do we know that \nPoint\n provides a \nprint()\n method?  Well, we can read the implementation code of \nPoint\n, or we can agree with the implementer of \nPoint\n that \nPoint\n provides a \nPrintable\n interface!  \n\n\nIt is important to note that, \ninterface\n provides a \nsyntactic\n contract on the abstraction barrier, but it does not provide a \nsemantic\n contract.  It does not, for instance, guarantee that \nprint()\n actually prints something to the screen.  One could still implement interface \nPrintable\n as follows:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n     \n:\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nprint\n()\n \n{\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\nand the code still compiles!\n\n\nNot all programming languages that support classes support interface.  C++, Javascript, and Python, for instance, do not support similar concepts.\n\n\n\n\nDefault Access Modifier for Interface\n\n\nIn the examples above, I explicitly specify the methods in the \nPrintable\n and \nShape\n interfaces as \npublic\n.  In Java, all methods in an interface are public by default, so the keywords \npublic\n could be omitted.\n\n\n\n\nInterface as Type\n\n\nIn Java, an interface is a type.  What this means is that:\n\n\n\n\nWe can declare a variable with an interface type, such as:\n\n1\n  \nShape\n \ncircle\n;\n\n\n\n\n\nor\n\n1\n  \nPrintable\n \ncircle\n;\n\n\n\n\n\nWe cannot, however, instantiate an object from an interface\nsince an interface is a \"template\", an \"abstraction\", and does not have an implementation.  For instance:\n\n\n\n\n1\n2\n3\n4\n  \n// this is not OK\n\n  \nPrintable\n \np\n \n=\n \nnew\n \nPrintable\n();\n\n  \n// this is OK\n\n  \nPrintable\n \ncircle\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, we can pass arguments of an interface type into a method, and the return type of a method can be an interface.\n\n\n\n\n\n\nAn object can be an instance of multiple types.  Recall that Java is a statically typed language. We associate a type with a variable.  We can assign a variable to an object if the object is an instance of the type of the variable.  For example, Line 4 above creates a new circle, which is an instance of three types: \nCircle\n, \nShape\n, and \nPrintable\n.  It is ok to assign this new circle to a variable of type \nPrintable\n.\n\n\n\n\n\n\nWe say that \nShape\n and \nPrintable\n are \nsupertypes\n of \nCircle\n, and \nCircle\n is a subtype of \nShape\n and \nPrintable\n.\n\n\nLate Binding and Polymorphism\n\n\nWe can now do something cool like this:\n\n1\n2\n3\n4\n5\n6\n7\n  \nPrintable\n[]\n \nobjs\n;\n\n    \n:\n\n    \n// initialize array objs\n\n  \n:\n\n  \nfor\n \n(\nPrintable\n \no\n:\n \nobjs\n)\n \n{\n\n      \no\n.\nprint\n();\n\n  \n}\n\n\n\n\n\n\nLet's examine this code.  Line 1 declares an array of objects of type \nPrintable\n.  We skip over the code to initialize the content of the array for now, and\njump to Line 5-7, which is a \nfor\n loop.  Line 5 declares a loop variable \no\n of type \nPrintable\n and loops through all objects in the array \nobjs\n, and Line 6 invokes the method \nprint\n of \no\n.\n\n\n\n\nArray and For Loops in Java\n\n\nSee Oracle's tutorial on \narray\n and \nenhanced loop\n\n\n\n\nThe magic happens in Line 6:\n\n\n\n\nFirst, since we know that any object in the array has the type \nPrintable\n, this means that they must implement the \nPrintable\n interface and support the method \nprint()\n.  \n\n\nSecond, we do not know, and we do not \nneed\n to know which class an object is an instance of.\n\n\nThird, we can actually have objects of completely unrelated classes in the same array. We can have objects of type \nCircle\n, and objects of type \nPoint\n.  We can have objects of type \nFactory\n, or objects of type \nStudent\n, or objects of type \nCushion\n.  As long as the objects implement the \nPrintable\n interface, we can put them into the same array.\n\n\nFourth, at \nrun time\n, Java looks at the object \no\n, and determines its class, and invokes the right implementation of \nprint()\n corresponding to the \no\n.  That is, if \no\n is an instance of a class \nCircle\n, then it will call \nprint()\n method of \nCircle\n; if \no\n is an instance of a class \nPoint\n, then it will call \nprint()\n method of \nPoint\n, and so on.\n\n\n\n\nTo further appreciate the magic in Line 6, especially on last point above, consider how a function call is done in C.  In C, you cannot have two functions of the same name within the same scope, so if you call a function \nprint()\n, you know exactly which set of instructions will be called\n1\n.  So, the name \nprint\n is bound to the corresponding set of instructions at compilation time.  This is called \nstatic binding\n or \nearly binding\n.\nTo have \nprint()\n for different types, we need to name them differently to avoid naming conflicts: e.g., \nprint_point()\n, \nprint_circle()\n.\n\n\nIn a language with static binding, suppose you want to mix objects of different types\ntogether in an array, you need to do something like the following pseudocode:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n   \nfor\n \neach\n \nobject\n \nin\n \nthe\n \narray\n\n       \nif\n \nobject\n \nis\n \na\n \npoint\n\n           \nprint_point\n(\nobject\n)\n\n       \nelse\n \nif\n \nobject\n \nis\n \na\n \ncircle\n\n           \nprint_circle\n(\nobject\n)\n\n     \nelse\n \nif\n \nobject\n \nis\n \na\n \nsquare\n\n           \nprint_square\n(\nobject\n)\n\n           \n:\n\n           \n:\n\n\n\n\n\n\nNot only is the code verbose and ugly, it would be cumbersome if you define a new compound data type that supports printing, since you would need to remember to add a new if-else condition to call for a corresponding print function.\n\n\nIn OO languages, you can have methods named \nprint()\n implemented differently in different classes.  When we compile the code above, the compiler will have no way to know which implementation will be called.  The bindings of \nprint()\n to the actual set of instructions will only be done at run time, after the object \no\n is instantiated from a class.  This is known as \ndynamic binding\n, or \nlate binding\n, or \ndynamic dispatch\n.\n\n\n\n\nIf you understand how an object is represented internally, this is not so magical after all.  Referring to the figure above, the array \nobjs[]\n contains an array of references to objects, the first one is a \nCircle\n object, and the following two are \nPoint\n objects.  When \no.print()\n is invoked, Java refers to the method table, which points to either the method table for \nCircle\n or for \nPoint\n, based on the class the object is an instance of.\n\n\nThis behavior, which is common to OO programming languages, is known as \npolymorphism\n2\n.\n\n\nThe Abstraction Principle\n\n\nWith the interface \nShape\n, we can implement other classes, such as \nRectangle\n, \nSquare\n, \nPolygon\n with the same interface.  For instance,\n\n\n1\n2\n3\nclass\n \nRectangle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n   \n// left as exercise (See Exercise 2)\n\n\n}\n\n\n\n\n\n\n\nSo far, we have been treating our shapes as pure geometric objects.  Let's consider an application where we want to paint the shapes.  Each shape should have a fill color and a border (with color and thickness).\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nimport\n \njava.awt.Color\n;\n\n    \n:\n\n\n\nclass\n \nPaintedCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n  \nprivate\n \nColor\n  \nborderColor\n;\n\n  \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n  \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n    \nfillColor\n \n=\n \nc\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n    \nborderThickness\n \n=\n \nt\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n    \nborderColor\n \n=\n \nc\n;\n\n  \n}\n\n\n  \n// other methods and fields for Circle from before\n\n\n\n}\n\n\n\n\n\n\n\nIn the code above, we added the line \nimport\n \njava.awt.Color\n to use the \nColor class\n that Java provides, and added three private members as well as their setters.\n\n\nWe can do the same for \nTriangle\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nimport\n \njava.awt.Color\n;\n\n    \n:\n\n\n\nclass\n \nPaintedTriangle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n  \nprivate\n \nColor\n  \nborderColor\n;\n\n  \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n  \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n    \nfillColor\n \n=\n \nc\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n    \nborderThickness\n \n=\n \nt\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n    \nborderColor\n \n=\n \nc\n;\n\n  \n}\n\n\n  \n// other methods and fields written for Triangle\n\n\n\n}\n\n\n\n\n\n\n\nand for other shapes.\n\n\nGreat!  We now have colorful shapes.  The code above, however, is not \ngood\n code, even though it is \ncorrect\n.  Just consider what needs to be done if we decide to support border styles (dotted border, solid border, dashed border, etc).  We would have to edit every single class that supports colors and borders!\n\n\nOne principle that we can follow is the \nabstraction principle\n, which says \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"\n3\n\n\nFollowing the principle, we want to implement these style-related fields and methods in just one place.  But where?\n\n\nInheritance\n\n\nThe OO-way to do this is to create a \nparent class\n, and put all common fields and methods into the parent.  A parent class is defined just like a normal class.  For instance:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass\n \nPaintedShape\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n  \nprivate\n \nColor\n  \nborderColor\n;\n\n  \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n  \npublic\n \nPaintedShape\n(\nColor\n \nfillColor\n,\n \nColor\n \nborderColor\n,\n \ndouble\n \nborderThickness\n)\n \n{\n\n    \nthis\n.\nfillColor\n \n=\n \nfillColor\n;\n\n    \nthis\n.\nborderColor\n \n=\n \nborderColor\n;\n\n    \nthis\n.\nborderThickness\n \n=\n \nborderThickness\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n    \nfillColor\n \n=\n \nc\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n    \nborderThickness\n \n=\n \nt\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n    \nborderColor\n \n=\n \nc\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe \nPaintedCircle\n class, \nPaintedSquare\n class, etc, can now \ninherits\n non-private fields and methods from the parent class, using the \nextends\n keyword.\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nPaintedCircle\n \nextends\n \nPaintedShape\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n      \n:\n\n\n}\n\n\n\nclass\n \nPaintedSquare\n \nextends\n \nPaintedShape\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n      \n:\n\n\n}\n\n\n\n\n\n\nThis mechanism for a class to inherit the properties and behavior from a parent is called \ninheritance\n, and is the fourth and final basic OO principles we cover\n4\n.\n\n\nWith inheritance, we do not have to repeat the declaration of fields \nfillColor\n, \nborderColor\n, \nborderThickness\n and the associated methods in them.  This software engineering principle is also known as the DRY principle -- \"\ndon't repeat yourself\n\" principle.  We are going to see DRY very regularly in future lectures.\n\n\nWe also call the \nPaintedShape\n the superclass (or base class) of \nPaintedCircle\n and \nPaintedSquare\n, and call \nPaintedCircle\n and \nPaintedSquare\n the subclass (or derived class)\n5\n of \nPaintedShape\n.\n\n\nA \nPaintedCircle\n object can now call \nfillWith()\n even if the method \nfillWith()\n is not defined in \nPaintedCircle\n -- it is defined in \nPaintedCircle\n's parent \nPaintedShape\n.  \n\n\nWhen a class extends a parent class, it inherits all the non-private fields and methods, so we can depict the objects and the class as follows:\n\n\n\n\nThe method table now includes pointers to methods defined in the parent (and grandparents, and so on).\n\n\nOverloading\n\n\nNow consider the constructor for \nPaintedCircle\n.   We need to initialize the geometric shape as well as the painting style.  But, we define the fields \nfillColor\n, etc \nprivate\n, and thus subclasses have no access to \nprivate\n fields in the parent.  We need to call the constructor of the parent to initialize these private fields.  The way to do this is to use the \nsuper\n keyword, as such:\n\n\n1\n2\n3\n4\n5\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ncenter\n,\n \ndouble\n \nradius\n,\n \nColor\n \nfillColor\n,\n \nColor\n \nborderColor\n,\n \ndouble\n \nborderThickness\n)\n \n{\n\n    \nsuper\n(\nfillColor\n,\n \nborderColor\n,\n \nborderThickness\n);\n\n    \nthis\n.\ncenter\n \n=\n \ncenter\n;\n\n    \nthis\n.\nradius\n \n=\n \nradius\n;\n\n  \n}\n\n\n\n\n\n\n\nYou can see that the constructor for \nPaintedCircle\n now takes in five parameters.  You can imagine that as the class gets more sophisticated with more fields, we need to pass in more parameters to the class to initialize the fields.  It is not uncommon to provide alternative constructors with fewer parameters and assign some \ndefault\n values to the fields.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n  \n// create circle with default style (white with black border of thickness 1)\n\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ncenter\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nsuper\n(\nColor\n.\nWHITE\n,\n \nColor\n.\nBLACK\n,\n \n1.0\n);\n\n    \nthis\n.\ncenter\n \n=\n \ncenter\n;\n\n    \nthis\n.\nradius\n \n=\n \nradius\n;\n\n  \n}\n\n\n  \n// create circle with customized styles  \n\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ncenter\n,\n \ndouble\n \nradius\n,\n \nColor\n \nfillColor\n,\n \nColor\n \nborderColor\n,\n \ndouble\n \nborderThickness\n)\n \n{\n\n    \nsuper\n(\nfillColor\n,\n \nborderColor\n,\n \nborderThickness\n);\n\n    \nthis\n.\ncenter\n \n=\n \ncenter\n;\n\n    \nthis\n.\nradius\n \n=\n \nradius\n;\n\n  \n}\n\n\n\n\n\n\n\nTwo methods in a class can have the same name and still co-exist peacefully together.  This is called \noverloading\n.  When a method is called, we look at the \nsignature\n of the method, which consists of (i) the name of the method, (ii) the number, order, and type of the arguments, to determine which method is called.  To be precise, the first sentence of this paragraph should read: Two methods in a class can have the same name and still co-exist peacefully together, as long as they have different signatures.  Note that the return type is not part of the method signature, so you cannot have two methods with the same name and same arguments but different return type.  \n\n\nEven though the example above shows overloading of the constructor, we can overload other methods as well.  \n\n\nExercise\n\n\n\n\n\n\nConsider what happen when we do the following:\n\n\n1\n2\n3\nCircle\n \nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nShape\n \nc1\n \n=\n \nc\n;\n\n\nPrintable\n \nc2\n \n=\n \nc\n;\n\n\n\n\n\n\n\nAre the following statements allowed?  Why do you think Java does not allow some of the following statements?\n\n\n1\n2\n3\n4\nc1.print();\nc2.print();\nc1.getArea();\nc2.getArea();\n\n\n\n\n\n\n\n\n\n\nWrite another class \nRectangle\n that implements these two interfaces.  You should make use of the class \nPoint\n that you implemented from Lecture 1's exercise.  Then write another class \nPaintedRectangle\n that implements the two interfaces and inherits from \nPaintedShape\n that implements the two interfaces and inherits from \nPaintedShape\n.  You can assume that the sides of the rectangles are parallel with the x- and y-axes (in other words, the sides are either horizontal or vertical).\n\n\n\n\n\n\n(i) Write an interface called \nShape3D\n that supports a method \ngetVolume\n.  Write a class called \nCuboid\n that implements \nShape3D\n and has three private \ndouble\n fields \nlength\n, \nheight\n, and \nbreadth\n.  \ngetVolume()\n should return the volume of the \nCuboid\n object.  The constructor for \nCuboid\n should allow the client to create a \nCuboid\n object by specifying the three fields \nlength\n, \nheight\n and \nbreadth\n.\n\n\n(ii) We can extend one interface from another as well.  Find out how, and write a new interface \nSolid3D\n that inherits from interface \nShape3D\n that supports a method \ngetDensity\n and \ngetMass\n.  \n\n\n(iii) Now, write a new class called \nSolidCuboid\n with an additional private \ndouble\n field \ndensity\n.  The implementation of \ngetDensity()\n should return this field while \ngetMass()\n should return the mass of the cuboid.  The \nSolidCuboid\n should call the constructor of \nCuboid\n via \nsuper\n and provides two constructors: one constructor allows the client to specify the density, and the other does not and just set the default density to 1.0.\n\n\n\n\n\n\nWrite a class \nRectangle\n that implements \nShape\n.  A \nRectangle\n class has two \ndouble\n fields, \nlength\n and \nwidth\n, and a public method \nsetSize(int length, int width)\n that allows the client to change its size.  \n\n\nNow, write a class \nSquare\n that inherits from \nRectangle\n.  A \nSquare\n has an additional constraint that \nlength\n must be the same as \nwidth\n.  How should \nSquare\n implement the \nsetSize(int length, int width)\n method?  Do you think \nSquare\n should inherit from \nRectangle\n?  Or should it be another way around?  Or maybe they should not inherit from each other?\n\n\n(Note: to implement the \ncontains\n method in \nShape\n, you need to also keep the position of the \nSquare\n (top left corner, for instance).  But, it is not important for this question)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRemember a function is just an abstraction over a set of instructions.\u00a0\n\u21a9\n\n\n\n\n\n\nIn biology, polymorphism means that an organism can have many different forms.\u00a0\n\u21a9\n\n\n\n\n\n\nThis principle is formulated by Benjamin C. Pierce in his book \nTypes and Programming Languages\n.\u00a0\n\u21a9\n\n\n\n\n\n\nThe other three is encapsulation, abstraction, and polymorphism.\u00a0\n\u21a9\n\n\n\n\n\n\nAgain, you see that computer scientist can be quite indecisive when it comes to the terminologies in OOP.\u00a0\n\u21a9",
            "title": "2. Interface, Inheritance & Polymorphism"
        },
        {
            "location": "/lec02/index.html#lecture-2-inheritance-polymorphism",
            "text": "",
            "title": "Lecture 2: Inheritance &amp; Polymorphism"
        },
        {
            "location": "/lec02/index.html#learning-objectives",
            "text": "After this lecture, students should:   be able to build a mental model for how objects and classes are represented in Java  understand the concepts of object-oriented programming, including interface, polymorphism, late binding, inheritance, method overloading, and the usage of these concepts in programming.  know the purpose and usage of Java keywords  implements ,  extends ,  super ,  this , and  @Override  understand Java concepts of arrays, enhanced  for  loop, and method signature.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec02/index.html#memory-model-for-objects",
            "text": "To help understand how classes and objects work, it is useful to visualize how they are stored in the memory.  We mentioned last week that data (e.g., fields) and code (e.g., methods) are stored in two different regions in the memory.  Since an object contains both fields and methods, where do we keep an object?  It turned out that different implementations of Java may store the objects differently, but here is one way that we will follow for CS2030:   In the figure above, there are two objects of the same class.  An object is referred to through its reference, which is a pointer to the memory location where the instance fields for the object is stored, along with a pointer to a  method table .  A method table stores a table of pointers to the methods, along with a table to the class fields.      As an example, consider the following class:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 class   A   { \n   private   int   x ; \n   static   public   int   y ; \n\n   public   void   foo ()   { \n     : \n   } \n\n   public   void   bar ()   { \n     : \n   } \n\n     :  }    If we have two instances of A,  a1  and  a2 , with  A.y = 1 ,  a1.x = 9 ,  a2.x = 40 , then the memory layout looks like:   Note that, we have only one copy of the  static  class field  y , regardless of how many instances of  A  we create.",
            "title": "Memory Model for Objects"
        },
        {
            "location": "/lec02/index.html#enforcing-abstraction-barrier-with-interface",
            "text": "Recall the concept of encapsulation. When we develop a large piece of software, it is important to hide the details on data representation and implementation, and only expose certain  public  methods for the users to use.  We can imagine that there is an abstraction barrier between the code that implements the internals of a class (called the  implementer ) and the code that uses the class (called the  client ) to achieve a higher level task.  We have seen that we use  private  to enforce data hiding -- to hide certain fields and methods from outside of the barrier.  Now, we are going to see how we can enforce that the right set of methods are defined, implemented, and used on both sides of the barrier.  The mechanism to do this is through defining an  interface  (aka a  protocol  as it is called in Objective-C or Swift).  An interface is like a contract between the implementer of a class and the client of a class.  If a class promises to implement an interface, then we are guaranteed that the methods defined in the interface are already implemented in the class.  Otherwise, the code would not compile.  In Java, we can define an interface using  interface  keyword:  1\n2\n3\n4\n5 interface   Shape   { \n   public   double   getArea (); \n   public   double   getPerimeter (); \n   public   boolean   contains ( Point   p );  }    The example interface  Shape  above contains only the declaration of the methods, not the implementation.    Now, let's see how the implementer would implement a class using the interface.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 import   java.lang.Math ;  class   Circle   implements   Shape   { \n   private   Point   center ; \n   private   double   radius ; \n\n   public   Circle ( Point   center ,   double   radius )   { \n     this . center   =   center ; \n     this . radius   =   radius ; \n   } \n\n   public   void   moveTo ( Point   p )   { \n     center   =   p ; \n   } \n\n   @Override \n   public   double   getArea ()   { \n     return   Math . PI   *   radius   *   radius ; \n   } \n\n   @Override \n   public   boolean   contains ( Point   p )   { \n     return   ( p . distance ( center )   <   radius ); \n   } \n\n   @Override \n   public   double   getPerimeter ()   { \n     return   Math . PI   *   2   *   radius ; \n   }  }    This is very similar to the code you saw in Lecture 1, except that in Line 2, we say  class   Circle   implements   Shape .  This line informs the compiler that the programmer intends to implement all the methods included in the interface  Shape  exactly as declared (in terms of names, the number of arguments, the types of arguments, returned type, and access modifier).  The rest of the class is the same, except that we renamed  getCircumference  with  getPerimeter , which is more general and applies to all shapes.  We also added  annotations  to our code by adding the line  @Override  before methods in  Circle  that implement the methods declared in  Shape .  This annotation is optional, but it informs the compiler of our intention and helps make the intention of the programmer clearer to others who read the code.   Java Annotation  Annotations are metadata that is not part of the code.  They do not affect execution.  They are useful to compilers and other software tools, as well as humans who read the code.  While we can similarly make the code more human-friendly with comments, an annotation is structured and so can be easily parsed by software.  You will see 1-2 more useful annotations in this module.    this  The  this  keyword in Java that refers to the current object.  In the example above, we use  this  to disambiguate the argument  center  and the field  center .  In general, it is a good practice to use  this  when referring the instance variable of the current object to make your intention clear.   Note that we can have other methods (such as  moveTo ) in the class beyond what is promised in the interface the class implements.  A class can implement more than one interface.   For instance, let's say that we have another interface called  Printable [^1] with a single method defined:  1\n2\n3 interface   Printable   { \n   public   void   print ();  }    The implementer of  Circle  wants to inform the clients that the method  void print()  is implemented, it can do the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   Circle   implements   Shape ,   Printable   { \n      : \n      : \n    @Override \n    public   void   print ()   { \n      System . out . printf ( \"radius: %f\\n\" ,   radius ); \n      System . out . printf ( \"center:\" ); \n      center . print (); \n    }  }    In the above, we call  print()  on the  Point  object as well.  How do we know that  Point  provides a  print()  method?  Well, we can read the implementation code of  Point , or we can agree with the implementer of  Point  that  Point  provides a  Printable  interface!    It is important to note that,  interface  provides a  syntactic  contract on the abstraction barrier, but it does not provide a  semantic  contract.  It does not, for instance, guarantee that  print()  actually prints something to the screen.  One could still implement interface  Printable  as follows:  1\n2\n3\n4\n5\n6\n7 class   Circle   implements   Shape ,   Printable   { \n      : \n      : \n    @Override \n    public   void   print ()   { \n    }  }    and the code still compiles!  Not all programming languages that support classes support interface.  C++, Javascript, and Python, for instance, do not support similar concepts.   Default Access Modifier for Interface  In the examples above, I explicitly specify the methods in the  Printable  and  Shape  interfaces as  public .  In Java, all methods in an interface are public by default, so the keywords  public  could be omitted.",
            "title": "Enforcing Abstraction Barrier with Interface"
        },
        {
            "location": "/lec02/index.html#interface-as-type",
            "text": "In Java, an interface is a type.  What this means is that:   We can declare a variable with an interface type, such as: 1    Shape   circle ;   \nor 1    Printable   circle ;   \nWe cannot, however, instantiate an object from an interface\nsince an interface is a \"template\", an \"abstraction\", and does not have an implementation.  For instance:   1\n2\n3\n4    // this is not OK \n   Printable   p   =   new   Printable (); \n   // this is OK \n   Printable   circle   =   new   Circle ( new   Point ( 0 ,   0 ),   10 );      Similarly, we can pass arguments of an interface type into a method, and the return type of a method can be an interface.    An object can be an instance of multiple types.  Recall that Java is a statically typed language. We associate a type with a variable.  We can assign a variable to an object if the object is an instance of the type of the variable.  For example, Line 4 above creates a new circle, which is an instance of three types:  Circle ,  Shape , and  Printable .  It is ok to assign this new circle to a variable of type  Printable .    We say that  Shape  and  Printable  are  supertypes  of  Circle , and  Circle  is a subtype of  Shape  and  Printable .",
            "title": "Interface as Type"
        },
        {
            "location": "/lec02/index.html#late-binding-and-polymorphism",
            "text": "We can now do something cool like this: 1\n2\n3\n4\n5\n6\n7    Printable []   objs ; \n     : \n     // initialize array objs \n   : \n   for   ( Printable   o :   objs )   { \n       o . print (); \n   }    Let's examine this code.  Line 1 declares an array of objects of type  Printable .  We skip over the code to initialize the content of the array for now, and\njump to Line 5-7, which is a  for  loop.  Line 5 declares a loop variable  o  of type  Printable  and loops through all objects in the array  objs , and Line 6 invokes the method  print  of  o .   Array and For Loops in Java  See Oracle's tutorial on  array  and  enhanced loop   The magic happens in Line 6:   First, since we know that any object in the array has the type  Printable , this means that they must implement the  Printable  interface and support the method  print() .    Second, we do not know, and we do not  need  to know which class an object is an instance of.  Third, we can actually have objects of completely unrelated classes in the same array. We can have objects of type  Circle , and objects of type  Point .  We can have objects of type  Factory , or objects of type  Student , or objects of type  Cushion .  As long as the objects implement the  Printable  interface, we can put them into the same array.  Fourth, at  run time , Java looks at the object  o , and determines its class, and invokes the right implementation of  print()  corresponding to the  o .  That is, if  o  is an instance of a class  Circle , then it will call  print()  method of  Circle ; if  o  is an instance of a class  Point , then it will call  print()  method of  Point , and so on.   To further appreciate the magic in Line 6, especially on last point above, consider how a function call is done in C.  In C, you cannot have two functions of the same name within the same scope, so if you call a function  print() , you know exactly which set of instructions will be called 1 .  So, the name  print  is bound to the corresponding set of instructions at compilation time.  This is called  static binding  or  early binding .\nTo have  print()  for different types, we need to name them differently to avoid naming conflicts: e.g.,  print_point() ,  print_circle() .  In a language with static binding, suppose you want to mix objects of different types\ntogether in an array, you need to do something like the following pseudocode: 1\n2\n3\n4\n5\n6\n7\n8\n9     for   each   object   in   the   array \n        if   object   is   a   point \n            print_point ( object ) \n        else   if   object   is   a   circle \n            print_circle ( object ) \n      else   if   object   is   a   square \n            print_square ( object ) \n            : \n            :    Not only is the code verbose and ugly, it would be cumbersome if you define a new compound data type that supports printing, since you would need to remember to add a new if-else condition to call for a corresponding print function.  In OO languages, you can have methods named  print()  implemented differently in different classes.  When we compile the code above, the compiler will have no way to know which implementation will be called.  The bindings of  print()  to the actual set of instructions will only be done at run time, after the object  o  is instantiated from a class.  This is known as  dynamic binding , or  late binding , or  dynamic dispatch .   If you understand how an object is represented internally, this is not so magical after all.  Referring to the figure above, the array  objs[]  contains an array of references to objects, the first one is a  Circle  object, and the following two are  Point  objects.  When  o.print()  is invoked, Java refers to the method table, which points to either the method table for  Circle  or for  Point , based on the class the object is an instance of.  This behavior, which is common to OO programming languages, is known as  polymorphism 2 .",
            "title": "Late Binding and Polymorphism"
        },
        {
            "location": "/lec02/index.html#the-abstraction-principle",
            "text": "With the interface  Shape , we can implement other classes, such as  Rectangle ,  Square ,  Polygon  with the same interface.  For instance,  1\n2\n3 class   Rectangle   implements   Shape ,   Printable   { \n    // left as exercise (See Exercise 2)  }    So far, we have been treating our shapes as pure geometric objects.  Let's consider an application where we want to paint the shapes.  Each shape should have a fill color and a border (with color and thickness).   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 import   java.awt.Color ; \n     :  class   PaintedCircle   implements   Shape ,   Printable   { \n   private   Color    fillColor ; \n   private   Color    borderColor ; \n   private   double   borderThickness ; \n\n   public   void   fillWith ( Color   c )   { \n     fillColor   =   c ; \n   } \n\n   public   void   setBorderThickness ( double   t )   { \n     borderThickness   =   t ; \n   } \n\n   public   void   setBorderColor ( Color   c )   { \n     borderColor   =   c ; \n   } \n\n   // other methods and fields for Circle from before  }    In the code above, we added the line  import   java.awt.Color  to use the  Color class  that Java provides, and added three private members as well as their setters.  We can do the same for  Triangle   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 import   java.awt.Color ; \n     :  class   PaintedTriangle   implements   Shape ,   Printable   { \n   private   Color    fillColor ; \n   private   Color    borderColor ; \n   private   double   borderThickness ; \n\n   public   void   fillWith ( Color   c )   { \n     fillColor   =   c ; \n   } \n\n   public   void   setBorderThickness ( double   t )   { \n     borderThickness   =   t ; \n   } \n\n   public   void   setBorderColor ( Color   c )   { \n     borderColor   =   c ; \n   } \n\n   // other methods and fields written for Triangle  }    and for other shapes.  Great!  We now have colorful shapes.  The code above, however, is not  good  code, even though it is  correct .  Just consider what needs to be done if we decide to support border styles (dotted border, solid border, dashed border, etc).  We would have to edit every single class that supports colors and borders!  One principle that we can follow is the  abstraction principle , which says \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" 3  Following the principle, we want to implement these style-related fields and methods in just one place.  But where?",
            "title": "The Abstraction Principle"
        },
        {
            "location": "/lec02/index.html#inheritance",
            "text": "The OO-way to do this is to create a  parent class , and put all common fields and methods into the parent.  A parent class is defined just like a normal class.  For instance:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 class   PaintedShape   { \n   private   Color    fillColor ; \n   private   Color    borderColor ; \n   private   double   borderThickness ; \n\n   public   PaintedShape ( Color   fillColor ,   Color   borderColor ,   double   borderThickness )   { \n     this . fillColor   =   fillColor ; \n     this . borderColor   =   borderColor ; \n     this . borderThickness   =   borderThickness ; \n   } \n\n   public   void   fillWith ( Color   c )   { \n     fillColor   =   c ; \n   } \n\n   public   void   setBorderThickness ( double   t )   { \n     borderThickness   =   t ; \n   } \n\n   public   void   setBorderColor ( Color   c )   { \n     borderColor   =   c ; \n   }  }    The  PaintedCircle  class,  PaintedSquare  class, etc, can now  inherits  non-private fields and methods from the parent class, using the  extends  keyword.  1\n2\n3\n4\n5\n6\n7 class   PaintedCircle   extends   PaintedShape   implements   Shape ,   Printable   { \n       :  }  class   PaintedSquare   extends   PaintedShape   implements   Shape ,   Printable   { \n       :  }    This mechanism for a class to inherit the properties and behavior from a parent is called  inheritance , and is the fourth and final basic OO principles we cover 4 .  With inheritance, we do not have to repeat the declaration of fields  fillColor ,  borderColor ,  borderThickness  and the associated methods in them.  This software engineering principle is also known as the DRY principle -- \" don't repeat yourself \" principle.  We are going to see DRY very regularly in future lectures.  We also call the  PaintedShape  the superclass (or base class) of  PaintedCircle  and  PaintedSquare , and call  PaintedCircle  and  PaintedSquare  the subclass (or derived class) 5  of  PaintedShape .  A  PaintedCircle  object can now call  fillWith()  even if the method  fillWith()  is not defined in  PaintedCircle  -- it is defined in  PaintedCircle 's parent  PaintedShape .    When a class extends a parent class, it inherits all the non-private fields and methods, so we can depict the objects and the class as follows:   The method table now includes pointers to methods defined in the parent (and grandparents, and so on).",
            "title": "Inheritance"
        },
        {
            "location": "/lec02/index.html#overloading",
            "text": "Now consider the constructor for  PaintedCircle .   We need to initialize the geometric shape as well as the painting style.  But, we define the fields  fillColor , etc  private , and thus subclasses have no access to  private  fields in the parent.  We need to call the constructor of the parent to initialize these private fields.  The way to do this is to use the  super  keyword, as such:  1\n2\n3\n4\n5    public   PaintedCircle ( Point   center ,   double   radius ,   Color   fillColor ,   Color   borderColor ,   double   borderThickness )   { \n     super ( fillColor ,   borderColor ,   borderThickness ); \n     this . center   =   center ; \n     this . radius   =   radius ; \n   }    You can see that the constructor for  PaintedCircle  now takes in five parameters.  You can imagine that as the class gets more sophisticated with more fields, we need to pass in more parameters to the class to initialize the fields.  It is not uncommon to provide alternative constructors with fewer parameters and assign some  default  values to the fields.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    // create circle with default style (white with black border of thickness 1) \n   public   PaintedCircle ( Point   center ,   double   radius )   { \n     super ( Color . WHITE ,   Color . BLACK ,   1.0 ); \n     this . center   =   center ; \n     this . radius   =   radius ; \n   } \n\n   // create circle with customized styles   \n   public   PaintedCircle ( Point   center ,   double   radius ,   Color   fillColor ,   Color   borderColor ,   double   borderThickness )   { \n     super ( fillColor ,   borderColor ,   borderThickness ); \n     this . center   =   center ; \n     this . radius   =   radius ; \n   }    Two methods in a class can have the same name and still co-exist peacefully together.  This is called  overloading .  When a method is called, we look at the  signature  of the method, which consists of (i) the name of the method, (ii) the number, order, and type of the arguments, to determine which method is called.  To be precise, the first sentence of this paragraph should read: Two methods in a class can have the same name and still co-exist peacefully together, as long as they have different signatures.  Note that the return type is not part of the method signature, so you cannot have two methods with the same name and same arguments but different return type.    Even though the example above shows overloading of the constructor, we can overload other methods as well.",
            "title": "Overloading"
        },
        {
            "location": "/lec02/index.html#exercise",
            "text": "Consider what happen when we do the following:  1\n2\n3 Circle   c   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Shape   c1   =   c ;  Printable   c2   =   c ;    Are the following statements allowed?  Why do you think Java does not allow some of the following statements?  1\n2\n3\n4 c1.print();\nc2.print();\nc1.getArea();\nc2.getArea();     Write another class  Rectangle  that implements these two interfaces.  You should make use of the class  Point  that you implemented from Lecture 1's exercise.  Then write another class  PaintedRectangle  that implements the two interfaces and inherits from  PaintedShape  that implements the two interfaces and inherits from  PaintedShape .  You can assume that the sides of the rectangles are parallel with the x- and y-axes (in other words, the sides are either horizontal or vertical).    (i) Write an interface called  Shape3D  that supports a method  getVolume .  Write a class called  Cuboid  that implements  Shape3D  and has three private  double  fields  length ,  height , and  breadth .   getVolume()  should return the volume of the  Cuboid  object.  The constructor for  Cuboid  should allow the client to create a  Cuboid  object by specifying the three fields  length ,  height  and  breadth .  (ii) We can extend one interface from another as well.  Find out how, and write a new interface  Solid3D  that inherits from interface  Shape3D  that supports a method  getDensity  and  getMass .    (iii) Now, write a new class called  SolidCuboid  with an additional private  double  field  density .  The implementation of  getDensity()  should return this field while  getMass()  should return the mass of the cuboid.  The  SolidCuboid  should call the constructor of  Cuboid  via  super  and provides two constructors: one constructor allows the client to specify the density, and the other does not and just set the default density to 1.0.    Write a class  Rectangle  that implements  Shape .  A  Rectangle  class has two  double  fields,  length  and  width , and a public method  setSize(int length, int width)  that allows the client to change its size.    Now, write a class  Square  that inherits from  Rectangle .  A  Square  has an additional constraint that  length  must be the same as  width .  How should  Square  implement the  setSize(int length, int width)  method?  Do you think  Square  should inherit from  Rectangle ?  Or should it be another way around?  Or maybe they should not inherit from each other?  (Note: to implement the  contains  method in  Shape , you need to also keep the position of the  Square  (top left corner, for instance).  But, it is not important for this question)        Remember a function is just an abstraction over a set of instructions.\u00a0 \u21a9    In biology, polymorphism means that an organism can have many different forms.\u00a0 \u21a9    This principle is formulated by Benjamin C. Pierce in his book  Types and Programming Languages .\u00a0 \u21a9    The other three is encapsulation, abstraction, and polymorphism.\u00a0 \u21a9    Again, you see that computer scientist can be quite indecisive when it comes to the terminologies in OOP.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec03/index.html",
            "text": "Lecture 3\n\n\nLearning Objectives\n\n\nAt the end of this lecture, students should\n\n\n\n\nbe familiar with the concept and power of method overriding\n\n\nunderstand how Java dispatches methods that have been overridden\n\n\nappreciate the usefulness of overriding \nequals\n and \ntoString\n in the \nObject\n class\n\n\nbe exposed to the \nString\n class and its associated methods, especially the \n+\n operator\n\n\nbe aware that inheritance can be easily abused and leads to bad code\n\n\nunderstand the differences between HAS-A and IS-A relationship\n\n\nbe able to use composition to model classes with HAS-A relationship\n\n\nbe able to use inheritance to model classes with IS-A relationship\n\n\nunderstand the Liskov Substitution Principle and thus be aware that not all IS-A relationship should be modeled with inheritance\n\n\nunderstand the purposes of the Java keyword \nfinal\n\n\n\n\nJava \nObject\n class\n\n\nIn Java, every class inherits from the \nclass \nObject\n implicitly.  The \nObject\n class defines many useful methods that are common to all objects.  The two useful ones are :\n\n\n\n\nequals(Object obj)\n, which checks if two objects are equal to each other, and\n\n\ntoString()\n, which returns a string representation of the object, and is a better way to print an object than the \nprint()\n method and \nPrintable\n interface we write.\n\n\n\n\nThe \nequals()\n method as implemented in \nObject\n, only compares if two object references refer to the same object.  In the Figure below, we show an array \ncircles\n with three \nCircle\n objects.  All three circles are centered at (0, 0) with radius 10.  They are created as follows:\n\n\n1\n2\n3\n4\n    \nCircle\n[]\n \ncircles\n \n=\n \nnew\n \nCircle\n[\n3\n];\n\n    \ncircles\n[\n0\n]\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n    \ncircles\n[\n1\n]\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n    \ncircles\n[\n2\n]\n \n=\n \ncircles\n[\n1\n];\n\n\n\n\n\n\n\nWhen you check \ncircles[0].equals(circles[1])\n, however, it returns \nfalse\n, because even though \ncircles[0]\n and \ncircles[1]\n are semantically the same, they refer to the two different objects.  Calling \ncircles[1].equals(circles[2])\n returns \ntrue\n, as they are referring to the same object.  \n\n\n\n\nWhat if you need a method that compares if two circles are \nsemantically\n the same?  You can implement your own method, say \nisTheSameCircle(Circle c)\n.  But, the \nequals()\n method is universal (all classes inherits this method) and is used by other classes for equality tests.  So, in most cases, we can implement a method called \nequals()\n with the same signature with the semantic that we want[^8].\n\n\nThat's right.  Even though we cannot have two methods with the same signature in the same class, we can have two methods with the same signature, one in the superclass (or the superclass's superclass, and so on), one in the subclass.  The method in the subclass will override the method in the superclass.  For example,\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n    \n:\n\n  \n@Override\n\n  \npublic\n \nboolean\n \nequals\n(\nObject\n \nobj\n)\n \n{\n\n    \nif\n \n(\nthis\n \n==\n \nobj\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nif\n \n(\nobj\n \ninstanceof\n \nCircle\n)\n \n{\n\n      \nCircle\n \ncircle\n \n=\n \n(\nCircle\n)\n \nobj\n;\n\n      \nreturn\n \n(\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n    \n}\n \nelse\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nLine 10 above compares if the two center points are equal, and the two radius values are equal.  So, we compare if the two circles are semantically the same.  The rest of this code requires some explanation:\n\n\n\n\nLine 3 uses the same \n@Override\n annotation that we have seen before -- we are telling the compilers that we are overriding a method in the superclass.\n\n\nLine 4 declares the method \nequals\n, and note that it has to have exactly the same signature as the \nequals()\n method we are overriding.  Even though we meant to compare two \nCircle\n objects, we cannot declare it as \npublic boolean equals(Circle circle)\n, since the signature is different and the compiler would complain.\n\n\nSince \nobj\n is of an \nObject\n type, we can actually pass in any object to compare with a \nCircle\n.  Line 5 checks if the comparison makes sense, by checking if \nobj\n is instantiated from a \nCircle\n class, using the \ninstanceof\n keyword.  If \nobj\n is not even a \nCircle\n object, then we simply return \nfalse\n.\n\n\nIf \nobj\n is an instance of \nCircle\n, we assign \nobj\n to a variable of type \nCircle\n and compare as in Line 10.\n\n\n\n\nFor the code above to work, we have to override the \nequals\n method of \nPoint\n as well.  That is left as an exercise\n1\n.\n\n\nOne final note: polymorphism works here as well.  If we have an object reference \nobj\n of type \nObject\n that refers to an instance of a \nCircle\n, calling \nobj.equals()\n will invoke the \nequals()\n method of \nCircle\n, not \nObject\n, just like the case of interfaces.\n\n\nRecall that when a class implements an interface, an instance of that class can take on the type of that interface.  Similarly, when a class inherits from a parent class, an instance of that class can take on the type of the parent class.  So, we can do the following:\n\n\n1\n2\nCircle\n \nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nObject\n \no\n \n=\n \nc\n;\n\n\n\n\n\n\n\nLine 2 assigns the circle object \nc\n to \no\n of type \nObject\n.  So, both \no\n and \nc\n are referring to the same objects.  Due to type checking at compile time, however, Java does not allow methods and fields in the subclass (e.g., \nCircle\n) that is not in the superclass (e.g., \nObject\n) to be called.  In this example, only the methods known to \nObject\n can be accessed by \no\n.\n\n\nNow, consider what would happen if we override the method \nequals()\n from the \nObject\n class.  \n\n\nThe method table will update the entry for \nequals()\n to point to the implementation provided by the \nCircle\n class, instead of the \nObject\n class.\n\n\n\n\nNow, consider what would happen if we \noverload\n the method \nequals()\n with one that takes in a \nCircle\n object.  I also throw in a couple of \nSystem.out.print()\n to help us figure out what is going on.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n    \n:\n\n  \n@Override\n\n  \npublic\n \nboolean\n \nequals\n(\nObject\n \nobj\n)\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"equals(Object) called\"\n);\n\n    \nif\n \n(\nobj\n \n==\n \nthis\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nif\n \n(\nobj\n \ninstanceof\n \nCircle\n)\n \n{\n\n      \nCircle\n \ncircle\n \n=\n \n(\nCircle\n)\n \nobj\n;\n\n      \nreturn\n \n(\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n    \n}\n \nelse\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nboolean\n \nequals\n(\nCircle\n \ncircle\n)\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"equals(Circle) called\"\n);\n\n    \nreturn\n \n((\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n  \n}\n \n\n}\n\n\n\n\n\n\n\nSince this new \nequals()\n method does not override the method in \nObject\n, it gets its own slot in the method table of \nCircle\n, instead of reusing one from the \nObject\n.\n\n\n\n\nNow, consider which version of \nequals\n are called by the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nCircle\n \nc1\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nCircle\n \nc2\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nObject\n \no1\n \n=\n \nc1\n;\n\n\nObject\n \no2\n \n=\n \nc2\n;\n\n\n\no1\n.\nequals\n(\no2\n);\n\n\no1\n.\nequals\n((\nCircle\n)\no2\n);\n\n\no1\n.\nequals\n(\nc2\n);\n\n\nc1\n.\nequals\n(\no2\n);\n\n\nc1\n.\nequals\n((\nCircle\n)\no2\n);\n\n\nc1\n.\nequals\n(\nc2\n);\n\n\n\n\n\n\n\nLines 6-9 call \nequals(Object)\n defined in \nCircle\n\uff0c while Lines 10-11 call \nequals(Circle)\n defined in \nCircle\n.  Let's look at why for each one:\n\n\n\n\nLine 6 calls \nequals\n of an \nObject\n object on an \nObject\n object.  Java checks through all methods defined in \nObject\n, and finds a method that matches the signature, which is the \nequals(Object)\n (which \nCircle\n has overridden). This is the one that will get called.\n\n\nLine 7-8 call \nequals\n of an \nObject\n object on a \nCircle\n object.  Java checks through all methods defined in \nObject\n and finds one method that matches the signature, which is \nequals(Object)\n (which \nCircle\n has overridden).  Even though there is another method \nequals(Circle)\n defined, it is defined as part of the \nCircle\n class, which Java refuses to access because \no1\n is declared to have the type \nObject\n.  Since the only method that Java can find has an argument of type \nObject\n, the argument is cast as an \nObject\n when \nequals\n is invoked.\n\n\nLine 9 calls \nequals\n of a \nCircle\n object on an \nObject\n object.  Java finds a method with the matching signature, \nequals(Object)\n, and invokes that.\n\n\nFinally, Lines 10-11 call \nequals\n of a \nCircle\n object on a \nCircle\n object.  Even though there are two overloaded methods which Java can call without type error, Java always invokes \nthe most specific method\n, in this case, \nequals(Circle)\n.\n\n\n\n\nWhy do we need to override \nequals\n in \nObject\n, rather than just using the \nCircle\n-specific \nequals(Circle)\n?  As shown above, only when an object declared as \nCircle\n calls \nequals\n on another \nCircle\n object, the \nCircle\n-specific \nequals(Circle)\n is invoked.\n\nTo write code that is general and reusable, we should exploit OO polymorphism, that means different subclasses of \nObject\n implement their own customized version of \nequals\n, and the right version of \nequals\n will be called.\n\n\nOne example of where this is called the \ncontains(Object)\n method from class \nArrayList\n (we will cover this later in class), which checks if an object is already in the list, and to check this, it checks for equality of the given object with every object in the \nArrayList\n, by calling \nequals(Object)\n.\n\n\ntoString\n\n\nWe now turn our attention to another method in \nObject\n that we could override, the \ntoString()\n method.  \ntoString()\n is called whenever the \nString\n representation of an object is needed.  For instance, when we try to print an object.   By default, the \ntoString\n of \nObject\n simply prints the name of the class, followed by \n@\n, followed by the reference.   It is often useful to override this to include the content of the object as well, for debugging and logging purposes.  This is a much more useful and flexible way than writing our own \nprint()\n method as we have seen in earlier lectures, since we are not limited to printing to standard output anymore.\n\n\n\n\njava.lang.String\n\n\nString\n is one of the many useful classes provided by Java.  You can skim through to see what methods are available and keep the \nAPI reference\n handy.\n\n\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nPoint\n \n{\n\n  \n:\n\n  \npublic\n \nString\n \ntoString\n()\n \n{\n\n    \nreturn\n \n\"(\"\n \n+\n \nx\n \n+\n \n\",\"\n \n+\n \ny\n \n\")\"\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNow, if we run:\n\n1\n2\nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\np\n);\n\n\n\n\n\n\nIt should print \n(0,0)\n instead of \nPoint\n@1235\nde\n.\n\n\nThe ability to override methods that you inherit from a parent, including root class \nObject\n, makes overriding an extremely powerful tool.  It allows you to change how existing libraries behave, and customize them to your classes, without changing a single line of their code or even accessing their code!\n\n\nAs Uncle Ben said, \"With great power, comes great responsibility.\"  We must use overriding and inheritance carefully.  Since we can affect how existing libraries behave, we can easily break existing code and introduce bugs.  Since you may not have access to these existing code, it is often tricky to trace and debug.  \n\n\n\n\nUsing \nsuper\n To Access Overridden Methods\n\n\nAfter a subclass overrides a method in the superclass, the methods have been overridden can still be called, with \nsuper\n keyword. \nFor instance, the following \ntoString\n implementation of \nPoint\n calls the \ntoString\n from \nObject\n, to prefix the string representation of Point with the class and reference address.\n\n1\n2\n3\n4\n@Override\n\n\npublic\n \nString\n \ntoString\n()\n \n{\n\n  \nreturn\n \nsuper\n.\ntoString\n()\n \n+\n \n\" (\"\n \n+\n \nx\n \n+\n \n\",\"\n \n+\n \ny\n \n+\n \n\")\"\n;\n\n\n}\n\n\n\n\n\n\n\n\nThe \nprotected\n and Default Access Modifiers\n\n\nIn the last lecture, when we inherit \nCircle\n from \nPaintedShape\n, we set the fields \nfillColor\n etc to \nprivate\n, to create an abstraction barrier between the superclass and its subclasses.  This barrier allows the implementor of the superclass to freely change the internal representation of the superclass without worrying about the effect on the subclasses.\n\n\nSometimes, the implementor of a superclass may choose to allow the subclasses to have access to some of its fields and methods, but yet prevent other classes from accessing them.  This type of access restriction can be achieved with the \nprotected\n access modifier. \n\n\n\n\nprotected\n in Other Languages\n\n\nC++ and C# both provide \nprotected\n keyword, allowing subclasses to access \nprotected\n fields and methods of the superclass.  Swift, however, decided that \ndeciding fields/methods access based on inheritance complicates things without bringing any advantage\n and does not provide the \nprotected\n access modifier.\n\n\n\n\nJava Packages\n\n\nSo far we have written several classes and interfaces (\nCircle\n, \nPoint\n, \nShape\n, \nPrintable\n, \nPaintedShape\n, \nSquare\n, etc).  We are using common names to name our classes and interfaces, and it is not inconceivable that in a large software project using external libraries that we will end up with multiple classes with the same name!  For instance, Java library provides a \nPoint\n class and a \nShape\n interface as well.  \n\n\nJava \npackage\n mechanism allows us to group relevant classes and interfaces together under a \nnamespace\n.  You have seen two packages so far: \njava.awt\n where we import the \nColor\n class from, and \njava.lang\n where we import the \nMath\n class from.  These are provided by Java as standard libraries.  We can also create our own package and put the classes and interfaces into the same package.  We (and the clients) can then import and use the classes and interfaces that we provide.  \n\n\nBesides providing namespace to disambiguate classes or interfaces with the same name, Java \npackage\n also provides another higher-layer of abstraction barrier.  In Java, a \nprotected\n field or method can be accessed by other classes in the same package.\n\n\nFinally, Java has the forth access modifier known as the default modifier.  This access modifier (or lack of it) is used when we do not specify \npublic\n, \nprotected\n, nor \nprivate\n.  A field or member with no access modifier is private to the package -- it is \npublic\n to all classes within the same package, but \nprivate\n to classes outside of the package.  The default access modifier is also known as \npackage-private\n by some.\n\n\nThe following table, taken from \nOracle's Java Tutorial\n\nsummarizes the access modifiers:\n\n\n\n\n\n\n\n\nAccess Modifier\n\n\nClass\n\n\nPackage\n\n\nSubclass\n\n\nWorld\n\n\n\n\n\n\n\n\n\n\npublic\n\n\nY\n\n\nY\n\n\nY\n\n\nY\n\n\n\n\n\n\nprotected\n\n\nY\n\n\nY\n\n\nY\n\n\nN\n\n\n\n\n\n\nno modifier\n\n\nY\n\n\nY\n\n\nN\n\n\nN\n\n\n\n\n\n\nprivate\n\n\nY\n\n\nN\n\n\nN\n\n\nN\n\n\n\n\n\n\n\n\nIn Java, every class belongs to a package, whether we like it or not.  If we do not declare that a class belongs to a package, then it belongs to the default package.\n\n\nWe will not be discussing \npackage\n much more than what we have done today.  You can learn more about packages via \nOracle's Java Tutorial\n.\n\n\nModeling HAS-A Relationship\n\n\nInheritance in OO tends to get overused.  \nIn practice, we seldom use inheritance\n.  Let's look at some examples of how \nnot\n to use inheritance, and why.\n\n\nYou may come across examples online or in books that look like the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nPoint\n \n{\n\n  \nprotected\n \ndouble\n \nx\n;\n\n  \nprotected\n \ndouble\n \ny\n;\n\n    \n:\n\n\n}\n\n\n\nclass\n \nCircle\n \nextends\n \nPoint\n \n{\n\n  \nprotected\n \ndouble\n \nradius\n;\n\n    \n:\n\n\n}\n\n\n\nclass\n \nCylinder\n \nextends\n \nCircle\n \n{\n\n  \nprotected\n \ndouble\n \nheight\n;\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nCircle\n implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius), and \nCylinder\n would have the fields corresponding to a circle, which is its base, and the height.  So, we are \nreusing\n the fields and the code related to initializing and manipulating the fields.\n\n\nWhen we start to consider methods encapsulated with each object, things start to get less intuitive.  What does \ngetPerimeter()\n and \ngetArea()\n of \nCylinder\n means?  How about \ndistanceTo\n between a \nCylinder\n and a \nPoint\n?   What is the meaning of a \nCircle\n containing a \nCylinder\n?\n\n\nThe inheritance hierarchy above actually models the HAS-A relationship: A circle has a center (which is a point), a cylinder has a base which is a circle.  Therefore, a better way to capture the relationship between the three types of objects is through \ncomposition\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nPoint\n \n{\n\n  \ndouble\n \nx\n;\n\n  \ndouble\n \ny\n;\n\n    \n:\n\n\n}\n\n\n\nclass\n \nCircle\n \n{\n\n  \nPoint\n \ncenter\n;\n\n  \ndouble\n \nradius\n;\n\n    \n:\n\n\n}\n\n\n\nclass\n \nCylinder\n \n{\n\n  \nCircle\n \nbase\n;\n\n  \ndouble\n \nheight\n;\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nComposition allows us to build more complex classes from simpler ones, and is usually favored over inheritance.  \n\n\nThe \nPaintedShape\n class from Lecture 2, for instance, could be modeled as a composition of a \nStyle\n object and \nShape\n object.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nStyle\n \n{\n\n  \nColor\n \nfillColor\n;\n\n  \nColor\n \nborderColor\n;\n\n    \n:\n\n\n}\n\n\n\nclass\n \nPaintedShape\n \n{\n\n  \nStyle\n \nstyle\n;\n\n  \nShape\n \nshape\n;\n\n    \n:\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \nshape\n.\ngetArea\n();\n\n  \n}\n\n  \n:\n\n  \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n    \nstyle\n.\nfillWith\n(\nc\n);\n\n  \n}\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThe design above is also known as the \nforwarding\n -- calls to methods on \nPaintedShape\n gets forwarded to either \nStyle\n or \nShape\n objects.\n\n\nModeling IS-A Relationship\n\n\nA better situation to use inheritance is to model a IS-A relationship: when the subclass behaves just like parent class, but has some additional behaviors.  For instance, it is natural to model a \nPaintedCircle\n as a subclass of \nCircle\n -- since a PaintedCircle has all the behavior of \nCircle\n, but has \nadditional\n behaviors related to being painted.\n\n\n1\n2\n3\n4\nclass\n \nPaintedCircle\n \nextends\n \nCircle\n \n{\n\n  \nStyle\n \nstyle\n;\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nA more tricky situation for modeling a IS-A relationship occurs when the subclass behaves just like the parent class \nmost\n of the time, but sometimes behave slightly differently than the parent.  Consider how we model a rectangle and a square.  Normally, we consider a square IS-A special case of a rectangle.  So, we could model as:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nRectangle\n \n{\n\n  \ndouble\n \nwidth\n,\n \nheight\n;\n\n  \nPoint\n \ntopLeft\n;\n\n  \nRectangle\n(\nPoint\n \ntopLeft\n,\n \nin\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n    \nthis\n.\ntopLeft\n \n=\n \ntopLeft\n;\n\n    \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n    \nthis\n.\nheight\n \n=\n \nheight\n;\n\n  \n}\n\n\n}\n\n\n\nclass\n \nSquare\n \nextends\n \nRectangle\n \n{\n\n  \nSquare\n(\nPoint\n \ntopLeft\n,\n \nint\n \nwidth\n)\n \n{\n\n      \nsuper\n(\ntopLeft\n,\n \nwidth\n,\n \nwidth\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nSo far, so good.\n\n\nNow, suppose the two classes are written by two different developers.  The developer who wrote Rectangle decided to add the method \nresizeTo\n:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nRectangle\n \n{\n\n      \n:\n\n    \nvoid\n \nsetSize\n(\nint\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n        \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n        \nthis\n.\nheight\n \n=\n \nheight\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis developer assumes the behavior that, after calling \nsetSize(w, h)\n, the width of the rectangle will be \nw\n and the height will be \nh\n.  He/she publishes this API, and another developer then assumes this behavior, and wrote some code, like:\n\n\n1\n2\n3\n4\nvoid\n \ndoSomething\n(\nRectangle\n \nr\n)\n \n{\n\n  \nr\n.\nsetSize\n(\n1\n,\n \n2\n);\n\n    \n:\n\n\n}\n\n\n\n\n\nWhat should the developer who develops \nSquare\n do?  Since \nSquare\n is a subclass of \nRectangle\n, it would inherit \nsetSize\n from its parent, but it does not make sense to call \nsetSize\n with two different parameters.  Sure, \nSquare\n can overload \nsetSize\n and provide a \nsetSize\n with one parameter only, but that does not prevent someone from calling \nsetSize\n with two parameters on a \nSquare\n.  Someone could do the following and the code would still compile and run, turning the square into a rectangle!\n\n\n1\n2\nSquare\n \ns\n \n=\n \nnew\n \nSquare\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\ns\n.\nsetSize\n(\n4\n,\n \n8\n);\n\n\n\n\n\n\n\nThe \nSquare\n developer can try to override \nsetSize\n, to ignore the second parameter:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass\n \nSquare\n \nextends\n \nRectangle\n \n{\n\n    \n:\n\n  \n@Override\n\n  \nvoid\n \nsetSize\n(\nint\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n    \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n    \nthis\n.\nheight\n \n=\n \nwidth\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThis makes more sense and would make everyone who uses \nSquare\n happy -- a square is always a square -- but it introduces an \ninconsistency\n in behavior and will most likely break another part of the code that the developer is totally unaware of.  The developer of \ndoSomething\n suddenly cannot assume that \nsetSize\n works as intended and documented.\n\n\nIt is a developer's responsibility that any inheritance with method overriding does not alter the behavior of existing code.  This brings us to the \nLiskov Substitution Principle\n (LSP), which says that: \"Let \n\\phi(x)\n\\phi(x)\n be a property provable about objects \nx\nx\n of type \nT\nT\n. Then \n\\phi(y)\n\\phi(y)\n should be true for objects \ny\ny\n of type \nS\nS\n where \nS\nS\n is a subtype of \nT\nT\n.\"   \n\n\nThis means that if \nS\nS\n is a subclass of \nT\nT\n, then an object of type \nT\nT\n can be replaced by an object of type \nS\nS\n without changing the desirable property of the program.\n\n\nIn the example above, this means that everywhere we can expect rectangles to be used, we can replace a rectangle with a square.  This was no longer true with the introduction of \nsetSize\n method.\n\n\nPreventing Inheritance and Method Overriding\n\n\nSometimes, it is useful for a developer to explicitly prevent a class to be inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs.  Both the two java classes you have seen, \njava.lang.Math\n and \njava.lang.String\n, cannot be inherited from.  In Java, we use the keyword \nfinal\n when declaring a class to tell Java that we ban this class from being inherited.\n\n\n1\n2\n3\nfinal\n \nclass\n \nCircle\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nAlternatively, we can allow inheritance, but still prevent a specific method from being overridden, by declaring a method as \nfinal\n.  Usually, we do this on methods that are critical for the correctness of the class.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nCircle\n \n{\n\n   \n:\n\n  \nfinal\n \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nfinal variable\n\n\nThe keyword \nfinal\n has another use.   When declaring a variable as \nfinal\n, just like\n    \nPI\n in \nMath\n, it prevents the variable from being modified.  In other words, the variable becomes constant.\n\n1\n    \npublic\n \nstatic\n \nfinal\n \ndouble\n \nPI\n   \n=\n \n3.141592653589793\n;\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\nIn the class \nPoint\n, add a new method \nequals\n that overrides the \nequals\n from \nObject\n, so that when calling \np.equals(q)\n on two \nPoint\n objects, the method return \ntrue\n if and only \np\n and \nq\n coincide (i.e., have the same coordinates).\n\n\n\n\n\n\nConsider the following classes: \nFormattedText\n adds formatting information to the text. We call \ntoggleUnderline()\n to add or remove underlines from the text. A \nURL\n \nis a\n \nFormattedText\n that is always underlined.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nFormattedText\n \n{\n\n  \npublic\n \nString\n \ntext\n;\n \n  \npublic\n \nboolean\n \nisUnderlined\n;\n\n  \npublic\n \nvoid\n \ntoggleUnderline\n()\n \n{\n \n    \nisUnderlined\n \n=\n \n(!\nisUnderlined\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nURL\n \nextends\n \nFormattedText\n \n{\n \n  \npublic\n \nURL\n()\n \n{\n \n    \nisUnderlined\n \n=\n \ntrue\n;\n\n  \n}\n\n  \npublic\n \nvoid\n \ntoggleUnderline\n()\n \n{\n \n    \n// do nothing\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nDoes it violate the Liskov Substitution Principle? Explain.\n\n\n\n\n\n\nConsider each of the code snippets below.  Will it result in a compilation or run time error?  If not, what will be printed? \n\n\n(a)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n(b)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\na\n \n=\n \nnew\n \nA\n();\n\n\na\n.\nf\n();\n\n\n\n\n\n\n(C)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nsuper\n.\nf\n();\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n(d)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nthis\n.\nf\n();\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n(e)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nint\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n    \nreturn\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n(f)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n(\nint\n \nx\n)\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n    \n// return x; <-- this line should not be here.\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nb\n.\nf\n(\n0\n);\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\na\n.\nf\n(\n0\n);\n\n\n\n\n\n\n(g)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(h)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nprivate\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(i)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(j)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\nA\n.\nf\n();\n\n\nB\n.\nf\n();\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(k)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n \n=\n \n0\n;\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\nx\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(l)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n \n=\n \n0\n;\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\nsuper\n.\nx\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(m)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nclass\n \nA\n \n{\n\n  \nprotected\n \nint\n \nx\n \n=\n \n0\n;\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\nx\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(n)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nA\n \n{\n\n  \nprotected\n \nint\n \nx\n \n=\n \n0\n;\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nint\n \nx\n \n=\n \n1\n;\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\nx\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n(o)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nA\n \n{\n\n  \nprotected\n \nint\n \nx\n \n=\n \n0\n;\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \npublic\n \nint\n \nx\n \n=\n \n1\n;\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\nsuper\n.\nx\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\nConsider each of the code snippets below.  Which will result in a compilation error?\n\n\n(a)\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \nx\n)\n \n{}\n\n  \npublic\n \nvoid\n \nf\n(\nboolean\n \ny\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n(b)\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \nx\n)\n \n{}\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \ny\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n(C)\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \nprivate\n \nvoid\n \nf\n(\nint\n \nx\n)\n \n{}\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \ny\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n(d)\n\n1\n2\n3\n4\n5\n6\nclass\n \nA\n \n{\n\n  \npublic\n \nint\n \nf\n(\nint\n \nx\n)\n \n{\n\n      \nreturn\n \nx\n;\n\n  \n}\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \ny\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n(e)\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n(\nint\n \nx\n,\n \nString\n \ns\n)\n \n{}\n\n  \npublic\n \nvoid\n \nf\n(\nString\n \ns\n,\n \nint\n \ny\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you override \nequals()\n you should generally override \nhashCode()\n as well, but let's leave that for another lesson on another day.\u00a0\n\u21a9",
            "title": "3. More on Inheritance"
        },
        {
            "location": "/lec03/index.html#lecture-3",
            "text": "",
            "title": "Lecture 3"
        },
        {
            "location": "/lec03/index.html#learning-objectives",
            "text": "At the end of this lecture, students should   be familiar with the concept and power of method overriding  understand how Java dispatches methods that have been overridden  appreciate the usefulness of overriding  equals  and  toString  in the  Object  class  be exposed to the  String  class and its associated methods, especially the  +  operator  be aware that inheritance can be easily abused and leads to bad code  understand the differences between HAS-A and IS-A relationship  be able to use composition to model classes with HAS-A relationship  be able to use inheritance to model classes with IS-A relationship  understand the Liskov Substitution Principle and thus be aware that not all IS-A relationship should be modeled with inheritance  understand the purposes of the Java keyword  final",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec03/index.html#java-object-class",
            "text": "In Java, every class inherits from the  class  Object  implicitly.  The  Object  class defines many useful methods that are common to all objects.  The two useful ones are :   equals(Object obj) , which checks if two objects are equal to each other, and  toString() , which returns a string representation of the object, and is a better way to print an object than the  print()  method and  Printable  interface we write.   The  equals()  method as implemented in  Object , only compares if two object references refer to the same object.  In the Figure below, we show an array  circles  with three  Circle  objects.  All three circles are centered at (0, 0) with radius 10.  They are created as follows:  1\n2\n3\n4      Circle []   circles   =   new   Circle [ 3 ]; \n     circles [ 0 ]   =   new   Circle ( new   Point ( 0 ,   0 ),   10 ); \n     circles [ 1 ]   =   new   Circle ( new   Point ( 0 ,   0 ),   10 ); \n     circles [ 2 ]   =   circles [ 1 ];    When you check  circles[0].equals(circles[1]) , however, it returns  false , because even though  circles[0]  and  circles[1]  are semantically the same, they refer to the two different objects.  Calling  circles[1].equals(circles[2])  returns  true , as they are referring to the same object.     What if you need a method that compares if two circles are  semantically  the same?  You can implement your own method, say  isTheSameCircle(Circle c) .  But, the  equals()  method is universal (all classes inherits this method) and is used by other classes for equality tests.  So, in most cases, we can implement a method called  equals()  with the same signature with the semantic that we want[^8].  That's right.  Even though we cannot have two methods with the same signature in the same class, we can have two methods with the same signature, one in the superclass (or the superclass's superclass, and so on), one in the subclass.  The method in the subclass will override the method in the superclass.  For example,   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   Circle   implements   Shape ,   Printable   { \n     : \n   @Override \n   public   boolean   equals ( Object   obj )   { \n     if   ( this   ==   obj )   { \n       return   true ; \n     } \n     if   ( obj   instanceof   Circle )   { \n       Circle   circle   =   ( Circle )   obj ; \n       return   ( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n     }   else   { \n       return   false ; \n     } \n   }  }    Line 10 above compares if the two center points are equal, and the two radius values are equal.  So, we compare if the two circles are semantically the same.  The rest of this code requires some explanation:   Line 3 uses the same  @Override  annotation that we have seen before -- we are telling the compilers that we are overriding a method in the superclass.  Line 4 declares the method  equals , and note that it has to have exactly the same signature as the  equals()  method we are overriding.  Even though we meant to compare two  Circle  objects, we cannot declare it as  public boolean equals(Circle circle) , since the signature is different and the compiler would complain.  Since  obj  is of an  Object  type, we can actually pass in any object to compare with a  Circle .  Line 5 checks if the comparison makes sense, by checking if  obj  is instantiated from a  Circle  class, using the  instanceof  keyword.  If  obj  is not even a  Circle  object, then we simply return  false .  If  obj  is an instance of  Circle , we assign  obj  to a variable of type  Circle  and compare as in Line 10.   For the code above to work, we have to override the  equals  method of  Point  as well.  That is left as an exercise 1 .  One final note: polymorphism works here as well.  If we have an object reference  obj  of type  Object  that refers to an instance of a  Circle , calling  obj.equals()  will invoke the  equals()  method of  Circle , not  Object , just like the case of interfaces.  Recall that when a class implements an interface, an instance of that class can take on the type of that interface.  Similarly, when a class inherits from a parent class, an instance of that class can take on the type of the parent class.  So, we can do the following:  1\n2 Circle   c   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Object   o   =   c ;    Line 2 assigns the circle object  c  to  o  of type  Object .  So, both  o  and  c  are referring to the same objects.  Due to type checking at compile time, however, Java does not allow methods and fields in the subclass (e.g.,  Circle ) that is not in the superclass (e.g.,  Object ) to be called.  In this example, only the methods known to  Object  can be accessed by  o .  Now, consider what would happen if we override the method  equals()  from the  Object  class.    The method table will update the entry for  equals()  to point to the implementation provided by the  Circle  class, instead of the  Object  class.   Now, consider what would happen if we  overload  the method  equals()  with one that takes in a  Circle  object.  I also throw in a couple of  System.out.print()  to help us figure out what is going on.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 class   Circle   implements   Shape ,   Printable   { \n     : \n   @Override \n   public   boolean   equals ( Object   obj )   { \n     System . out . println ( \"equals(Object) called\" ); \n     if   ( obj   ==   this )   { \n       return   true ; \n     } \n     if   ( obj   instanceof   Circle )   { \n       Circle   circle   =   ( Circle )   obj ; \n       return   ( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n     }   else   { \n       return   false ; \n     } \n   } \n\n   public   boolean   equals ( Circle   circle )   { \n     System . out . println ( \"equals(Circle) called\" ); \n     return   (( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n   }   }    Since this new  equals()  method does not override the method in  Object , it gets its own slot in the method table of  Circle , instead of reusing one from the  Object .   Now, consider which version of  equals  are called by the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 Circle   c1   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Circle   c2   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Object   o1   =   c1 ;  Object   o2   =   c2 ;  o1 . equals ( o2 );  o1 . equals (( Circle ) o2 );  o1 . equals ( c2 );  c1 . equals ( o2 );  c1 . equals (( Circle ) o2 );  c1 . equals ( c2 );    Lines 6-9 call  equals(Object)  defined in  Circle \uff0c while Lines 10-11 call  equals(Circle)  defined in  Circle .  Let's look at why for each one:   Line 6 calls  equals  of an  Object  object on an  Object  object.  Java checks through all methods defined in  Object , and finds a method that matches the signature, which is the  equals(Object)  (which  Circle  has overridden). This is the one that will get called.  Line 7-8 call  equals  of an  Object  object on a  Circle  object.  Java checks through all methods defined in  Object  and finds one method that matches the signature, which is  equals(Object)  (which  Circle  has overridden).  Even though there is another method  equals(Circle)  defined, it is defined as part of the  Circle  class, which Java refuses to access because  o1  is declared to have the type  Object .  Since the only method that Java can find has an argument of type  Object , the argument is cast as an  Object  when  equals  is invoked.  Line 9 calls  equals  of a  Circle  object on an  Object  object.  Java finds a method with the matching signature,  equals(Object) , and invokes that.  Finally, Lines 10-11 call  equals  of a  Circle  object on a  Circle  object.  Even though there are two overloaded methods which Java can call without type error, Java always invokes  the most specific method , in this case,  equals(Circle) .   Why do we need to override  equals  in  Object , rather than just using the  Circle -specific  equals(Circle) ?  As shown above, only when an object declared as  Circle  calls  equals  on another  Circle  object, the  Circle -specific  equals(Circle)  is invoked. \nTo write code that is general and reusable, we should exploit OO polymorphism, that means different subclasses of  Object  implement their own customized version of  equals , and the right version of  equals  will be called.  One example of where this is called the  contains(Object)  method from class  ArrayList  (we will cover this later in class), which checks if an object is already in the list, and to check this, it checks for equality of the given object with every object in the  ArrayList , by calling  equals(Object) .",
            "title": "Java Object class"
        },
        {
            "location": "/lec03/index.html#tostring",
            "text": "We now turn our attention to another method in  Object  that we could override, the  toString()  method.   toString()  is called whenever the  String  representation of an object is needed.  For instance, when we try to print an object.   By default, the  toString  of  Object  simply prints the name of the class, followed by  @ , followed by the reference.   It is often useful to override this to include the content of the object as well, for debugging and logging purposes.  This is a much more useful and flexible way than writing our own  print()  method as we have seen in earlier lectures, since we are not limited to printing to standard output anymore.   java.lang.String  String  is one of the many useful classes provided by Java.  You can skim through to see what methods are available and keep the  API reference  handy.   1\n2\n3\n4\n5\n6 class   Point   { \n   : \n   public   String   toString ()   { \n     return   \"(\"   +   x   +   \",\"   +   y   \")\" ; \n   }  }    Now, if we run: 1\n2 Point   p   =   new   Point ( 0 , 0 );  System . out . println ( p );    It should print  (0,0)  instead of  Point @1235 de .  The ability to override methods that you inherit from a parent, including root class  Object , makes overriding an extremely powerful tool.  It allows you to change how existing libraries behave, and customize them to your classes, without changing a single line of their code or even accessing their code!  As Uncle Ben said, \"With great power, comes great responsibility.\"  We must use overriding and inheritance carefully.  Since we can affect how existing libraries behave, we can easily break existing code and introduce bugs.  Since you may not have access to these existing code, it is often tricky to trace and debug.     Using  super  To Access Overridden Methods  After a subclass overrides a method in the superclass, the methods have been overridden can still be called, with  super  keyword. \nFor instance, the following  toString  implementation of  Point  calls the  toString  from  Object , to prefix the string representation of Point with the class and reference address. 1\n2\n3\n4 @Override  public   String   toString ()   { \n   return   super . toString ()   +   \" (\"   +   x   +   \",\"   +   y   +   \")\" ;  }",
            "title": "toString"
        },
        {
            "location": "/lec03/index.html#the-protected-and-default-access-modifiers",
            "text": "In the last lecture, when we inherit  Circle  from  PaintedShape , we set the fields  fillColor  etc to  private , to create an abstraction barrier between the superclass and its subclasses.  This barrier allows the implementor of the superclass to freely change the internal representation of the superclass without worrying about the effect on the subclasses.  Sometimes, the implementor of a superclass may choose to allow the subclasses to have access to some of its fields and methods, but yet prevent other classes from accessing them.  This type of access restriction can be achieved with the  protected  access modifier.    protected  in Other Languages  C++ and C# both provide  protected  keyword, allowing subclasses to access  protected  fields and methods of the superclass.  Swift, however, decided that  deciding fields/methods access based on inheritance complicates things without bringing any advantage  and does not provide the  protected  access modifier.",
            "title": "The protected and Default Access Modifiers"
        },
        {
            "location": "/lec03/index.html#java-packages",
            "text": "So far we have written several classes and interfaces ( Circle ,  Point ,  Shape ,  Printable ,  PaintedShape ,  Square , etc).  We are using common names to name our classes and interfaces, and it is not inconceivable that in a large software project using external libraries that we will end up with multiple classes with the same name!  For instance, Java library provides a  Point  class and a  Shape  interface as well.    Java  package  mechanism allows us to group relevant classes and interfaces together under a  namespace .  You have seen two packages so far:  java.awt  where we import the  Color  class from, and  java.lang  where we import the  Math  class from.  These are provided by Java as standard libraries.  We can also create our own package and put the classes and interfaces into the same package.  We (and the clients) can then import and use the classes and interfaces that we provide.    Besides providing namespace to disambiguate classes or interfaces with the same name, Java  package  also provides another higher-layer of abstraction barrier.  In Java, a  protected  field or method can be accessed by other classes in the same package.  Finally, Java has the forth access modifier known as the default modifier.  This access modifier (or lack of it) is used when we do not specify  public ,  protected , nor  private .  A field or member with no access modifier is private to the package -- it is  public  to all classes within the same package, but  private  to classes outside of the package.  The default access modifier is also known as  package-private  by some.  The following table, taken from  Oracle's Java Tutorial \nsummarizes the access modifiers:     Access Modifier  Class  Package  Subclass  World      public  Y  Y  Y  Y    protected  Y  Y  Y  N    no modifier  Y  Y  N  N    private  Y  N  N  N     In Java, every class belongs to a package, whether we like it or not.  If we do not declare that a class belongs to a package, then it belongs to the default package.  We will not be discussing  package  much more than what we have done today.  You can learn more about packages via  Oracle's Java Tutorial .",
            "title": "Java Packages"
        },
        {
            "location": "/lec03/index.html#modeling-has-a-relationship",
            "text": "Inheritance in OO tends to get overused.   In practice, we seldom use inheritance .  Let's look at some examples of how  not  to use inheritance, and why.  You may come across examples online or in books that look like the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   Point   { \n   protected   double   x ; \n   protected   double   y ; \n     :  }  class   Circle   extends   Point   { \n   protected   double   radius ; \n     :  }  class   Cylinder   extends   Circle   { \n   protected   double   height ; \n     :  }    Circle  implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius), and  Cylinder  would have the fields corresponding to a circle, which is its base, and the height.  So, we are  reusing  the fields and the code related to initializing and manipulating the fields.  When we start to consider methods encapsulated with each object, things start to get less intuitive.  What does  getPerimeter()  and  getArea()  of  Cylinder  means?  How about  distanceTo  between a  Cylinder  and a  Point ?   What is the meaning of a  Circle  containing a  Cylinder ?  The inheritance hierarchy above actually models the HAS-A relationship: A circle has a center (which is a point), a cylinder has a base which is a circle.  Therefore, a better way to capture the relationship between the three types of objects is through  composition :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   Point   { \n   double   x ; \n   double   y ; \n     :  }  class   Circle   { \n   Point   center ; \n   double   radius ; \n     :  }  class   Cylinder   { \n   Circle   base ; \n   double   height ; \n     :  }    Composition allows us to build more complex classes from simpler ones, and is usually favored over inheritance.    The  PaintedShape  class from Lecture 2, for instance, could be modeled as a composition of a  Style  object and  Shape  object.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Style   { \n   Color   fillColor ; \n   Color   borderColor ; \n     :  }  class   PaintedShape   { \n   Style   style ; \n   Shape   shape ; \n     : \n   public   double   getArea ()   { \n     return   shape . getArea (); \n   } \n   : \n   public   void   fillWith ( Color   c )   { \n     style . fillWith ( c ); \n   } \n     :  }    The design above is also known as the  forwarding  -- calls to methods on  PaintedShape  gets forwarded to either  Style  or  Shape  objects.",
            "title": "Modeling HAS-A Relationship"
        },
        {
            "location": "/lec03/index.html#modeling-is-a-relationship",
            "text": "A better situation to use inheritance is to model a IS-A relationship: when the subclass behaves just like parent class, but has some additional behaviors.  For instance, it is natural to model a  PaintedCircle  as a subclass of  Circle  -- since a PaintedCircle has all the behavior of  Circle , but has  additional  behaviors related to being painted.  1\n2\n3\n4 class   PaintedCircle   extends   Circle   { \n   Style   style ; \n     :  }    A more tricky situation for modeling a IS-A relationship occurs when the subclass behaves just like the parent class  most  of the time, but sometimes behave slightly differently than the parent.  Consider how we model a rectangle and a square.  Normally, we consider a square IS-A special case of a rectangle.  So, we could model as:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   Rectangle   { \n   double   width ,   height ; \n   Point   topLeft ; \n   Rectangle ( Point   topLeft ,   in   width ,   int   height )   { \n     this . topLeft   =   topLeft ; \n     this . width   =   width ; \n     this . height   =   height ; \n   }  }  class   Square   extends   Rectangle   { \n   Square ( Point   topLeft ,   int   width )   { \n       super ( topLeft ,   width ,   width ); \n   }  }    So far, so good.  Now, suppose the two classes are written by two different developers.  The developer who wrote Rectangle decided to add the method  resizeTo :  1\n2\n3\n4\n5\n6\n7 class   Rectangle   { \n       : \n     void   setSize ( int   width ,   int   height )   { \n         this . width   =   width ; \n         this . height   =   height ; \n     }  }    This developer assumes the behavior that, after calling  setSize(w, h) , the width of the rectangle will be  w  and the height will be  h .  He/she publishes this API, and another developer then assumes this behavior, and wrote some code, like:  1\n2\n3\n4 void   doSomething ( Rectangle   r )   { \n   r . setSize ( 1 ,   2 ); \n     :  }   \nWhat should the developer who develops  Square  do?  Since  Square  is a subclass of  Rectangle , it would inherit  setSize  from its parent, but it does not make sense to call  setSize  with two different parameters.  Sure,  Square  can overload  setSize  and provide a  setSize  with one parameter only, but that does not prevent someone from calling  setSize  with two parameters on a  Square .  Someone could do the following and the code would still compile and run, turning the square into a rectangle!  1\n2 Square   s   =   new   Square ( new   Point ( 0 , 0 ),   10 );  s . setSize ( 4 ,   8 );    The  Square  developer can try to override  setSize , to ignore the second parameter:  1\n2\n3\n4\n5\n6\n7\n8 class   Square   extends   Rectangle   { \n     : \n   @Override \n   void   setSize ( int   width ,   int   height )   { \n     this . width   =   width ; \n     this . height   =   width ; \n   }  }    This makes more sense and would make everyone who uses  Square  happy -- a square is always a square -- but it introduces an  inconsistency  in behavior and will most likely break another part of the code that the developer is totally unaware of.  The developer of  doSomething  suddenly cannot assume that  setSize  works as intended and documented.  It is a developer's responsibility that any inheritance with method overriding does not alter the behavior of existing code.  This brings us to the  Liskov Substitution Principle  (LSP), which says that: \"Let  \\phi(x) \\phi(x)  be a property provable about objects  x x  of type  T T . Then  \\phi(y) \\phi(y)  should be true for objects  y y  of type  S S  where  S S  is a subtype of  T T .\"     This means that if  S S  is a subclass of  T T , then an object of type  T T  can be replaced by an object of type  S S  without changing the desirable property of the program.  In the example above, this means that everywhere we can expect rectangles to be used, we can replace a rectangle with a square.  This was no longer true with the introduction of  setSize  method.",
            "title": "Modeling IS-A Relationship"
        },
        {
            "location": "/lec03/index.html#preventing-inheritance-and-method-overriding",
            "text": "Sometimes, it is useful for a developer to explicitly prevent a class to be inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs.  Both the two java classes you have seen,  java.lang.Math  and  java.lang.String , cannot be inherited from.  In Java, we use the keyword  final  when declaring a class to tell Java that we ban this class from being inherited.  1\n2\n3 final   class   Circle   { \n     :  }    Alternatively, we can allow inheritance, but still prevent a specific method from being overridden, by declaring a method as  final .  Usually, we do this on methods that are critical for the correctness of the class.  1\n2\n3\n4\n5\n6 class   Circle   { \n    : \n   final   public   boolean   contains ( Point   p )   { \n     : \n   }  }     final variable  The keyword  final  has another use.   When declaring a variable as  final , just like\n     PI  in  Math , it prevents the variable from being modified.  In other words, the variable becomes constant. 1      public   static   final   double   PI     =   3.141592653589793 ;",
            "title": "Preventing Inheritance and Method Overriding"
        },
        {
            "location": "/lec03/index.html#exercise",
            "text": "In the class  Point , add a new method  equals  that overrides the  equals  from  Object , so that when calling  p.equals(q)  on two  Point  objects, the method return  true  if and only  p  and  q  coincide (i.e., have the same coordinates).    Consider the following classes:  FormattedText  adds formatting information to the text. We call  toggleUnderline()  to add or remove underlines from the text. A  URL   is a   FormattedText  that is always underlined.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   FormattedText   { \n   public   String   text ;  \n   public   boolean   isUnderlined ; \n   public   void   toggleUnderline ()   {  \n     isUnderlined   =   (! isUnderlined ); \n   }  }  class   URL   extends   FormattedText   {  \n   public   URL ()   {  \n     isUnderlined   =   true ; \n   } \n   public   void   toggleUnderline ()   {  \n     // do nothing \n   }  }    Does it violate the Liskov Substitution Principle? Explain.    Consider each of the code snippets below.  Will it result in a compilation or run time error?  If not, what will be printed?   (a)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   {  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();    (b)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   A   { \n   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   void   f ()   { \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();  a   =   new   A ();  a . f ();    (C)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   void   f ()   { \n     super . f (); \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();    (d)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   void   f ()   { \n     this . f (); \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();    (e)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   int   f ()   { \n     System . out . println ( \"B f\" ); \n     return   0 ; \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();    (f)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   A   { \n   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   void   f ( int   x )   { \n     System . out . println ( \"B f\" ); \n     // return x; <-- this line should not be here. \n   }  }  B   b   =   new   B ();  b . f ();  b . f ( 0 );  A   a   =   b ;  a . f ();  a . f ( 0 );    (g)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   public   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();    (h)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   private   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();    (i)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   static   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();    (j)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   A   { \n   static   void   f ()   { \n     System . out . println ( \"A f\" ); \n   }  }  class   B   extends   A   { \n   static   void   f ()   { \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  A   a   =   b ;  A . f ();  B . f ();  a . f ();  b . f ();    (k)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 class   A   { \n   private   int   x   =   0 ;  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( x ); \n   }  }  B   b   =   new   B ();  b . f ();    (l)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 class   A   { \n   private   int   x   =   0 ;  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( super . x ); \n   }  }  B   b   =   new   B ();  b . f ();    (m)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 class   A   { \n   protected   int   x   =   0 ;  }  class   B   extends   A   { \n   public   void   f ()   { \n     System . out . println ( x ); \n   }  }  B   b   =   new   B ();  b . f ();    (n)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   A   { \n   protected   int   x   =   0 ;  }  class   B   extends   A   { \n   public   int   x   =   1 ; \n   public   void   f ()   { \n     System . out . println ( x ); \n   }  }  B   b   =   new   B ();  b . f ();    (o)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   A   { \n   protected   int   x   =   0 ;  }  class   B   extends   A   { \n   public   int   x   =   1 ; \n   public   void   f ()   { \n     System . out . println ( super . x ); \n   }  }  B   b   =   new   B ();  b . f ();      Consider each of the code snippets below.  Which will result in a compilation error?  (a) 1\n2\n3\n4 class   A   { \n   public   void   f ( int   x )   {} \n   public   void   f ( boolean   y )   {}  }    (b) 1\n2\n3\n4 class   A   { \n   public   void   f ( int   x )   {} \n   public   void   f ( int   y )   {}  }    (C) 1\n2\n3\n4 class   A   { \n   private   void   f ( int   x )   {} \n   public   void   f ( int   y )   {}  }    (d) 1\n2\n3\n4\n5\n6 class   A   { \n   public   int   f ( int   x )   { \n       return   x ; \n   } \n   public   void   f ( int   y )   {}  }    (e) 1\n2\n3\n4 class   A   { \n   public   void   f ( int   x ,   String   s )   {} \n   public   void   f ( String   s ,   int   y )   {}  }          If you override  equals()  you should generally override  hashCode()  as well, but let's leave that for another lesson on another day.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec04/index.html",
            "text": "Lecture 4: Types, Memory, Exception\n\n\nLearning Outcomes\n\n\nAfter this class, students should:\n\n\n\n\nunderstand the differences between compile time and run time\n\n\nunderstand the basic rules for type conversion in Java, including the differenes between narrowing conversion and widening conversion.\n\n\nunderstand the concept of subtyping in general and the subtype relations in Java\n\n\nunderstand what is type covariance and that Java arrays are covariance.\n\n\nunderstand when memory are allocated/deallocated from the heap vs. from the stack\n\n\nunderstand the concept of call stack in JVM\n\n\nunderstand how Java call by reference and call by value\n\n\nknow about the keywords \nnull\n, \ntry\n, \ncatch\n, \nfinally\n, \nthrow\n, and \nthrows\n.\n\n\nappreciate why exceptions is a useful way of handling errors\n\n\naware of the differences between errors, unchecked exception, and checked exception in Java\n\n\nbe able to trace through the control flow of \ntry\n/\ncatch\n/\nfinally\n block\n\n\nhow to generate an exception and create a new exception\n\n\nnot commit bad practices when using exceptions\n\n\n\n\njava\n and \njavac\n\n\nNow that we have gone through the basic concepts of OO programming, let's take a step away from OO for the moment and look at some other important features of Java.\n\n\nIn your \nLab 0\n, we showed you how to use \njavac\n to compile your Java program and \njava\n to execute your program.  \n\n\njavac\n is a \ncompiler\n. It reads in Java source files as a string, parses the string for syntax errors, and converts the Java code into an intermediate binary format called the \nbytecode\n.  Bytecode is an instruction set akin to hardware instructions but is typically executed by a software interpreter.\n\n\nThis behavior is different from what \ngcc\n does for C programs.  \ngcc\n produces native machine code, corresponding to hardware instructions.  As such, a C program your \ngcc\n produced on your home machine will not run on \nsunfire\n.  \n\n\nJava designers (led by James Gosling) wanted a language that can be compiled into a form that is platform and hardware independent, thus, they developed their own runtime environment called the Java Virtual Machine (JVM), which interprets and executes the bytecode, optimizes the execution, and manages the memory of Java programs.  Bytecode produced (the \n.class\n files) on one platform can run other platforms.\n\n\n\n\nOther Bytecode Languages\n\n\nMany other programming environments offer compilation to bytecode.  Python, for instance, compiles Python code into \n.pyc\n files, which contain Python bytecode.  Facebook's HHVM compiles PHP into bytecode.  Google's V8 compiles Javascript into bytecode too.\n\n\n\n\n\n\nOther JVM Languages\n\n\nWhile JVM was initially designed for Java, its popularity has led to the development of other languages that compile to JVM bytecode and run on JVM, such as Clojure, Groovy, Scala and Kotlin.  \n\n\n\n\n\n\nOther Java Compilers\n\n\nWhile we stick to the Java 9 compiler from Oracle for CS2030, there are other Java compilers: \necj\n is the Java compiler from Eclipse -- if you use Eclipse IDE, this is the default compiler.  \ngcj\n is the GNU Java Compiler (which has been removed from GCC 7 onwards).\n\n\n\n\nOnce you produce the \n.class\n files containing the bytecode corresponding to the code you have written, you can pass the bytecode to JVM for execution by invoking the \njava\n command.  This is when your code gets executed -- objects get created and stored in memory, methods get called, etc. \n\n\nCompile Time vs Run Time\n\n\nIt is important to understand the difference between the two stages, compile time (when we invoke \njavac\n) and run time (when we invoke \njava\n).\n\n\nDuring compile time, the compiler does not always know what value a variable will take, nor will it know the sequence of execution of the programs.  As such, the compiler opts to be conservative and only makes the decision on what it knows for sure.  We have encountered this before -- recall our discussion on late binding:\n\n1\n2\n3\n  \nfor\n \n(\nPrintable\n \no\n:\n \nobjs\n)\n \n{\n\n      \no\n.\nprint\n();\n\n  \n}\n\n\n\n\n\n\nThe compiler cannot always be sure what is the class of the object the variable \no\n will refer to during runtime, and thus, it cannot be sure which version of \nprint\n method will be executed.  \n\n\nIn another example, we have\n\n\n1\n2\n3\n  \nCircle\n \nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n  \nPrintable\n \nc2\n \n=\n \nc\n;\n\n  \nc2\n.\ngetArea\n();\n\n\n\n\n\n\n\nAt compile time, \nc2\n has a type \nPrintable\n, and we try to invoke \ngetArea\n which is a method available in \nCircle\n, not \nPrintable\n.  Even though if we trace through the three lines of code above, we (the humans) can be sure that \nc2\n is pointing to a \nCircle\n object and it is fine to call \ngetArea\n, the compiler has to be conservative as it is designed to work on arbitrarily complex programs with an unknown sequence of execution.  The compiler thus does not allow us to call \nc2.getArea()\n.\n\n\njshell\n\n\nIf we compile a program with \njavac\n and then execute it with \njava\n, we have two distinct phases.  An error reported by \njavac\n occurs during compilation and is a \ncompile time error\n.  An error reported by \njava\n occors during run time, and is a \nrun time error\n.  \n\n\nIf we \"play\" with our classes and with Java syntax using \njshell\n, however, the differences between compile time and run time error are blurred.  \njshell\n is an \"REPL\" tool, which stands for \"read-eval-print loop\", and it does exactly what the name says: it repeatedly reads in a Java statement, evaluates the statement, and prints out the result.  The reading step is analogous to compiling, while the evaluating and printing steps are analogous to running a program.  So, \njshell\n produces an error message, it could be due to an error triggered by either compile time or run time.\n\n\n1. Types\n\n\nThe above discussion brings us back to the topic of types.  Unlike C which is not type safe or  Python and Javascript which are weakly typed, Java belongs to a class of programming language which is statically typed and enforces type safety through a rich set of rules.  Understanding these rules and appreciating them is important to writing good and general Java programs, as well as picking up other statically and strongly typed programming languages.\n\n\nType Conversion\n\n\nSometimes a programmer knows better than the compiler the intention of the program.  In this case, it is useful for a programmer to override the compiler's decision.  One possible such override is to force the type of a variable to be something more appropriate, through \ntype casting\n.\n\n\nWe have seen type casting in action when we discussed about type safety (see \nLecture 1\n).  Recall that, in C, we can type cast two seemingly incompatible types to each other.  We have also seen it \nlast week\n when we cast an \nObject\n variable to a \nCircle\n when we discuss overriding of the \nequals()\n method.\n\n\nType casting is a form of type conversion, in particular, an \nexplicit type conversion\n. \n\n\nLet's talk about \nimplicit type conversion\n first.  Implicit conversion can happen in several contexts:\n\n\n\n\nAssignment, for instance, assigning a variable of type \nCircle\n to a variable of type `Shape.\n\n\nMethod invocation, for instance, when you pass a variable of type \nCircle\n to a method expecting \nShape\n.\n\n\nString conversion, when one of the operands of \n+\n is a \nString\n and the other is not, in which case it will be converted to \nString\n (by calling \ntoString()\n).\n\n\n\n\nSuppose we have a reference type \nS\nS\n and \nT\nT\n is a subtype of \nS\nS\n (denoted \nT <: S\nT <: S\n), then converting \nT\nT\n to \nS\nS\n is checked at compile time.  This conversion is known as \nwidening reference conversion\n.\n\n\nThe converse is not true.  If we want to convert \nS\nS\n to \nT\nT\n (known as \nnarrowing reference conversion\n), then we need explicit casting.  Such conversion is checked at run time, and it may cause an exception.  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nS\n \n{\n \n}\n\n\nclass\n \nT\n \nextends\n \nS\n \n{\n \n}\n\n\nclass\n \nU\n \nextends\n \nS\n \n{\n \n}\n \n\n\nS\n \ns1\n,\n \ns2\n;\n\n\nT\n \nt\n \n=\n \nnew\n \nT\n();\n\n\nU\n \nu\n \n=\n \nnew\n \nU\n();\n\n\n\ns1\n \n=\n \nt\n;\n  \n// always OK since this is a widening reference conversion.\n\n\ns2\n \n=\n \nu\n;\n  \n// always OK since this is a widening reference conversion.\n\n\nt\n  \n=\n \ns1\n;\n \n// not allowed since it is a narrowing reference conversion.\n\n\nt\n  \n=\n \n(\nT\n)\ns1\n;\n \n// explicit conversion allowed by compiler, no problem during run time.\n\n\nt\n  \n=\n \n(\nT\n)\ns2\n;\n \n// explicit conversion allowed by compiler, but cause run time error.\n\n\n\n\n\n\n\n\n\nJava subtyping and conversion specification\n\n\nWe are not going through all the gory details of Java subtyping and type conversion rules.  Chapter 5 of \nJava Language Specification\n succinctly and precisely defines all the rules on this topic.  For those students who are interested, you can check it out.  Otherwise, we will discover some of the other rules along the way as we learn more about Java in practice.\n\n\n\n\nSubtyping\n\n\nWe have seen how subtyping works in Java: we say that if a class \nT\nT\n extends from class \nS\nS\n or implements interface \nS\nS\n, \nT\nT\n is a subtype of \nS\nS\n.  The notion of subtyping, however, is more general than that.  In the study of programming languages, we say that \nT\nT\n is a subtype of \nS\nS\n if a piece of code written for variables of type \nS\nS\n can also safely be used on variables of type \nT\nT\n.   In the context of Java and other OO languages, inheritance and implementation of interfaces satisfy these conditions.  In other languages, however, we can create subtypes without these OO notions.  In Ada, for instance, we can create a subtype by restricting the range of values of a type.  E.g., we can create a subtype \ndigit\n from the type \nint\n, restricting its value to ranging between 0 and 9.\n\n\nWith this more general notion of subtyping, we can define subtype relations between the primitive types, as follows:\n\n\nbyte\n \n<:\n<:\n \nshort\n \n<:\n<:\n \nint\n \n<:\n<:\n \nlong\n \n<:\n<:\n \nfloat\n \n<:\n<:\n \ndouble\n; and \nchar\n \n<:\n<:\n \nint\n\n\nWe can also extend the notion of widening conversion and narrowing conversion to primitive types.\n\n\nVariance of Types\n\n\nGiven a type \nT\nT\n, we can create other complex types that depend on \nT\nT\n.  For instance, we can have an array of type \nT\nT\n, a generic class parameterized by \nT\nT\n (next lecture), a method that takes in \nT\nT\n and returns \nT\nT\n, etc.\n\n\nThe term \nvariance of types\n refers to how these more complex types relate to each other, given the relationship between the simpler types.\n\n\nSuppose \nA(T)\nA(T)\n is the complex type constructed from \nT\nT\n.  Then we say that \n\n\n\n\nA\nA\n is \ncovariant\n if \nT <: S\nT <: S\n implies \nA(T) <: A(S)\nA(T) <: A(S)\n, \n\n\nA\nA\n is \ncontravariant\n if \nT <: S\nT <: S\n implies \nA(S) <: A(T)\nA(S) <: A(T)\n,\n\n\nA\nA\n is \nbivariant\n if it is both covariant and contravariant, and\n\n\nA\nA\n is \ninvariant\n if it is neither covariant nor contravariant.\n\n\n\n\nFor example, in Java, arrays (of reference type) are covariant.  This means that, \nT[]\n is a subtype of \nS[]\n, if \nT\n is a subtype of \nS\n.  Based on the type conversion rule, it is OK to assign any array of reference type to an array of \nObject\n objects, or pass an array of reference type to a method that expects an array of \nObject\n objects.  This decision (of making Java arrays covariant) makes it possible to write very generic method that operates on array, as provided by the Java utility class \nArrays\n.\n1\n\n\nWe will see examples of complex type \nA\nA\n that is invariant and contravariant later in this module.\n\n\n2. Heap and Stack\n\n\nAs mentioned earlier, JVM manages memory of Java programs while its bytecode instructions are interpreted and executed.  Different JVM implementation may implement these differently, but typically a JVM implementation partitions the memory into several regions, including\n- \nmethod area\n for storing the code for the methods;\n- \nmetaspace\n for storing meta information about classes;\n- \nheap\n for storing dynamically allocated objects;\n- \nstack\n for local variables and call frames.\n\n\nSince the concepts of heap and stack are common to all execution environments (either based on bytecode or machine code), we will focus on them here.\n\n\nThe \nheap\n is the region in memory where all objects are allocated in and stored, while the \nstack\n is the region where all variables (including primitive types and object references) are allocated in and stored.\n\n\nConsiders the following two lines of code.\n\n1\n2\nCircle\n \nc\n;\n\n\nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n8\n);\n\n\n\n\n\nLine 1 declares a variable \nc\n.  When Java executes this line of code, it allocates some memory space for an object reference for \nc\n, the content is initialized to \nnull\n.  Since \nc\n is a variable, it resides in the stack.\n\n\n\n\nnull\n in Java\n\n\nnull\n is a special value for the object reference, that signifies that this reference is not pointing to any object.  This is similar to the \nnull\n in Javascript, \nNULL\n macro in C, \nnullptr\n in C++11, \nNone\n in Python, \nnil\n in Objective-C.  (Again, you see here computer scientists just can't agree on names!)  \nSir Tony Hoare\n (who also invented quicksort) famously apologized for inventing the null pointer.  He calls it his billion-dollar mistake.\n\n\n\n\nLine 2 creates a new Circle object.  When Java executes this line of code, it allocates some memory space for a \nCircle\n object on the heap.  The memory address of this memory space becomes the reference of the object and is assigned to the variable \nc\n.\n\n\nThis is shown in the figure below\n2\n.\n\n\n\n\nThe first argument to \nCircle\n constructor is also an object, so to be more precise, when Line 2 above is executed, a \nPoint\n object is also created and allocated on the heap.  So the field \nc\n inside \nCircle\n is actually a reference to this object.\n\n\n\n\nNow, let's look at a slightly different example.\n\n\n1\n2\n3\n4\n5\n6\nCircle\n \nc\n;\n\n\nPoint\n \ncenter\n;\n\n\ndouble\n \nradius\n;\n\n\nradius\n \n=\n \n8\n;\n\n\ncenter\n \n=\n \nnew\n \nPoint\n(\n1\n,\n \n1\n);\n\n\nc\n \n=\n \nnew\n \nCircle\n(\ncenter\n,\n \nradius\n);\n\n\n\n\n\n\nIn the second example, we have three variables, \nc\n, \ncenter\n, and \nradius\n .  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Recall that for object references, they are initialized to \nnull\n.  Primitive type variables (e.g., \nradius\n) are initialized to 0.\n\n\n\n\nAfter Lines 4-6, we have:\n\n\n\n\nCall Stack\n\n\nNow, let's look at what happens when we invoke a method.  Take the \ndistanceTo\n method in \nPoint\n as an example:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nPoint\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n\n  \nprivate\n \ndouble\n \ny\n;\n\n  \npublic\n \ndouble\n \ndistanceTo\n(\nPoint\n \nq\n)\n \n{\n\n    \nreturn\n \nMath\n.\nsqrt\n((\nq\n.\nx\n \n-\n \nthis\n.\nx\n)*(\nq\n.\nx\n \n-\n \nthis\n.\nx\n)+(\nq\n.\ny\n \n-\n \nthis\n.\ny\n)*(\nq\n.\ny\n \n-\n \nthis\n.\ny\n));\n\n  \n}\n\n\n}\n\n\n\n\n\nand the invocation:\n\n1\n2\n3\nPoint\n \np1\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\nPoint\n \np2\n \n=\n \nnew\n \nPoint\n(\n1\n,\n1\n);\n\n\np1\n.\ndistanceTo\n(\np2\n);\n\n\n\n\n\n\nAfter declaring \np1\n and \np2\n and creating both objects, we have:\n\n\n\nWhen \ndistanceTo\n is called, JVM creates a \nstack frame\n for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the \nthis\n reference, (ii) the method arguments, and (iii) local variables within the method, among other things\n3\n4\n.  When a class method is called, the stack frame does not contain the \nthis\n reference.\n\n\n\n\nYou can see that the \nreferences\n to the objects \np1\n and \np2\n are copied onto the stack frame. \np1\n and \nthis\n point to the same object, and \np2\n and \nq\n point to the same object.\nWithin the method, any modification done to \nthis\n would change the object referenced to by \np1\n, and any change made to \nq\n would change the object referenced to by \np2\n as well.\nAfter the method returns, the stack frame for that method is destroyed.\n\n\nLet's call the \nmove\n function from your \nLab 0\n, with arguments \n(double theta, double d)\n.\n\n\n1\n2\n3\ndouble\n \ntheta\n \n=\n \nMath\n.\nPI\n/\n4.0\n;\n\n\ndouble\n \ndistance\n \n=\n \n1\n;\n\n\np2\n.\nmove\n(\ntheta\n,\n \ndistance\n);\n\n\n\n\n\n\n\nAgain, we create a stack frame, copy the reference to object \np2\n into \nthis\n, copy \ntheta\n from the calling function to \ntheta\n the argument within the method, copy \ndistance\n from the calling function to \nd\n the argument within the method.  Recall that, in this function, you actually change the \nx\n and \ny\n of \nthis\n to move \np2\n.  \n\n\n\n\nWhat is important here is that, as \ntheta\n and \ndistance\n are primitive types instead of references, we copy the values onto the stack.  If we change \ntheta\n or \nd\n within \nmove\n, the \ntheta\n and \ndistance\n of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass in a variable of primitive type into a method and have its value changed, you will have to use a \nwrapper class\n.  The details of how to do this are left as an exercise.\n\n\nTo summarize, Java uses \ncall by value\n for primitive types, and \ncall by reference\n for objects.\n\n\nIf we made multiple nested method calls, as we usually do, the stack frames get stacked on top of each other.  For instance, in Lab 0, \nmain\n calls \nsolve\n, which calls the \nCircle\n constructor, which calls the \nangleTo\n.  When JVM is executing \nangleTo\n, the call stack contains the stack frames of (in order of top to bottom): \nangleTo\n, \nCircle\n constructor, \nsolve\n, and \nmain\n.\n\n\nOne final note: the memory allocated on the stack are deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a \ngarbage collector\n  that checks for unreferenced objects on the heap and cleans up the memory automatically.\n\n\n3. Exceptions\n\n\nOne of the nuances of programming is having to write code to deal with exceptions and errors.  Consider writing a method that reads in a series of x and y coordinates from a file, not unlike what you have seen in Lab 0.  Here are some things that could go wrong:\n\n\n\n\nThe file to read from may not exist\n\n\nThe file to read from exists, but you may not have permission to read it\n\n\nYou can open the file for reading, but it might contain non-numeric text where you numerical values\n\n\nThe file might contain fewer values than expected\n\n\nThe file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive)\n\n\n\n\nIn C, we usually have to write code like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nfd\n \n=\n \nfopen\n(\nfilename\n,\n\"r\"\n);\n\n\nif\n \n(\nfd\n \n==\n \nNULL\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"Unable to open file. \"\n);\n\n  \nif\n \n(\nerrno\n \n==\n \nENFILE\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"Too many opened files.  Unable to open another\n\\n\n\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nerrno\n \n==\n \nENOENT\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"No such file %s\n\\n\n\"\n,\n \nfilename\n);\n\n  \n}\n \nelse\n \nif\n \n(\nerrno\n \n==\n \nEACCES\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"No read permission to %s\n\\n\n\"\n,\n \nfilename\n);\n\n  \n}\n\n  \nreturn\n \n-\n1\n;\n\n\n}\n\n\nscanned\n \n=\n \nfscanf\n(\nfd\n,\n \n\"%d\"\n,\n \n&\nnum_of_points\n);\n\n\nif\n \n(\nscanned\n \n==\n \n0\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"Unable to scan for an integer\n\\n\n\"\n);\n\n  \nfclose\n(\nfd\n);\n\n  \nreturn\n \n-\n2\n;\n\n\n}\n\n\nif\n \n(\nscanned\n \n==\n \nEOF\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"No input found.\n\\n\n\"\n);\n\n  \nfclose\n(\nfd\n);\n\n  \nreturn\n \n-\n3\n;\n\n\n}\n\n\n\n\n\n\n\nOut of the lines above, only 2 lines correspond to the actual tasks, the others are for exception checking/handling.  How uncool is that?  Furthermore, the actual tasks are interspersed between exception checking code, making reading and understanding the logic of the code difficult.\n\n\nThe examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors.  Note that the POSIX APIs has a global variable \nerrno\n that signifies the detailed error.  First, we have to check for different \nerrno\n values and react accordingly (we can use \nperror\n, but that has its limits).  Second, \nerrno\n is global and we know that using global variable is bad practice.  In fact, I am not even sure that code above works because \nfprintf\n in Line 3 might have changed \nerrno\n!\n\n\nThen, there is the issue of having to repeatedly clean up after an error -- here we \nfclose\n the file if there is an error reading, twice.  It is easy to forget to do so if we have to do this in multiple places.   Furthermore, if we need to perform more complex clean up, then we would end up with lots of repeated code.\n\n\nFortunately, Java supports \ntry\n/\ncatch\n/\nfinally\n control statements, which is a way to group statements that check/handle errors together making code easier to read.  The Java equivalent to the above is:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\ntry\n \n{\n\n  \nreader\n \n=\n \nnew\n \nFileReader\n(\nfilename\n);\n\n  \nscanner\n \n=\n \nnew\n \nScanner\n(\nreader\n);\n\n  \nnumOfPoints\n \n=\n \nscanner\n.\nnextInt\n();\n\n\n}\n\n\ncatch\n \n(\nFileNotFoundException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"Unable to open \"\n \n+\n \nfilename\n \n+\n \n\" \"\n \n+\n \ne\n);\n\n\n}\n\n\ncatch\n \n(\nInputMismatchException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"Unable to scan for an integer\"\n);\n\n\n}\n\n\ncatch\n \n(\nNoSuchElementException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"No input found\"\n);\n\n\n}\n\n\nfinally\n \n{\n\n  \nif\n \n(\nscanner\n \n!=\n \nnull\n)\n\n    \nscanner\n.\nclose\n();\n\n\n}\n\n\n\n\n\n\n\nHere Lines 2-4 keep the basic tasks together, and all the clean up tasks are grouped together in Lines 18-19.  Lines 8-16 handle the exceptions.  We no longer rely on a global variable to convey the type of exceptions, or special return value to indicate exceptions.   What if we want the calling method to handle the exception?  Then, we simply do not do anything (i.e., do not catch the exception) and let the exception propagates to the calling method automatically.\n\n\n\n\nError vs. Exception in Java\n\n\nWe have been using the term error and exception loosely.  Java has different classes for \nError\n and \nException\n.  \nError\n is for situations where the program should terminate as generally there is no way to recover.  For instance, when the heap is full (\nOutOfMemoryError\n) or the stack is full (\nStackOverflowError\n).  Exceptions are for situations where it is still possible to reasonably recover from the error.\n\n\n\n\n\n\nCombining Multiple Catches\n\n\nIn cases where the code to handle the exceptions is the same, you can\n\n1\n2\n3\ncatch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n    System.err.println(e);\n}\n\n\n\n\n\n\n\nHere is a more detailed description of the control flow of exceptions.  Consider we have a \ntry\n-\ncatch\n-\nfinally\n block that catches two exceptions \nE1\n and \nE2\n.  Inside the \ntry\n block, we call a method \nm1()\n; \nm1()\n calls \nm2()\n; \nm2()\n calls \nm3()\n, and \nm3()\n calls \nm4()\n.   In a normal (no exception) situation, the control flow looks like this:\n\n\n\n\nThe statements in \ntry\n block are executed, followed by the statements in \nfinally\n block.\n\n\nNow, let's suppose something went wrong deep inside the nested call, in \nm4()\n.  One of the statement executes \nthrow new E2();\n, which causes the execution in \nm4()\n to stop.  JVM now looks for the block of code that catches \nE2\n, going down the call stack, until it can find a place where the exception is handled.  In this example, we suppose that none of \nm1()\n-\nm4()\n handles (i.e., \ncatch\n) the exception.  Thus, JVM then jumps to the code that handles \nE2\n.  Finally, JVM executes the \nfinally\n block.\n\n\nNote that the \nfinally\n block is always executed even when \nreturn\n or \nthrow\n is called in a \ncatch\n block.\n\n\n\n\nChecked Exceptions\n\n\nThere are two types of exceptions in Java: \nchecked\n and \nunchecked\n exceptions:\n\n\n\n\nA checked exception is something that the programmer should anticipate and handle.  For instance, when you open a file, you should anticipate that in some cases, the file cannot be open.   \n\n\nAn unchecked exception is something that the programmer does not anticipate, and usually is a result of a bug.  For example, when you try to call \np.distanceTo(q)\n but \np\n is \nnull\n, \nNullPointerException\n will be thrown.  \n\n\n\n\nWe need to either catch all checked exceptions or let it propagate to the calling method\n.  Otherwise, the program will not compile.  \n\n\nFor unchecked exceptions, even though we could catch it, it makes more sense to eliminate the bugs.  In Java, unchecked exceptions are subclasses of \nRuntimeException\n.  All \nError\ns are unchecked.\n\n\nAll methods that throw checked exception need to \nspecify\n the checked exception(s).  For example, if we want to put the code to open a file and read an \nint\n from it into a function, and want the calling function to deal with the exception, this is what we should do:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\npublic\n \nstatic\n \nint\n \nreadIntFromFile\n(\nString\n \nfilename\n)\n\n  \nthrows\n \nFileNotFoundException\n \n{\n\n  \nFileReader\n \nreader\n \n=\n \nnew\n \nFileReader\n(\nfilename\n);\n\n  \nScanner\n \nscanner\n \n=\n \nnew\n \nScanner\n(\nreader\n);\n\n  \nint\n \nnumOfPoints\n \n=\n \nscanner\n.\nnextInt\n();\n    \n  \nscanner\n.\nclose\n();\n\n  \nreturn\n \nnumOfPoints\n;\n\n\n}\n\n\n\n\n\n\n\nNote Line 2 specify that this method might throw \nFileNotFoundException\n.  \n\n\nA checked exception must be either caught or thrown to calling function, except \nmain\n, which has no calling function to throw to.  If \nmain\n does not catch a checked exception, the program exits, and the exception is revealed to the user -- this is generally considered a bad programming practice.\n\n\nThe two other exceptions from the examples above \nInputMismatchException\n and \nNoSuchElementException\n are subclasses of \nRuntimeException\n, and therefore are unchecked.\n\n\nGenerating Exception\n\n\nThe Circle constructor in Lab 0 requires the distance \nd\nd\n between two input points to be \n0 < d \\le 2r\n0 < d \\le 2r\n.  If the condition is violated, you are asked to return an invalid circle.  A better way is to throw an unchecked exception \nIllegalArgumentException\n if one of the above two conditions is met.  \n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n \nCircle\n(\nPoint\n \np\n,\n \nPoint\n \nq\n,\n \ndouble\n \nr\n,\n \nboolean\n \ncenterOnLeft\n)\n \n{\n\n  \nif\n \n(\np\n.\ndistanceTo\n(\nq\n)\n \n>\n \n2\n*\nr\n)\n \n{\n\n    \nthrow\n \nnew\n \nIllegalArgumentException\n(\n\"Input points are too far apart\"\n);\n\n  \n}\n\n  \nif\n \n(\np\n.\nequals\n(\nq\n))\n \n{\n\n    \nthrow\n \nnew\n \nIllegalArgumentException\n(\n\"Input points coincide\"\n);\n\n  \n}\n\n\n\n\n\n\n\nNote that difference between \nthrow\n and \nthrows\n: the former is to generate an exception, the latter to specify that the exception(s) thrown by a method.\n\n\nIf you find that none of the \nexceptions provided by Java\n meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones.\nBut, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.\n\n\nOverriding Method that Throws Exceptions\n\n\nWhen you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method.  This rule enforces the Liskov Substitution Principle.  The caller of the overridden method cannot expect any new checked exception than what has already been \"promised\" in the method specification.\n\n\nGood Practices for Exception Handling\n\n\nCatch Exceptions to Clean Up\n\n\nWhile it is convenient to just let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so.  Consider the example earlier, where \nm1()\n, \nm2()\n, and \nm3()\n do not handle exception E2.  Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly.  Also, suppose that \nm2()\n allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method.  Not handling the exception, means that, code that deallocates these resources does not get called when an exception occurs!  It is better for \nm2()\n to catch the exception, handle the resource deallocation in a \nfinally\n block.  If there is a need for the calling methods to be aware of the exception, \nm2()\n can always re-throw the exception:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\npublic\n \nvoid\n \nm2\n()\n \nthrows\n \nE2\n \n{\n\n  \ntry\n \n{\n\n    \n// setup resources\n\n    \nm3\n();\n\n  \n}\n\n  \ncatch\n \n(\nE2\n \ne\n)\n \n{\n\n    \nthrow\n \ne\n;\n\n  \n}\n\n  \nfinally\n \n{\n\n    \n// clean up resources\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nCatch All Exception is Bad\n\n\nSometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions.  Since Java uses checked exceptions, it forces you to handle the exceptions or else your code will not compile.  One way to quickly get around this is to write:\n\n\n1\n2\n3\n4\n5\n6\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nException\n \ne\n)\n \n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nto shut the compiler up.  DO NOT DO THIS.  All exceptions thrown are now silently ignored!  This is such as bad practice that there is a name for this -- this is call the \nPokemon Exception Handling\n.\n\n\nCan we do \nworse\n?  How about the following:\n\n1\n2\n3\n4\n5\n6\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nError\n \ne\n)\n \n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\ud83d\ude31\n\n\nOverreacting\n\n\nDo not exit a program just because of exception.  This would prevent the calling function from cleaning up their resources.  Worse, do not exit a program silently.\n\n\n1\n2\n3\n4\n5\n6\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nException\n \ne\n)\n \n{\n\n  \nSystem\n.\nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\n\nDo Not Break Abstraction Barrier\n\n\nSometimes, letting the calling method handles the exception causes the implementation details to be leaked, and make it harder to change the implementation later.\n\n\nFor instance, suppose we design a class \nClassRoster\n with a method \ngetStudents()\n, which reads the list of students from a text file.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nClassRoster\n \n{\n\n   \n:\n\n  \npublic\n \nStudents\n[]\n \ngetStudents\n()\n \nthrows\n \nFileNotFoundException\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\nLater, we change the implementation to reading the list from an SQL database,\n\n1\n2\n3\n4\n5\n6\nclass\n \nClassRoster\n \n{\n\n   \n:\n\n  \npublic\n \nStudents\n[]\n \ngetStudents\n()\n \nthrows\n \nSQLException\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\nWe should, as much as possible, handle the implementation specific exceptions within the abstraction barrier.  \n\n\nExercise\n\n\n\n\n\n\nSuppose we have an interface \nShape\n and two classes \nCircle\n and \nSquare\n that implements \nShape\n.  We initialize the following variables:\n\n\n1\n2\nShape\n[]\n \nshapes\n;\n\n\nCircle\n[]\n \ncircles\n \n=\n \nnew\n \nCircle\n[\n1\n];\n\n\n\n\n\n\n\nWill the following two lines compile?  Will any of the lines cause a run time exception?  Explain.\n\n1\n2\nshapes\n \n=\n \ncircles\n;\n\n\nshapes\n[\n0\n]\n \n=\n \nnew\n \nSquare\n(\n3.0\n);\n\n\n\n\n\n\n(Assume \nSquare\n has a constructor that takes in a single \ndouble\n argument.)\n\n\n\n\n\n\nWrite a static method with the following signature:\n\n\n1\npublic\n \nstatic\n \nboolean\n \nsearch\n(\nObject\n[]\n \na\n,\n \nObject\n \ntarget\n)\n \n\n\n\n\n\n\nto search linearly through the array \na\n to see if there exists an element of \na\n that equals to \ntarget\n (the equality is tested using the \nequals\n method).  The method returns \ntrue\n if the \ntarget\n is found, and returns \nfalse\n otherwise.\n\n\nFor instance, \n\n\n1\n2\n3\nPoint\n[]\n \npoints\n \n=\n \n{\n \nnew\n \nPoint\n(\n0\n,\n0\n),\n \nnew\n \nPoint\n(\n0\n,\n1\n),\n \nnew\n \nPoint\n(\n0\n,\n2\n)\n \n};\n\n\nsearch\n(\npoints\n,\n \nnew\n \nPoint\n(\n0\n,\n1\n));\n \n// return true\n\n\nsearch\n(\npoints\n,\n \nnew\n \nPoint\n(\n1\n,\n1\n));\n \n// return false\n\n\n\n\n\n\n\nTake note of how method overriding, polymorphism, widening type conversion, and the covariance property of Java array are used in this question.\n\n\n\n\n\n\nIn Java, we cannot write a method to swap two primitive types without going through some hoops.  For instance, the following does not work:\n\n\n1\n2\n3\n4\n5\nstatic\n \nvoid\n \nswap\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n  \nint\n \ntmp\n \n=\n \nx\n;\n\n  \nx\n \n=\n \ny\n;\n\n  \ny\n \n=\n \ntmp\n;\n\n\n}\n\n\n\n\n\n\n\nWhy? \n\n\nTo pass a variable of primitive type by reference, we need to wrap the variable in a wrapper class.  For example,\n\n\n1\n2\n3\n4\nclass\n \nWrapper\n \n{\n\n  \npublic\n \nint\n \nx\n;\n\n  \npublic\n \nint\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nUsing the \nWrapper\n class above to pass the two variables \nx\n and \ny\n into the \nswap\n method to swap their values.  Using the method signature:\n\n\n1\n2\n3\nstatic void swap(Wrapper w) {\n  // TODO\n}\n\n\n\n\n\n\nShow how you would implement and use the \nswap\n method.  Convince yourself that it is working by tracing through the content of the stack and heap as you call \nswap\n.\n\n\n\n\n\n\nWill the following result in a compile time error?  Run time error?\n\n\n(a)\n\n1\n2\n3\n4\n5\n6\nint\n \ni\n;\n\n\ndouble\n \nd\n;\n\n\ni\n \n=\n \nd\n;\n\n\nd\n \n=\n \ni\n;\n\n\ni\n \n=\n \n(\nint\n)\n \nd\n;\n\n\nd\n \n=\n \n(\ndouble\n)\n \ni\n;\n\n\n\n\n\n\n(b)\n\n1\n2\n3\n4\n5\n6\nint\n \ni\n;\n\n\nboolean\n \nb\n;\n\n\ni\n \n=\n \nb\n;\n\n\nb\n \n=\n \ni\n;\n\n\ni\n \n=\n \n(\nint\n)\n \nb\n;\n\n\nb\n \n=\n \n(\nboolean\n)\n \ni\n;\n\n\n\n\n\n\n(C)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n \n=\n \n(\nB\n)\na\n;\n\n\na\n \n=\n \n(\nA\n)\nb\n;\n\n\n\n\n\n\n(d)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ninterface\n \nI\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nI\n \n{\n\n\n}\n\n\n\nI\n \ni1\n \n=\n \nnew\n \nI\n();\n\n\nI\n \ni2\n \n=\n \nnew\n \nA\n();\n\n\nA\n \na1\n \n=\n \ni2\n;\n\n\nA\n \na2\n \n=\n \n(\nA\n)\ni2\n;\n\n\n\n\n\n\n(e)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ninterface\n \nI\n \n{\n\n\n}\n\n\n\ninterface\n \nJ\n \nextends\n \nI\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nJ\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nI\n \ni\n \n=\n \na\n;\n\n\nJ\n \nj\n \n=\n \na\n;\n\n\ni\n \n=\n \nj\n;\n\n\nj\n \n=\n \ni\n;\n\n\nj\n \n=\n \n(\nJ\n)\ni\n;\n\n\na\n \n=\n \ni\n;\n\n\na\n \n=\n \nj\n;\n\n\na\n \n=\n \n(\nA\n)\ni\n;\n\n\na\n \n=\n \n(\nA\n)\nj\n;\n\n\n\n\n\n\n(f)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\ninterface\n \nI\n \n{\n\n\n}\n\n\n\ninterface\n \nJ\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nI\n,\n \nJ\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nI\n \ni\n \n=\n \na\n;\n\n\nJ\n \nj\n \n=\n \na\n;\n\n\ni\n \n=\n \nj\n;\n\n\nj\n \n=\n \ni\n;\n\n\nj\n \n=\n \n(\nJ\n)\ni\n;\n\n\nI\n \n=\n \n(\nI\n)\nj\n;\n\n\na\n \n=\n \ni\n;\n\n\na\n \n=\n \nj\n;\n\n\na\n \n=\n \n(\nA\n)\ni\n;\n\n\na\n \n=\n \n(\nA\n)\nj\n;\n\n\n\n\n\n\n(g)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nclass\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nC\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\nC\n \nc\n \n=\n \nb\n;\n\n\nA\n \na\n \n=\n \n(\nA\n)\nb\n;\n\n\nC\n \nc\n \n=\n \n(\nC\n)\nb\n;\n\n\n\n\n\n\n\n\n\n\nWill each of the following programs compile? If so, what will be printed?\n\n\n(a)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nIllegalArgumentException\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before throw\"\n);\n\n      \nthrow\n \nnew\n \nIllegalArgumentException\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After throw\"\n);\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(b)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nIllegalArgumentException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nIllegalArgumentException\n();\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(C)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nIllegalArgumentException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nException\n();\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(d)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nIllegalArgumentException\n();\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(e)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nArrayIndexOutOfBoundsException\n();\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(f)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nArrayIndexOutOfBoundsException\n();\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught IA exception in f\"\n);\n\n    \n}\n \ncatch\n \n(\nArrayIndexOutOfBoundsException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught AIOOB exception in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(g)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nArrayIndexOutOfBoundsException\n();\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught exception in f\"\n);\n\n    \n}\n \ncatch\n \n(\nArrayIndexOutOfBoundsException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught AIOOB exception in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(h)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nArrayIndexOutOfBoundsException\n();\n\n    \n}\n \ncatch\n \n(\nArrayIndexOutOfBoundsException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught AIOOB exception in f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught exception in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n(i)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nMain\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \nthrows\n \nException\n \n{\n\n    \ntry\n \n{\n\n      \nthrow\n \nnew\n \nArrayIndexOutOfBoundsException\n();\n\n    \n}\n \ncatch\n \n(\nIllegalArgumentException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in f\"\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \ntry\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Before f\"\n);\n\n      \nf\n();\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"After f\"\n);\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\n\"Caught in main\"\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA utility class is a Java class that contains only class methods and class fields.  You have seen another example in CS2030, \nMath\n, and will see a few more in this module.\u00a0\n\u21a9\n\n\n\n\n\n\nUnlike earlier figures, I didn't show the class metadata and method tables for simplicity.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is not that difference from how an OS handles function call in a machine code, as you will see in CS2100/CS2106.\u00a0\n\u21a9\n\n\n\n\n\n\nThe other things are JVM implementation independent and not relevant to our discussion here.\u00a0\n\u21a9",
            "title": "4. Types, Memory, Exception"
        },
        {
            "location": "/lec04/index.html#lecture-4-types-memory-exception",
            "text": "",
            "title": "Lecture 4: Types, Memory, Exception"
        },
        {
            "location": "/lec04/index.html#learning-outcomes",
            "text": "After this class, students should:   understand the differences between compile time and run time  understand the basic rules for type conversion in Java, including the differenes between narrowing conversion and widening conversion.  understand the concept of subtyping in general and the subtype relations in Java  understand what is type covariance and that Java arrays are covariance.  understand when memory are allocated/deallocated from the heap vs. from the stack  understand the concept of call stack in JVM  understand how Java call by reference and call by value  know about the keywords  null ,  try ,  catch ,  finally ,  throw , and  throws .  appreciate why exceptions is a useful way of handling errors  aware of the differences between errors, unchecked exception, and checked exception in Java  be able to trace through the control flow of  try / catch / finally  block  how to generate an exception and create a new exception  not commit bad practices when using exceptions",
            "title": "Learning Outcomes"
        },
        {
            "location": "/lec04/index.html#java-and-javac",
            "text": "Now that we have gone through the basic concepts of OO programming, let's take a step away from OO for the moment and look at some other important features of Java.  In your  Lab 0 , we showed you how to use  javac  to compile your Java program and  java  to execute your program.    javac  is a  compiler . It reads in Java source files as a string, parses the string for syntax errors, and converts the Java code into an intermediate binary format called the  bytecode .  Bytecode is an instruction set akin to hardware instructions but is typically executed by a software interpreter.  This behavior is different from what  gcc  does for C programs.   gcc  produces native machine code, corresponding to hardware instructions.  As such, a C program your  gcc  produced on your home machine will not run on  sunfire .    Java designers (led by James Gosling) wanted a language that can be compiled into a form that is platform and hardware independent, thus, they developed their own runtime environment called the Java Virtual Machine (JVM), which interprets and executes the bytecode, optimizes the execution, and manages the memory of Java programs.  Bytecode produced (the  .class  files) on one platform can run other platforms.   Other Bytecode Languages  Many other programming environments offer compilation to bytecode.  Python, for instance, compiles Python code into  .pyc  files, which contain Python bytecode.  Facebook's HHVM compiles PHP into bytecode.  Google's V8 compiles Javascript into bytecode too.    Other JVM Languages  While JVM was initially designed for Java, its popularity has led to the development of other languages that compile to JVM bytecode and run on JVM, such as Clojure, Groovy, Scala and Kotlin.      Other Java Compilers  While we stick to the Java 9 compiler from Oracle for CS2030, there are other Java compilers:  ecj  is the Java compiler from Eclipse -- if you use Eclipse IDE, this is the default compiler.   gcj  is the GNU Java Compiler (which has been removed from GCC 7 onwards).   Once you produce the  .class  files containing the bytecode corresponding to the code you have written, you can pass the bytecode to JVM for execution by invoking the  java  command.  This is when your code gets executed -- objects get created and stored in memory, methods get called, etc.",
            "title": "java and javac"
        },
        {
            "location": "/lec04/index.html#compile-time-vs-run-time",
            "text": "It is important to understand the difference between the two stages, compile time (when we invoke  javac ) and run time (when we invoke  java ).  During compile time, the compiler does not always know what value a variable will take, nor will it know the sequence of execution of the programs.  As such, the compiler opts to be conservative and only makes the decision on what it knows for sure.  We have encountered this before -- recall our discussion on late binding: 1\n2\n3    for   ( Printable   o :   objs )   { \n       o . print (); \n   }    The compiler cannot always be sure what is the class of the object the variable  o  will refer to during runtime, and thus, it cannot be sure which version of  print  method will be executed.    In another example, we have  1\n2\n3    Circle   c   =   new   Circle ( new   Point ( 0 , 0 ),   10 ); \n   Printable   c2   =   c ; \n   c2 . getArea ();    At compile time,  c2  has a type  Printable , and we try to invoke  getArea  which is a method available in  Circle , not  Printable .  Even though if we trace through the three lines of code above, we (the humans) can be sure that  c2  is pointing to a  Circle  object and it is fine to call  getArea , the compiler has to be conservative as it is designed to work on arbitrarily complex programs with an unknown sequence of execution.  The compiler thus does not allow us to call  c2.getArea() .",
            "title": "Compile Time vs Run Time"
        },
        {
            "location": "/lec04/index.html#jshell",
            "text": "If we compile a program with  javac  and then execute it with  java , we have two distinct phases.  An error reported by  javac  occurs during compilation and is a  compile time error .  An error reported by  java  occors during run time, and is a  run time error .    If we \"play\" with our classes and with Java syntax using  jshell , however, the differences between compile time and run time error are blurred.   jshell  is an \"REPL\" tool, which stands for \"read-eval-print loop\", and it does exactly what the name says: it repeatedly reads in a Java statement, evaluates the statement, and prints out the result.  The reading step is analogous to compiling, while the evaluating and printing steps are analogous to running a program.  So,  jshell  produces an error message, it could be due to an error triggered by either compile time or run time.",
            "title": "jshell"
        },
        {
            "location": "/lec04/index.html#1-types",
            "text": "The above discussion brings us back to the topic of types.  Unlike C which is not type safe or  Python and Javascript which are weakly typed, Java belongs to a class of programming language which is statically typed and enforces type safety through a rich set of rules.  Understanding these rules and appreciating them is important to writing good and general Java programs, as well as picking up other statically and strongly typed programming languages.",
            "title": "1. Types"
        },
        {
            "location": "/lec04/index.html#type-conversion",
            "text": "Sometimes a programmer knows better than the compiler the intention of the program.  In this case, it is useful for a programmer to override the compiler's decision.  One possible such override is to force the type of a variable to be something more appropriate, through  type casting .  We have seen type casting in action when we discussed about type safety (see  Lecture 1 ).  Recall that, in C, we can type cast two seemingly incompatible types to each other.  We have also seen it  last week  when we cast an  Object  variable to a  Circle  when we discuss overriding of the  equals()  method.  Type casting is a form of type conversion, in particular, an  explicit type conversion .   Let's talk about  implicit type conversion  first.  Implicit conversion can happen in several contexts:   Assignment, for instance, assigning a variable of type  Circle  to a variable of type `Shape.  Method invocation, for instance, when you pass a variable of type  Circle  to a method expecting  Shape .  String conversion, when one of the operands of  +  is a  String  and the other is not, in which case it will be converted to  String  (by calling  toString() ).   Suppose we have a reference type  S S  and  T T  is a subtype of  S S  (denoted  T <: S T <: S ), then converting  T T  to  S S  is checked at compile time.  This conversion is known as  widening reference conversion .  The converse is not true.  If we want to convert  S S  to  T T  (known as  narrowing reference conversion ), then we need explicit casting.  Such conversion is checked at run time, and it may cause an exception.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   S   {   }  class   T   extends   S   {   }  class   U   extends   S   {   }   S   s1 ,   s2 ;  T   t   =   new   T ();  U   u   =   new   U ();  s1   =   t ;    // always OK since this is a widening reference conversion.  s2   =   u ;    // always OK since this is a widening reference conversion.  t    =   s1 ;   // not allowed since it is a narrowing reference conversion.  t    =   ( T ) s1 ;   // explicit conversion allowed by compiler, no problem during run time.  t    =   ( T ) s2 ;   // explicit conversion allowed by compiler, but cause run time error.     Java subtyping and conversion specification  We are not going through all the gory details of Java subtyping and type conversion rules.  Chapter 5 of  Java Language Specification  succinctly and precisely defines all the rules on this topic.  For those students who are interested, you can check it out.  Otherwise, we will discover some of the other rules along the way as we learn more about Java in practice.",
            "title": "Type Conversion"
        },
        {
            "location": "/lec04/index.html#subtyping",
            "text": "We have seen how subtyping works in Java: we say that if a class  T T  extends from class  S S  or implements interface  S S ,  T T  is a subtype of  S S .  The notion of subtyping, however, is more general than that.  In the study of programming languages, we say that  T T  is a subtype of  S S  if a piece of code written for variables of type  S S  can also safely be used on variables of type  T T .   In the context of Java and other OO languages, inheritance and implementation of interfaces satisfy these conditions.  In other languages, however, we can create subtypes without these OO notions.  In Ada, for instance, we can create a subtype by restricting the range of values of a type.  E.g., we can create a subtype  digit  from the type  int , restricting its value to ranging between 0 and 9.  With this more general notion of subtyping, we can define subtype relations between the primitive types, as follows:  byte   <: <:   short   <: <:   int   <: <:   long   <: <:   float   <: <:   double ; and  char   <: <:   int  We can also extend the notion of widening conversion and narrowing conversion to primitive types.",
            "title": "Subtyping"
        },
        {
            "location": "/lec04/index.html#variance-of-types",
            "text": "Given a type  T T , we can create other complex types that depend on  T T .  For instance, we can have an array of type  T T , a generic class parameterized by  T T  (next lecture), a method that takes in  T T  and returns  T T , etc.  The term  variance of types  refers to how these more complex types relate to each other, given the relationship between the simpler types.  Suppose  A(T) A(T)  is the complex type constructed from  T T .  Then we say that    A A  is  covariant  if  T <: S T <: S  implies  A(T) <: A(S) A(T) <: A(S) ,   A A  is  contravariant  if  T <: S T <: S  implies  A(S) <: A(T) A(S) <: A(T) ,  A A  is  bivariant  if it is both covariant and contravariant, and  A A  is  invariant  if it is neither covariant nor contravariant.   For example, in Java, arrays (of reference type) are covariant.  This means that,  T[]  is a subtype of  S[] , if  T  is a subtype of  S .  Based on the type conversion rule, it is OK to assign any array of reference type to an array of  Object  objects, or pass an array of reference type to a method that expects an array of  Object  objects.  This decision (of making Java arrays covariant) makes it possible to write very generic method that operates on array, as provided by the Java utility class  Arrays . 1  We will see examples of complex type  A A  that is invariant and contravariant later in this module.",
            "title": "Variance of Types"
        },
        {
            "location": "/lec04/index.html#2-heap-and-stack",
            "text": "As mentioned earlier, JVM manages memory of Java programs while its bytecode instructions are interpreted and executed.  Different JVM implementation may implement these differently, but typically a JVM implementation partitions the memory into several regions, including\n-  method area  for storing the code for the methods;\n-  metaspace  for storing meta information about classes;\n-  heap  for storing dynamically allocated objects;\n-  stack  for local variables and call frames.  Since the concepts of heap and stack are common to all execution environments (either based on bytecode or machine code), we will focus on them here.  The  heap  is the region in memory where all objects are allocated in and stored, while the  stack  is the region where all variables (including primitive types and object references) are allocated in and stored.  Considers the following two lines of code. 1\n2 Circle   c ;  c   =   new   Circle ( new   Point ( 1 ,   1 ),   8 );   \nLine 1 declares a variable  c .  When Java executes this line of code, it allocates some memory space for an object reference for  c , the content is initialized to  null .  Since  c  is a variable, it resides in the stack.   null  in Java  null  is a special value for the object reference, that signifies that this reference is not pointing to any object.  This is similar to the  null  in Javascript,  NULL  macro in C,  nullptr  in C++11,  None  in Python,  nil  in Objective-C.  (Again, you see here computer scientists just can't agree on names!)   Sir Tony Hoare  (who also invented quicksort) famously apologized for inventing the null pointer.  He calls it his billion-dollar mistake.   Line 2 creates a new Circle object.  When Java executes this line of code, it allocates some memory space for a  Circle  object on the heap.  The memory address of this memory space becomes the reference of the object and is assigned to the variable  c .  This is shown in the figure below 2 .   The first argument to  Circle  constructor is also an object, so to be more precise, when Line 2 above is executed, a  Point  object is also created and allocated on the heap.  So the field  c  inside  Circle  is actually a reference to this object.   Now, let's look at a slightly different example.  1\n2\n3\n4\n5\n6 Circle   c ;  Point   center ;  double   radius ;  radius   =   8 ;  center   =   new   Point ( 1 ,   1 );  c   =   new   Circle ( center ,   radius );    In the second example, we have three variables,  c ,  center , and  radius  .  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Recall that for object references, they are initialized to  null .  Primitive type variables (e.g.,  radius ) are initialized to 0.   After Lines 4-6, we have:",
            "title": "2. Heap and Stack"
        },
        {
            "location": "/lec04/index.html#call-stack",
            "text": "Now, let's look at what happens when we invoke a method.  Take the  distanceTo  method in  Point  as an example:  1\n2\n3\n4\n5\n6\n7 class   Point   { \n   private   double   x ; \n   private   double   y ; \n   public   double   distanceTo ( Point   q )   { \n     return   Math . sqrt (( q . x   -   this . x )*( q . x   -   this . x )+( q . y   -   this . y )*( q . y   -   this . y )); \n   }  }   \nand the invocation: 1\n2\n3 Point   p1   =   new   Point ( 0 , 0 );  Point   p2   =   new   Point ( 1 , 1 );  p1 . distanceTo ( p2 );    After declaring  p1  and  p2  and creating both objects, we have:  When  distanceTo  is called, JVM creates a  stack frame  for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the  this  reference, (ii) the method arguments, and (iii) local variables within the method, among other things 3 4 .  When a class method is called, the stack frame does not contain the  this  reference.   You can see that the  references  to the objects  p1  and  p2  are copied onto the stack frame.  p1  and  this  point to the same object, and  p2  and  q  point to the same object.\nWithin the method, any modification done to  this  would change the object referenced to by  p1 , and any change made to  q  would change the object referenced to by  p2  as well.\nAfter the method returns, the stack frame for that method is destroyed.  Let's call the  move  function from your  Lab 0 , with arguments  (double theta, double d) .  1\n2\n3 double   theta   =   Math . PI / 4.0 ;  double   distance   =   1 ;  p2 . move ( theta ,   distance );    Again, we create a stack frame, copy the reference to object  p2  into  this , copy  theta  from the calling function to  theta  the argument within the method, copy  distance  from the calling function to  d  the argument within the method.  Recall that, in this function, you actually change the  x  and  y  of  this  to move  p2 .     What is important here is that, as  theta  and  distance  are primitive types instead of references, we copy the values onto the stack.  If we change  theta  or  d  within  move , the  theta  and  distance  of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass in a variable of primitive type into a method and have its value changed, you will have to use a  wrapper class .  The details of how to do this are left as an exercise.  To summarize, Java uses  call by value  for primitive types, and  call by reference  for objects.  If we made multiple nested method calls, as we usually do, the stack frames get stacked on top of each other.  For instance, in Lab 0,  main  calls  solve , which calls the  Circle  constructor, which calls the  angleTo .  When JVM is executing  angleTo , the call stack contains the stack frames of (in order of top to bottom):  angleTo ,  Circle  constructor,  solve , and  main .  One final note: the memory allocated on the stack are deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a  garbage collector   that checks for unreferenced objects on the heap and cleans up the memory automatically.",
            "title": "Call Stack"
        },
        {
            "location": "/lec04/index.html#3-exceptions",
            "text": "One of the nuances of programming is having to write code to deal with exceptions and errors.  Consider writing a method that reads in a series of x and y coordinates from a file, not unlike what you have seen in Lab 0.  Here are some things that could go wrong:   The file to read from may not exist  The file to read from exists, but you may not have permission to read it  You can open the file for reading, but it might contain non-numeric text where you numerical values  The file might contain fewer values than expected  The file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive)   In C, we usually have to write code like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 fd   =   fopen ( filename , \"r\" );  if   ( fd   ==   NULL )   { \n   fprintf ( stderr ,   \"Unable to open file. \" ); \n   if   ( errno   ==   ENFILE )   { \n     fprintf ( stderr ,   \"Too many opened files.  Unable to open another \\n \" ); \n   }   else   if   ( errno   ==   ENOENT )   { \n     fprintf ( stderr ,   \"No such file %s \\n \" ,   filename ); \n   }   else   if   ( errno   ==   EACCES )   { \n     fprintf ( stderr ,   \"No read permission to %s \\n \" ,   filename ); \n   } \n   return   - 1 ;  }  scanned   =   fscanf ( fd ,   \"%d\" ,   & num_of_points );  if   ( scanned   ==   0 )   { \n   fprintf ( stderr ,   \"Unable to scan for an integer \\n \" ); \n   fclose ( fd ); \n   return   - 2 ;  }  if   ( scanned   ==   EOF )   { \n   fprintf ( stderr ,   \"No input found. \\n \" ); \n   fclose ( fd ); \n   return   - 3 ;  }    Out of the lines above, only 2 lines correspond to the actual tasks, the others are for exception checking/handling.  How uncool is that?  Furthermore, the actual tasks are interspersed between exception checking code, making reading and understanding the logic of the code difficult.  The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors.  Note that the POSIX APIs has a global variable  errno  that signifies the detailed error.  First, we have to check for different  errno  values and react accordingly (we can use  perror , but that has its limits).  Second,  errno  is global and we know that using global variable is bad practice.  In fact, I am not even sure that code above works because  fprintf  in Line 3 might have changed  errno !  Then, there is the issue of having to repeatedly clean up after an error -- here we  fclose  the file if there is an error reading, twice.  It is easy to forget to do so if we have to do this in multiple places.   Furthermore, if we need to perform more complex clean up, then we would end up with lots of repeated code.  Fortunately, Java supports  try / catch / finally  control statements, which is a way to group statements that check/handle errors together making code easier to read.  The Java equivalent to the above is:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 try   { \n   reader   =   new   FileReader ( filename ); \n   scanner   =   new   Scanner ( reader ); \n   numOfPoints   =   scanner . nextInt ();  }  catch   ( FileNotFoundException   e )   { \n     System . err . println ( \"Unable to open \"   +   filename   +   \" \"   +   e );  }  catch   ( InputMismatchException   e )   { \n     System . err . println ( \"Unable to scan for an integer\" );  }  catch   ( NoSuchElementException   e )   { \n     System . err . println ( \"No input found\" );  }  finally   { \n   if   ( scanner   !=   null ) \n     scanner . close ();  }    Here Lines 2-4 keep the basic tasks together, and all the clean up tasks are grouped together in Lines 18-19.  Lines 8-16 handle the exceptions.  We no longer rely on a global variable to convey the type of exceptions, or special return value to indicate exceptions.   What if we want the calling method to handle the exception?  Then, we simply do not do anything (i.e., do not catch the exception) and let the exception propagates to the calling method automatically.   Error vs. Exception in Java  We have been using the term error and exception loosely.  Java has different classes for  Error  and  Exception .   Error  is for situations where the program should terminate as generally there is no way to recover.  For instance, when the heap is full ( OutOfMemoryError ) or the stack is full ( StackOverflowError ).  Exceptions are for situations where it is still possible to reasonably recover from the error.    Combining Multiple Catches  In cases where the code to handle the exceptions is the same, you can 1\n2\n3 catch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n    System.err.println(e);\n}    Here is a more detailed description of the control flow of exceptions.  Consider we have a  try - catch - finally  block that catches two exceptions  E1  and  E2 .  Inside the  try  block, we call a method  m1() ;  m1()  calls  m2() ;  m2()  calls  m3() , and  m3()  calls  m4() .   In a normal (no exception) situation, the control flow looks like this:   The statements in  try  block are executed, followed by the statements in  finally  block.  Now, let's suppose something went wrong deep inside the nested call, in  m4() .  One of the statement executes  throw new E2(); , which causes the execution in  m4()  to stop.  JVM now looks for the block of code that catches  E2 , going down the call stack, until it can find a place where the exception is handled.  In this example, we suppose that none of  m1() - m4()  handles (i.e.,  catch ) the exception.  Thus, JVM then jumps to the code that handles  E2 .  Finally, JVM executes the  finally  block.  Note that the  finally  block is always executed even when  return  or  throw  is called in a  catch  block.",
            "title": "3. Exceptions"
        },
        {
            "location": "/lec04/index.html#checked-exceptions",
            "text": "There are two types of exceptions in Java:  checked  and  unchecked  exceptions:   A checked exception is something that the programmer should anticipate and handle.  For instance, when you open a file, you should anticipate that in some cases, the file cannot be open.     An unchecked exception is something that the programmer does not anticipate, and usually is a result of a bug.  For example, when you try to call  p.distanceTo(q)  but  p  is  null ,  NullPointerException  will be thrown.     We need to either catch all checked exceptions or let it propagate to the calling method .  Otherwise, the program will not compile.    For unchecked exceptions, even though we could catch it, it makes more sense to eliminate the bugs.  In Java, unchecked exceptions are subclasses of  RuntimeException .  All  Error s are unchecked.  All methods that throw checked exception need to  specify  the checked exception(s).  For example, if we want to put the code to open a file and read an  int  from it into a function, and want the calling function to deal with the exception, this is what we should do:  1\n2\n3\n4\n5\n6\n7\n8 public   static   int   readIntFromFile ( String   filename ) \n   throws   FileNotFoundException   { \n   FileReader   reader   =   new   FileReader ( filename ); \n   Scanner   scanner   =   new   Scanner ( reader ); \n   int   numOfPoints   =   scanner . nextInt ();     \n   scanner . close (); \n   return   numOfPoints ;  }    Note Line 2 specify that this method might throw  FileNotFoundException .    A checked exception must be either caught or thrown to calling function, except  main , which has no calling function to throw to.  If  main  does not catch a checked exception, the program exits, and the exception is revealed to the user -- this is generally considered a bad programming practice.  The two other exceptions from the examples above  InputMismatchException  and  NoSuchElementException  are subclasses of  RuntimeException , and therefore are unchecked.",
            "title": "Checked Exceptions"
        },
        {
            "location": "/lec04/index.html#generating-exception",
            "text": "The Circle constructor in Lab 0 requires the distance  d d  between two input points to be  0 < d \\le 2r 0 < d \\le 2r .  If the condition is violated, you are asked to return an invalid circle.  A better way is to throw an unchecked exception  IllegalArgumentException  if one of the above two conditions is met.    1\n2\n3\n4\n5\n6\n7 public   Circle ( Point   p ,   Point   q ,   double   r ,   boolean   centerOnLeft )   { \n   if   ( p . distanceTo ( q )   >   2 * r )   { \n     throw   new   IllegalArgumentException ( \"Input points are too far apart\" ); \n   } \n   if   ( p . equals ( q ))   { \n     throw   new   IllegalArgumentException ( \"Input points coincide\" ); \n   }    Note that difference between  throw  and  throws : the former is to generate an exception, the latter to specify that the exception(s) thrown by a method.  If you find that none of the  exceptions provided by Java  meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones.\nBut, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.",
            "title": "Generating Exception"
        },
        {
            "location": "/lec04/index.html#overriding-method-that-throws-exceptions",
            "text": "When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method.  This rule enforces the Liskov Substitution Principle.  The caller of the overridden method cannot expect any new checked exception than what has already been \"promised\" in the method specification.",
            "title": "Overriding Method that Throws Exceptions"
        },
        {
            "location": "/lec04/index.html#good-practices-for-exception-handling",
            "text": "",
            "title": "Good Practices for Exception Handling"
        },
        {
            "location": "/lec04/index.html#catch-exceptions-to-clean-up",
            "text": "While it is convenient to just let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so.  Consider the example earlier, where  m1() ,  m2() , and  m3()  do not handle exception E2.  Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly.  Also, suppose that  m2()  allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method.  Not handling the exception, means that, code that deallocates these resources does not get called when an exception occurs!  It is better for  m2()  to catch the exception, handle the resource deallocation in a  finally  block.  If there is a need for the calling methods to be aware of the exception,  m2()  can always re-throw the exception:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 public   void   m2 ()   throws   E2   { \n   try   { \n     // setup resources \n     m3 (); \n   } \n   catch   ( E2   e )   { \n     throw   e ; \n   } \n   finally   { \n     // clean up resources \n   }  }",
            "title": "Catch Exceptions to Clean Up"
        },
        {
            "location": "/lec04/index.html#catch-all-exception-is-bad",
            "text": "Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions.  Since Java uses checked exceptions, it forces you to handle the exceptions or else your code will not compile.  One way to quickly get around this is to write:  1\n2\n3\n4\n5\n6 try   { \n   // your code  }  catch   ( Exception   e )   { \n   :  }    to shut the compiler up.  DO NOT DO THIS.  All exceptions thrown are now silently ignored!  This is such as bad practice that there is a name for this -- this is call the  Pokemon Exception Handling .  Can we do  worse ?  How about the following: 1\n2\n3\n4\n5\n6 try   { \n   // your code  }  catch   ( Error   e )   { \n   :  }   \n\ud83d\ude31",
            "title": "Catch All Exception is Bad"
        },
        {
            "location": "/lec04/index.html#overreacting",
            "text": "Do not exit a program just because of exception.  This would prevent the calling function from cleaning up their resources.  Worse, do not exit a program silently.  1\n2\n3\n4\n5\n6 try   { \n   // your code  }  catch   ( Exception   e )   { \n   System . exit ( 0 );  }",
            "title": "Overreacting"
        },
        {
            "location": "/lec04/index.html#do-not-break-abstraction-barrier",
            "text": "Sometimes, letting the calling method handles the exception causes the implementation details to be leaked, and make it harder to change the implementation later.  For instance, suppose we design a class  ClassRoster  with a method  getStudents() , which reads the list of students from a text file.  1\n2\n3\n4\n5\n6 class   ClassRoster   { \n    : \n   public   Students []   getStudents ()   throws   FileNotFoundException   { \n     : \n   }  }   \nLater, we change the implementation to reading the list from an SQL database, 1\n2\n3\n4\n5\n6 class   ClassRoster   { \n    : \n   public   Students []   getStudents ()   throws   SQLException   { \n     : \n   }  }   \nWe should, as much as possible, handle the implementation specific exceptions within the abstraction barrier.",
            "title": "Do Not Break Abstraction Barrier"
        },
        {
            "location": "/lec04/index.html#exercise",
            "text": "Suppose we have an interface  Shape  and two classes  Circle  and  Square  that implements  Shape .  We initialize the following variables:  1\n2 Shape []   shapes ;  Circle []   circles   =   new   Circle [ 1 ];    Will the following two lines compile?  Will any of the lines cause a run time exception?  Explain. 1\n2 shapes   =   circles ;  shapes [ 0 ]   =   new   Square ( 3.0 );    (Assume  Square  has a constructor that takes in a single  double  argument.)    Write a static method with the following signature:  1 public   static   boolean   search ( Object []   a ,   Object   target )     to search linearly through the array  a  to see if there exists an element of  a  that equals to  target  (the equality is tested using the  equals  method).  The method returns  true  if the  target  is found, and returns  false  otherwise.  For instance,   1\n2\n3 Point []   points   =   {   new   Point ( 0 , 0 ),   new   Point ( 0 , 1 ),   new   Point ( 0 , 2 )   };  search ( points ,   new   Point ( 0 , 1 ));   // return true  search ( points ,   new   Point ( 1 , 1 ));   // return false    Take note of how method overriding, polymorphism, widening type conversion, and the covariance property of Java array are used in this question.    In Java, we cannot write a method to swap two primitive types without going through some hoops.  For instance, the following does not work:  1\n2\n3\n4\n5 static   void   swap ( int   x ,   int   y )   { \n   int   tmp   =   x ; \n   x   =   y ; \n   y   =   tmp ;  }    Why?   To pass a variable of primitive type by reference, we need to wrap the variable in a wrapper class.  For example,  1\n2\n3\n4 class   Wrapper   { \n   public   int   x ; \n   public   int   y ;  }    Using the  Wrapper  class above to pass the two variables  x  and  y  into the  swap  method to swap their values.  Using the method signature:  1\n2\n3 static void swap(Wrapper w) {\n  // TODO\n}   Show how you would implement and use the  swap  method.  Convince yourself that it is working by tracing through the content of the stack and heap as you call  swap .    Will the following result in a compile time error?  Run time error?  (a) 1\n2\n3\n4\n5\n6 int   i ;  double   d ;  i   =   d ;  d   =   i ;  i   =   ( int )   d ;  d   =   ( double )   i ;    (b) 1\n2\n3\n4\n5\n6 int   i ;  boolean   b ;  i   =   b ;  b   =   i ;  i   =   ( int )   b ;  b   =   ( boolean )   i ;    (C)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   A   {  }  class   B   extends   A   {  }  A   a   =   new   A ();  B   b   =   new   B ();  b   =   ( B ) a ;  a   =   ( A ) b ;    (d)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 interface   I   {  }  class   A   implements   I   {  }  I   i1   =   new   I ();  I   i2   =   new   A ();  A   a1   =   i2 ;  A   a2   =   ( A ) i2 ;    (e)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 interface   I   {  }  interface   J   extends   I   {  }  class   A   implements   J   {  }  A   a   =   new   A ();  I   i   =   a ;  J   j   =   a ;  i   =   j ;  j   =   i ;  j   =   ( J ) i ;  a   =   i ;  a   =   j ;  a   =   ( A ) i ;  a   =   ( A ) j ;    (f)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 interface   I   {  }  interface   J   {  }  class   A   implements   I ,   J   {  }  A   a   =   new   A ();  I   i   =   a ;  J   j   =   a ;  i   =   j ;  j   =   i ;  j   =   ( J ) i ;  I   =   ( I ) j ;  a   =   i ;  a   =   j ;  a   =   ( A ) i ;  a   =   ( A ) j ;    (g)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 class   A   {  }  class   B   extends   A   {  }  class   C   extends   A   {  }  B   b   =   new   B ();  A   a   =   b ;  C   c   =   b ;  A   a   =   ( A ) b ;  C   c   =   ( C ) b ;      Will each of the following programs compile? If so, what will be printed?  (a)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 class   Main   { \n   static   void   f ()   throws   IllegalArgumentException   { \n     try   { \n       System . out . println ( \"Before throw\" ); \n       throw   new   IllegalArgumentException (); \n       System . out . println ( \"After throw\" ); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (b)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Main   { \n   static   void   f ()   throws   IllegalArgumentException   { \n     try   { \n       throw   new   IllegalArgumentException (); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (C)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Main   { \n   static   void   f ()   throws   IllegalArgumentException   { \n     try   { \n       throw   new   Exception (); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (d)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   IllegalArgumentException (); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (e)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   ArrayIndexOutOfBoundsException (); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (f)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   ArrayIndexOutOfBoundsException (); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught IA exception in f\" ); \n     }   catch   ( ArrayIndexOutOfBoundsException   e )   { \n       System . out . println ( \"Caught AIOOB exception in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (g)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   ArrayIndexOutOfBoundsException (); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught exception in f\" ); \n     }   catch   ( ArrayIndexOutOfBoundsException   e )   { \n       System . out . println ( \"Caught AIOOB exception in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (h)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   ArrayIndexOutOfBoundsException (); \n     }   catch   ( ArrayIndexOutOfBoundsException   e )   { \n       System . out . println ( \"Caught AIOOB exception in f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught exception in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }    (i)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Main   { \n   static   void   f ()   throws   Exception   { \n     try   { \n       throw   new   ArrayIndexOutOfBoundsException (); \n     }   catch   ( IllegalArgumentException   e )   { \n       System . out . println ( \"Caught in f\" ); \n     } \n   } \n\n   public   static   void   main ( String []   args )   { \n     try   { \n       System . out . println ( \"Before f\" ); \n       f (); \n       System . out . println ( \"After f\" ); \n     }   catch   ( Exception   e )   { \n       System . out . println ( \"Caught in main\" ); \n     } \n   }  }          A utility class is a Java class that contains only class methods and class fields.  You have seen another example in CS2030,  Math , and will see a few more in this module.\u00a0 \u21a9    Unlike earlier figures, I didn't show the class metadata and method tables for simplicity.\u00a0 \u21a9    This is not that difference from how an OS handles function call in a machine code, as you will see in CS2100/CS2106.\u00a0 \u21a9    The other things are JVM implementation independent and not relevant to our discussion here.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec05/index.html",
            "text": "Lecture 5: Generics and Collections\n\n\nLearning Outcomes\n\n\n\n\nBe able to understand the difference between concrete class, abstract class, and interface with default methods\n\n\nAppreciate why generics is helpful\n\n\nBe able to create a generic class with one or more type parameters, and instantiate the parameterized type(s) by passing in type argument(s).\n\n\nUnderstand the subtype relationships between generic classes\n\n\nUnderstand type erasure, generic methods, wildcard types, bounded wildcard types.\n\n\nFamiliar with wrapper classes with primitives and autoboxing/unboxing; when to use primitive types and when to use wrapper classes\n\n\nFamiliar with Java collection frameworks: \nSet\n, \nList\n, \nMap\n and their concrete class \nHashSet\n, \nLinkedList\n, \nArrayList\n, and \nHashMap\n.\n\n\nAware of the other classes in Java Collection and is comfortable to look them up by reading the Java documentation.\n\n\nUnderstand there are differences between the collection classes and know when to use which one\n\n\n\n\nAbstract Class and Interface with Default Methods\n\n\nWe have seen how a class can inherit from a parent class, and implement one or more interfaces.  So far, the parent class that we have seen is a \nconcrete\n class -- it has fields and methods, complete with method implementation.  Such concrete parent class can be instantiated into objects.   \n\n\nOn the other hand, we have \npure\n interfaces, which is completely virtual or abstract.  It declares what public methods it should provide -- together with, for each method, the return type, the exception(s) it throws, and its method signature.  It can only have constant fields\n1\n and no implementation.\n\n\nBetween these two extremes, there are two other possibilities in Java:\n\n\n\n\nAn \nabstract class\n, which is just like a class, but it is declared as \nabstract\n, and some of its methods are declared as \nabstract\n, without implementation.  An abstract class cannot be instantiated, and any subclass who wish to be concrete needs to implement these abstract methods.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nabstract\n \nclass\n \nPaintedShape\n \n{\n\n  \nColor\n \nfillColor\n;\n\n    \n:\n\n  \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n    \nfillColor\n \n=\n \nc\n;\n\n  \n}\n\n    \n:\n\n  \nabstract\n \ndouble\n \ngetArea\n();\n\n  \nabstract\n \ndouble\n \ngetPerimeter\n();\n\n    \n:\n\n\n}\n\n\n\n\n\n\nAn interface with default implementations.  Introduced only in Java 8, with the goal of allowing an interface to evolve, an interface can now contain default implementation of its methods.  Such interface still cannot be instantiated into objects, but classes that implement such interface need not provide an implementation for a method where a default implementation exists.  For instance, we can have:\n\n1\n2\n3\n4\n5\n6\n7\n8\ninterface\n \nShape\n \n{\n\n  \npublic\n \ndouble\n \ngetArea\n();\n\n  \npublic\n \ndouble\n \ngetPerimeter\n();\n\n  \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n);\n\n  \ndefault\n \npublic\n \nboolean\n \ncover\n(\nPoint\n \np\n)\n \n{\n\n    \nreturn\n \ncontains\n(\np\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nwhere \ncover\n is a new method with default implementation, denoted with keyword \ndefault\n.  \n\n\n\n\nThe reason Java 8 introduced default methods for interface is for backward compatibility.  For instance, the implementer of \nShape\n can add \ncover\n to a new version of interface \nShape\n without breaking all the existing code that implements \nShape\n.\n\n\nAbstract class, however, should be used in general in the design of a class hierarchy -- in a case where it is more meaningful for the subclass to implement its own method than the superclass.  For example, in the \nPaintedShape\n abstract class above, it can implement the methods related to styles, but it is not meaningful to provide an implementation of \ngetArea\n and \ngetPerimeter\n. We will see more examples of abstract class later.\n\n\nGenerics\n\n\nNow let's move on to the topic of generics.\nSuppose you want to create a new class that encapsulates a queue of circles.  You wrote:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nCircleQueue\n \n{\n\n  \nprivate\n \nCircle\n[]\n \ncircles\n;\n\n   \n:\n\n  \npublic\n \nCircleQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull() {\n...}\n\n  \npublic\n \nboolean\n \nisEmpty() {\n...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nCircle\n \nc\n)\n \n{...}\n\n  \npublic\n \nCircle\n \ndequeue() {\n...}\n\n\n}\n\n\n\n\n\n\n\nLater, you found that you need a new class that encapsulates a queue of points.  You wrote:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nPointQueue\n \n{\n\n  \nprivate\n \nPoint\n[]\n \npoints\n;\n\n   \n:\n\n  \npublic\n \nPointQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull() {\n...}\n\n  \npublic\n \nboolean\n \nisEmpty() {\n...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nPoint\n \np\n)\n \n{...}\n\n  \npublic\n \nPoint\n \ndequeue() {\n...}\n\n\n}\n\n\n\n\n\n\nAnd you realize that there are actually a lot of similar code.  Invoking the \nabstraction principle\n, which states that \n\"Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts\n\", you decided to create a queue of Objects to replace the two classes above.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nObjectQueue\n \n{\n\n  \nprivate\n \nObject\n[]\n \nobjects\n;\n\n   \n:\n\n  \npublic\n \nObjectQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nObject\n \no\n)\n \n{...}\n\n  \npublic\n \nObject\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nNow you have a very general class, that you can use to store objects of any kind, including a queue of strings, a queue of colors, etc.  You are quite pleased with yourself, as you should!  The early Java collection library contains many such generic data structures that stores elements of type \nObject\n.\n\n\nTo create a queue of 10 circles and add some circles, you just need:\n\n1\n2\n3\n4\nObjectQueue\n \ncq\n \n=\n \nnew\n \nObjectQueue\n(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n5\n));\n\n \n:\n\n\n\n\n\n\nGetting a circle out of the queue is a bit more troublesome:\n\n1\nCircle\n \nc\n \n=\n \ncq\n.\ndequeue\n();\n\n\n\n\n\nWould generate a compilation error, since we are trying to perform a narrowing reference conversion -- we cannot assign a variable of type \nObject\n to a variable of type \nCircle\n without type casting:\n\n\n1\nCircle\n \nc\n \n=\n \n(\nCircle\n)\ncq\n.\ndequeue\n();\n\n\n\n\n\n\n\nAs we have seen in \nLecture 4\n, the code above might generate a runtime \nClassCastException\n if there is an object in the queue that is not \nCircle\n or its subclass.  To avoid runtime error, we should check the type first:\n\n\n1\n2\n3\n4\nObject\n \no\n \n=\n \ncq\n.\ndequeue\n();\n\n\nif\n \n(\no\n \ninstanceof\n \nCircle\n)\n \n{\n\n    \nCircle\n \nc\n \n=\n \n(\nCircle\n)\no\n;\n\n\n}\n\n\n\n\n\n\n\nWouldn't it be nice if we can still have code that is general, but we let the compiler generates an error if we try to add a non-\nCircle\n into our queue of \nCircle\n objects, so that we don't have to check for the type of an object all the time?\n\n\nJava 5 introduces generics, which is a significant improvement to the type systems in Java.  It allows a \ngeneric class\n or a \ngeneric interface\n of some type \nT\n to be written:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nprivate\n \nT\n[]\n \nobjects\n;\n\n   \n:\n\n  \npublic\n \nQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nT\n \no\n)\n \n{...}\n\n  \npublic\n \nT\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nT\n is known as \ntype parameter\n.\nThe same code as before can be written as:\n\n\n1\n2\n3\n4\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n<\nCircle\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n5\n));\n\n\nCircle\n \nc\n \n=\n \ncq\n.\ndequeue\n();\n\n\n\n\n\n\n\nHere, we pass \nCircle\n as the \ntype argument\n to \nT\n, creating a \nparameterized type\n \nQueue<Circle>\n.\n\n\nIn Line 4, we no longer need to cast, and there is no danger of runtime error due to an object of the wrong class being added to the queue, for doing this:\n\n1\n2\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n<\nCircle\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nPoint\n(\n1\n,\n \n3\n));\n\n\n\n\n\nwill generate a compile-time error.\n\n\nGeneric typing is a type of polymorphism as well and is also known as \nparametric polymorphism\n.\n\n\n\n\nIn Other Languages\n\n\nMany modern programming languages support generics: C++ (known as \ntemplate\n), Swift, Kotlin, C#, etc. For dynamically typed languages such as Python, one can already write generic code without regards to the type of the variables, so generic is kinda \"build in\".  In C (the 2011 version, C11), there is a \n_Generic\n expression, which is not to be confused with generics we are talking about here.\n\n\n\n\nWe can use parameterized type anywhere a type is used, including as type argument.  If we want to have a queue of a queue of circles, we can:\n\n\n1\nQueue\n<\nQueue\n<\nCircle\n>>\n \ncqq\n \n=\n \nnew\n \nQueue\n<>(\n10\n);\n\n\n\n\n\n\n\nVariance of Generic Types\n\n\nIn \nLecture 4\n, we discuss about subtypes and the variance of types.  Recall that \nT\nT\n is a subtype of \nS\nS\n if everywhere we use \nS\nS\n, we can substitute with \nT\nT\n.  \n\n\nSuppose a class or interface \nB\n is a subtype of \nA\n, then \nB<T>\n is also a subtype of \nA<T>\n, i.e., they are covariant.\n\n\nGenerics, however, are \ninvariant\n, with respect to the type parameter.  That is, if a class or interface \nB\n is a subtype of \nA\n, then neither is \nC<B>\n a subtype of \nC<A>\n, nor is \nC<A>\n a subtype of \nC<B>\n.  A parameterized type must be used with exactly with same type argument.  For instance:\n\n\n1\n2\n3\nQueue\n<\nCircle\n>\n \nqc\n \n=\n \nnew\n \nQueue\n<\nShape\n>();\n  \n// error\n\n\nQueue\n<\nShape\n>\n \nqs\n \n=\n \nnew\n \nQueue\n<\nCircle\n>();\n \n// error\n\n\nQueue\n<\nShape\n>\n \nqs\n \n=\n \n(\nQueue\n<\nShape\n>)\n \nnew\n \nQueue\n<\nCircle\n>();\n \n// error\n\n\n\n\n\n\n\nwill lead to compile-time error.  Attempting to type cast just like when we do a narrowing reference conversion will fail as well.\n\n\nWildcards\n\n\nSubtyping among generic types are achieved through wildcard types \n?\n.  \n?\n itself is not a type, but a notation to denote variance of generic types.  We can replace type parameter \nT\n with \n?\n, to indicate that \nT\n can be any type.  This creates a subtype relationship.  For instance, \nQueue<Shape>\n is a subtype of \nQueue\n<?\n>\n, \nQueue<Object>\n is a subtype of \nQueue\n<?\n>\n.\n\n\n1\nQueue\n<?\n>\n \nqc\n \n=\n \nnew\n \nQueue\n<\nShape\n>\n();\n   \n// OK\n\n\n\n\n\n\n\nSince the wildcard \n?\n is not a type, we cannot declare a class like this:\n\n1\n2\n3\nclass\n \nBar\n<?>\n \n{\n\n    \nprivate\n \n?\n \nx\n;\n\n\n}\n\n\n\n\n\n\nWe only use \n?\n when specifying the type of a variable, field, or parameter.\n\n\nWildcards can be bounded.  Java uses the keyword \nextends\n and \nsuper\n to specify the bound.  For instance, \nQueue<Circle>\n and \nQueue<Shape>\n are both subtypes of \nQueue\n<?\n \nextends\n \nShape\n>\n, but \nQueue<Object>\n is not a subtype of \nQueue\n<?\n>\n \nQueue\n<?\n \nextends\n \nShape\n>\n.\n\n\nTo be more general, if \nT\n is a subtype of \nS\n, then \nQueue<T>\n is a subtype of \nQueue\n<?\n \nextends\n \nS\n>\n.  In other words, the use of \n? extends\n is covariant.  Further, \nQueue\n<?\n \nextends\n \nT\n>\n is a subtype of \nQueue\n<?\n \nextends\n \nS\n>\n.\n\n\nThe \nsuper\n keyword is used to specify the contravariant relationship.\nIf \nT\n is a subtype of \nS\n, then \nQueue<S>\n is a subtype of \nQueue\n<?\n \nsuper\n \nT\n>\n.  \n\n\nMore intuitively, we can replace \n? extends X\n with type X or any subtype that extends X; \n? super X\n with type X or any supertype of X.\n\n\n\n\nWildcard type in Other Languages\n\n\nThe use of wildcard type \n?\n is not common in other programming languages.  Partly because Java introduces generics late and has to use type erasure to implement generic types.\n\n\n\n\nType Erasure\n\n\nIn Java, for backward compatibility, generic typing is implemented with a process called \ntype erasure\n.  The type argument is erased during compile time, and the type parameter \nT\n is replaced with either \nObject\n (if it is unbounded) or the bound (if it is bounded). For instance, \nQueue<Circle>\n will be replaced by \nQueue\n and \nT\n will be replaced by \nObject\n, just like how Java code is written before generic type is introduced in Java 5.  \nQueue\n<?\n \nextends\n \nShape\n>\n will be replaced with \nQueue\n and \nT\n will be replaced with \nShape\n.  The compiler also inserts type casting and additional methods\n2\n to preserve the semantics of generic type.\n\n\nJava's design decision to use type erasure to implement generics has several important implications.  \n\n\nFirst, unlike other languages, such as C++, Java does not support generics of a primitive type.  We cannot create a \nQueue<int>\n, for instance.  We can only use reference types as type argument (anything that is a subtype of \nObject\n).\n\n\nSecond, we cannot have code that looks like the following:\n\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \nvoid\n \nfoo\n(\nQueue\n<\nCircle\n>\n \nc\n)\n \n{}\n\n  \nvoid\n \nfoo\n(\nQueue\n<\nPoint\n>\n \nc\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n\nEven though both \nfoo\n above seem like they have different method signatures and is a valid application of method overloading, the compiler actually translates them both to:\n\n\n1\n2\n3\n4\nclass\n \nA\n \n{\n\n  \nvoid\n \nfoo\n(\nQueue\n \nc\n)\n \n{}\n\n  \nvoid\n \nfoo\n(\nQueue\n \nc\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n\nand bummer, we have a compilation error!\n\n\nThird, using static methods or static fields in generic class becomes trickier.\n\n\nConsider the example \n\n1\n2\n3\n4\n5\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nstatic\n \nint\n \nx\n \n=\n \n1\n;\n\n  \nstatic\n \nT\n \ny\n;\n\n  \nstatic\n \nT\n \nfoo\n(\nT\n \nt\n)\n \n{};\n\n\n}\n\n\n\n\n\n\nQueue<Circle>\n and \nQueue<Point>\n both gets compiled to \nQueue\n.  So they share the same \nx\n, even though you might think \nQueue<CIrcle>\n and \nQueue<Point>\n as two different distinct classes.  \n\n\nFurther, the next two liens \nstatic T y\n and \nstatic T foo(T t) {}\n will generate a compilation error.  Since there will only be a copy of \ny\n shared by both \nQueue<Circle>\n and \nQueue<Point>\n, the compiler does not know whether to replace \nT\n with \nCircle\n or \nPoint\n, and will complain.\n\n\nFourth, we cannot create an array of parameterized types.\n\n\n1\n2\n3\nQueue\n<\nCircle\n>[]\n \ntwoQs\n \n=\n \nnew\n \nQueue\n<\nCircle\n>[\n2\n];\n \n// compiler error\n\n\ntwoQs\n[\n0\n]\n \n=\n \nnew\n \nQueue\n<\nCircle\n>();\n\n\ntwoQs\n[\n1\n]\n \n=\n \nnew\n \nQueue\n<\nPoint\n>();\n\n\n\n\n\n\n\nAfter type erasure, we get\n\n1\n2\n3\nQueue\n[]\n \ntwoQs\n \n=\n \nnew\n \nQueue\n[\n2\n];\n \n// compiler error\n\n\ntwoQs\n[\n0\n]\n \n=\n \nnew\n \nQueue\n();\n\n\ntwoQs\n[\n1\n]\n \n=\n \nnew\n \nQueue\n();\n\n\n\n\n\n\nIf Java would have allowed us to create an array of a parameterized type, then we could have added an element of incompatible type \nQueue<Point>\n into an array of \nQueue<Circle>\n without raising a run-time error.  \n\n\nGenerics in Java is added as an afterthought and to maintain backward compatibility, the compiler has to erase the type parameter during compile type.  During runtime, the type information is no longer available, and this design causes the quirks above.\n\n\nRaw Types\n\n\nOne final note: for backward compatibility, Java allows us to use a generic class to be used without the type argument.  For instance, even though we declare \nQueue<T>\n, we can just use \nQueue\n.  \n\n\n1\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n();\n\n\n\n\n\n\n\nAfter all, during compile time, \nQueue<Circle>\n is translated into \nQueue\n anyway.  In Java 5 or later, if we just use \nQueue\n, we get a \nQueue\n of \nObject\ns.  This is called a \nraw type\n.  Recent Java compilers will warn you if you use a raw type in your code.  \n\n\nWrapper Classes\n\n\nWe can get around the problem of not being able to create generics of primitive types using wrapper classes.  Java provides a set of wrapper classes, one for each primitive type: \nBoolean\n, \nByte\n, \nCharacter\n, \nInteger\n, \nDouble\n, \nLong\n, \nFloat\n, and \nShort\n.\n\n\n1\n2\n3\n4\nQueue\n<\nInteger\n>\n \niq\n \n=\n \nnew\n \nQueue\n<\nInteger\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n4\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n8\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n15\n));\n\n\n\n\n\n\n\nJava 5 introduces something called \nautoboxing\n and \nunboxing\n, which creates the wrapper objects automatically (autoboxing) and retrieves its value (unboxing) automatically.  With autoboxing and unboxing, we can just write:\n\n\n1\n2\n3\n4\nQueue\n<\nInteger\n>\n \niq\n \n=\n \nnew\n \nQueue\n<\nInteger\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\n4\n);\n\n\ncq\n.\nenqueue\n(\n8\n);\n\n\ncq\n.\nenqueue\n(\n15\n);\n\n\n\n\n\n\n\nNote that \nenqueue\n expects an \nInteger\n object, but we pass in an \nint\n.  This would cause the \nint\n variable to automatically be boxed (i.e., be wrapped in Integer object) and put onto the call stack of \nenqueue\n.\n\n\nPerformance Penalty\n\n\nIf the wrapper class is so great, why not use it all the time and forget about primitive types?\n\n\nThe answer: performance.  Because using an object comes with the cost of allocating memory for the object and collecting of garbage afterward, it is less efficient than primitive types.  Consider the following two programs:\n\n\n1\n2\n3\n4\n5\nDouble\n \nsum\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nInteger\n.\nMAX_VALUE\n;\n \ni\n++)\n\n\n{\n\n    \nsum\n \n+=\n \ni\n;\n\n\n}\n\n\n\n\n\nvs.\n\n1\n2\n3\n4\n5\ndouble\n \nsum\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nInteger\n.\nMAX_VALUE\n;\n \ni\n++)\n\n\n{\n\n    \nsum\n \n+=\n \ni\n;\n\n\n}\n\n\n\n\n\n\nThe second one is 2 times faster!  Due to autoboxing and unboxing, the cost of creating objects become hidden and often forgotten.\n\n\nAll primitive wrapper class objects are immutable -- once you create an object, it cannot be changed.  Thus, every time \nsum\n in the example above is updated, a new object gets created.\n\n\nGeneric Methods\n\n\nWe can get around the problem of not being able to define static methods using generic methods.  Generic methods are just like generic type, but the scope of the type parameter is limited to only the method itself.\n\n\n1\n2\n3\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nstatic\n \n<\nT\n>\n \nT\n \nfoo\n(\nT\n \nt\n)\n \n{\n \nreturn\n \nt\n;\n \n};\n\n\n}\n\n\n\n\n\n\n\nThe above would compile.  Note that the \n<T>\n in \nstatic <T> T foo(T t)\n effectively declares a new type parameter \nT\n, scoped to the method \nfoo\n, and has nothing to do with the type parameter \n<T>\n for \nQueue<T>\n. \n\n(Recall that, since \nfoo\n is static and is associated with the class \nQueue\n).\n\n\nAs a convention, it is common to use the single letter \nT\n here, which may be confusing.  We can actually use any other single letter to represent the type parameter.\n\n1\n2\n3\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nstatic\n \n<\nX\n>\n \nX\n \nfoo\n(\nX\n \nt\n)\n \n{\n \nreturn\n \nt\n;\n \n};\n\n\n}\n\n\n\n\n\n\nTo invoke a generic method, we can call it like this:\n\n1\nQueue\n.<\nPoint\n>\nfoo\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n));\n\n\n\n\n\n\nor simply:\n\n1\nQueue\n.\nfoo\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n));\n\n\n\n\n\n\nType Inference\n\n\nIn the last example, Java compiler uses \ntype inference\n to determine what \nT\n should be: in this case, we are passing in a \nPoint\n object, so \nT\n should be replaced with \nPoint\n.\n\n\nType inference can also be used with constructors.\n\n1\nQueue\n<\nPoint\n>\n \nq\n \n=\n \nnew\n \nQueue\n<>();\n\n\n\n\n\n\nIn the line above, we use the \ndiamond operator\n \n<>\n to ask Java to fill in the type for us.  Again, type inference allows Java to infer that we are creating a \nPoint\n object.\n\n\nIn cases where the type inference finds multiple matching types, the most specific type is chosen.\n\n\n\n\nLocal variable type inference in Java 10\n\n\nJava 10, which is scheduled to be released next month, supports type inference for a local variable.  We can write\n\n1\nvar\n \nq\n \n=\n \nnew\n \nQueue\n<\nPoint\n>();\n\n\n\n\n\nand Java 10 compiler can infer that q should have the type \nQueue<Point>\n.\n\n\n\n\nJava Collections\n\n\nNow, we turn our attention to the Java Collection Framework.  Java provides a rich set of classes for managing and manipulating data.  They efficiently implement many useful data structures (hash tables, red-black trees, etc.) and algorithms (sorting, searching, etc.) so that we no longer have to.  As computer scientists, it is still very important for us to know how these data structures and algorithms can be implemented, how to prove some behaviors (such as running time) and their correctness, how certain trade-offs are made, etc. They are so important that we have two modules dedicated to them, CS2040 and CS3230, in the core CS curriculum.\n\n\nIn CS2030, however, we will only use them but not study how to implement them.  Most importantly, Java Collection Framework is mostly well-designed and serves as real-world examples of how all the OO principles and programming language concepts are used.  We can see how all the things that we have learned so far is applied.\n\n\nCollection\n\n\nOne of the basic interfaces in Java Collection Framework is \nCollection<E>\n, it looks like:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\npublic\n \ninterface\n \nCollection\n<\nE\n>\n \nextends\n \nIterable\n<\nE\n>\n \n{\n\n  \nboolean\n \nadd\n(\nE\n \ne\n);\n\n  \nboolean\n \ncontains\n(\nObject\n \no\n);\n\n  \nboolean\n \nremove\n(\nObject\n \no\n);\n\n  \nvoid\n \nclear\n();\n\n  \nboolean\n \nisEmpty\n();\n\n  \nint\n \nsize\n();\n\n\n  \nObject\n[]\n \ntoArray\n();\n\n  \n<\nT\n>\n \nT\n[]\n \ntoArray\n(\nT\n[]\n \na\n);\n\n\n  \nboolean\n \naddAll\n(\nCollection\n<?\n \nextends\n \nE\n>\n \nc\n);\n\n  \nboolean\n \ncontainsAll\n(\nCollection\n<?>\n \nc\n);\n\n  \nboolean\n \nremoveAll\n(\nCollection\n<?>\n \nc\n);\n\n  \nboolean\n \nretainAll\n(\nCollection\n<?>\n \nc\n);\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThere are some newly added methods in Java 8 that we will visit in the second half of this module, but first,\nlet's try to understand what the definition above means.  First, like a generic class that you have seen, \nCollection\n is a \ngeneric interface\n parameterized with a type parameter \nE\n.  It extends a generic \nIterable<E>\n interface (we will get to this later).\n\n\nThe first six methods of \nCollection<E>\n should be self-explanatory.  \nadd\n adds an element into the collection; \ncontains\n checks if a given object is in the collection;  \nremove\n removes a single instance of the given object from the collection;  \nclear\n removes all objects from the collection;  \nisEmpty()\n checks if the collection has no elements or not; and finally, \nsize\n returns the number of elements.\n\n\nNote that \ncontains()\n relies on the implementation of \nequals()\n to check if the object exists in the collection or not.  Similarly, \nremove()\n relies on \nequals()\n to find the matching objects.  We said earlier that it is useful to override the \nequals\n methods of \nObject\n instead of implementing our own \nequals\n, because the overridden \nequals()\n will be called elsewhere.  This is one of the \"elsewhere\" I mentioned.  The documentation of \ncontains(o)\n mentions that it is guaranteed to return \ntrue\n if there exists an element \ne\n such that \ne.equals(o)\n or \ne == null\n (if \no == null\n).  Ditto for \nremove(o)\n.\n\n\n\n\nNon-generic Methods\n\n\nYou might notice that, instead of \ncontains(E e)\nand \nremove(E e)\n, the \nCollection\n interface uses \ncontains(Object o)\n and \nremove(Object o)\n.  This little inconsistency, however, is harmless.  For instance, if you have a collection intended for circles only, adding a non-circle could be disastrous.  Trying to remove a non-circle or checking for a non-circle, would just return false.\nMore information can be found on this \nStackOverflow\n thread.\n\n\n\n\nJava Collection Framework allows classes that implement an interface to throw an \nUnsupportedOperationException\n if the implementation decides not to implement one of the operations (but still need to have the method in the class).\n\n\nThe method \ntoArray()\n on Line 9 returns an array containing all the elements inside this collection.  The second overloaded \ntoArray\n method takes in an array of generic type \nT\n.  If the collections fit in \na\n, \na\n is filled and returned.  Else, it allocates a new array of type \nT\n and returned.\n\n\nThe second \ntoArray\n method is an example of a generic method.  It is the caller responsibility to pass in the right type, otherwise, an \nArrayStoreException\n will be thrown.\n\n\nThe next group of methods operates on another collection.  \naddAll\n add all the elements of collection \nc\n into the current collection; \ncontainsAll\n checks if all the elements of collection \nc\n are contained in the current collection; \nremoveAll\n removes all elements from collection \nc\n, and finally, \nretainsAll\n remove all elements not in \nc\n.\n\n\nWhat is more interesting about the methods is the type of \nc\n.  In \ncontainsAll\n, \nremoveAll\n, and \nretainAll\n, the collection \nc\n has the type \nCollection\n<?\n>\n.  Recall that \nCollection\n<?\n>\n is a supertype of \nCollection<T>\n, whatever \nT\n is.  So, we can pass in a \nCollection\n of any reference type to check for equality.  In this case, we are not adding anything to the collection, so the type of \nc\n is set to be as general as possible.\n\n\nIn \naddAll\n, however, \nc\n is declared as \nCollection\n<?\n \nextends\n \nE\n>\n.  Since we are adding to the collection, we can only add elements that either has the type \nE\n or a type that is a subtype of \nE\n.  This constraint is enforced during compile time through the covariance relationship between \nCollection\n<?\n \nextends\n \nE\n>\n and \nCollection<E>\n.\n\n\n\n\nIterable\n\n\nThe \nIterable<E>\n interface provides only a single method, \nIterator<E> iterator()\n, which returns a generic interface called \nIterator<E>\n over the collection.  An \nIterator\n is another interface that allows us to go through all the elements in a \nCollection<E>\n.  Useful methods include \nhasNext()\n, which returns if there is a next element in the \nCollection<E>\n; \nnext()\n, which returns the next element (with parameterized type \nE\n); and \nremove()\n, which removes the last returned element from the \nCollection<E>\n.\n\n\n\n\nSo far we have not seen any example code using \nCollection\n.  This is because Java Collection Framework does not provide a class that implements the \nCollection<E>\n directly.  The documentation recommends that we implement the \nCollection<E>\n interface\n3\n if we want a collection of objects that allows duplicates and does not care about the orders.\n\n\nSet and List\n\n\nThe \nSet<E>\n and \nList<E>\n interfaces extend the \nCollection<E>\n interface.  \nSet<E>\n is meant for implementing a collection of objects that does not allow duplicates (but still does not care about order of elements), while \nList<E>\n is for implementing a collection of objects that allow duplicates, but the order of elements matters.\n\n\nMathematically, a \nCollection<E>\n is used to represent a bag, \nSet<E>\n, a set, and \nList<E>\n, a sequence.\n\n\nThe \nList<E>\n interface has additional methods for adding and removing elements.  \nadd(e)\n by default would just add to the end of the list.  \nadd(i, e)\n inserts \ne\n to position \ni\n.  \nget(i)\n returns the element at position \ni\n, \nremove(i)\n removes the elements at position \ni\n; \nset(i,e)\n replace the \ni\n-th element with \ne\n.\n\n\nUseful classes in Java collection that implement \nList<E>\n include \nArrayList\n and \nLinkedList\n, and useful classes that implement \nSet<E>\n include \nHashSet\n.\n\n\nLet's see some examples:\n\n\n1\n2\n3\n4\n5\nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nArrayList\n();\n\n\nnames\n.\nadd\n(\n\"Cersei\"\n);\n\n\nnames\n.\nadd\n(\n\"Joffrey\"\n);\n\n\nnames\n.\nadd\n(\n0\n,\n \n\"Gregor\"\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\nnames\n.\nget\n(\n1\n));\n\n\n\n\n\n\n\nLine 1 above creates an empty array list.  The second line adds two strings into the list, each appending them to the list.  After executing Line 3, it would contain the sequence \n<\"Cersei\",\"Joffrey\">\n.  Line 4 inserts the string \n\"Gregor\"\n to position 0, moving the rest of the list down by 1 position.  The sequence is now \n<\"Gregor\",\"Cersei\",\"Joffrey\">\n.  Finally, calling \nget(1)\n would return the string \n\"Cersei\"\n.\n\n\nNote that we declare \nnames\n with the interface type \nList<String>\n.  We should always do this to keep our code flexible.  If we want to change our implementation to \nLinkedList\n, we only need to change Line 1 to:\n\n1\nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nLinkedList\n();\n\n\n\n\n\n\nComparator\n\n\nThe \nList<E>\n interface also specifies a \nsort\n method, with the following specification:\n\n1\ndefault\n \nvoid\n \nsort\n(\nComparator\n<?\n \nsuper\n \nE\n>\n \nc\n)\n\n\n\n\n\n\nList<E>\n is an example of an interface with default method.  The keyword \ndefault\n indicates that the interface \nList<E>\n comes with a default \nsort\n implementation, so a class that implements the interface needs not implement it again unless the class wants to override the method.\n\n\nThis method specification is also interesting and worth looking closer.  It takes in an object \nc\n with generic interface \nComparator\n<?\n \nsuper\n \nE\n>\n.  The \nComparator\n interface allows us to specify how to compare two elements, by implementing a \ncompare()\n method.  \ncompare(o1,o2)\n should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise.\n\n\nLet's write \nComparator\n class\n4\n:\n\n\n1\n2\n3\n4\n5\nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n    \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n        \nreturn\n \ns1\n.\ncompareTo\n(\ns2\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nIn the above, we use the \ncompareTo\n method provided by the \nString\n class to do the comparison.  With the above, we can now sort the \nnames\n:\n\n\n1\nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n\n\n\n\n\n\nThis would result in the sequence being changed to \n<\"Cersei\",\"Gregor\",\"Joffrey\">\n.  We can easily change how we want to sort the names, for instance, to\n\n1\n2\n3\n4\n5\nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n    \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n        \nreturn\n \ns1\n.\nlength\n()\n \n-\n \ns2\n.\nlength\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nif we want to sort by the length of the names.\n\n\nOne last thing to note about the method \nsort\n is that it takes in \nComparator\n<?\n \nsuper\n \nE\n>\n that is contravariant.  Recall that \nComparator<Object>\n is a subtype of \nComparator\n<?\n \nsuper\n \nE\n>\n, so we can pass in more general \nComparator\n object to \nsort\n (e.g., a class that implements \nComprator<Object>\n \n\n\nMap\n\n\nOne of the more powerful data structures provided by Java Collection is maps (also known as a dictionary in other languages).  A map allows us to store a (unique key, value) pair into the collection, and retrieve the value later by looking up the key.\n\n\nThe \nMap<K,V>\n interface is again generic, but this time, has two type parameters, \nK\n for the type of the key, and \nV\n for the type of the value.  These parameters make the \nMap\n interface flexible -- we can use any type as the key and value.\n\n\nThe two most important methods for \nMap\n is \nput\n and \nget\n:\n\n\n1\n2\n    \nV\n \nput\n(\nK\n \nkey\n,\n \nV\n \nvalue\n);\n\n    \nV\n \nget\n(\nObject\n \nk\n);\n\n\n\n\n\n\n\nA useful class that implements \nMap\n interface is \nHashMap\n:\n\n\n1\n2\n3\n4\nMap\n<\nString\n,\nInteger\n>\n \npopulation\n \n=\n \nnew\n \nHashMap\n<\nString\n,\nInteger\n>();\n\n\npopulation\n.\nput\n(\n\"Oldtown\"\n,\n500000\n);\n\n\npopulation\n.\nput\n(\n\"Kings Landing\"\n,\n500000\n);\n\n\npopulation\n.\nput\n(\n\"Lannisport\"\n,\n300000\n);\n\n\n\n\n\n\n\nLater, if we want to lookup the value, we can:\n\n1\npopulation\n.\nget\n(\n\"Kings Landing\"\n);\n\n\n\n\n\n\nWhich Collection Class?\n\n\nJava provides many collection classes, more than what we have time to go through.  It is important to know which one to use to get the best performance out of them.  For the few classes we have seen:\n\n\n\n\nUse \nHashMap\n if you want to keep a (key, value) pair for lookup later.\n\n\nUse \nHashSet\n if you have a collection of elements with no duplicates and order is not important.\n\n\nUse \nArrayList\n if you have a collection of elements with possible duplicates and order is important, and retrieving a specific location is more important than removing elements from the list.\n\n\nUse \nLinkedList\n if you have a collection of elements with possibly duplicates and order is important, retriving a specific location is less important than removing elements from the list.\n\n\n\n\nYou should understand the reasons above after CS2040.\n\n\nFurther, if you want to check if a given object is contained in the list, then \nArrayList\n and \nLinkedList\n are not good candidates.  \nHashSet\n, on the other hand, can quickly check if an item is already contained in the set.  There is, unfortunately, no standard collection class that supports fast \ncontain\n and allow duplicates.  \n\n\nExercise\n\n\n\n\n\n\nConsider the following code snippet:\n    \n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\ninterface\n \nI\n \n{\n\n  \nvoid\n \nf\n();\n\n  \ndefault\n \nvoid\n \ng\n()\n \n{\n \n  \n}\n\n\n}\n\n\n\nabstract\n \nclass\n \nA\n \nimplements\n \nI\n \n{\n\n  \nabstract\n \nvoid\n \nh\n();\n\n  \nabstract\n \nvoid\n \nh\n(\nint\n \nx\n);\n\n  \nvoid\n \nj\n()\n \n{\n\n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\nClass \nB\n is a concrete class.  What are the methods that \nB\n needs to implement?\n\n\n\n\n\n\nFor each of the statement below, indicate if it is a valid statement (no compilation error). Explain why in one sentence.\n\n\n\n\nList\n<?\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<\nString\n>\n();\n\n\nList\n<?\n \nsuper\n \nInteger\n>\n \nlist\n \n=\n \nnew\n \nList\n<\nObject\n>\n();\n\n\nList\n<?\n \nextends\n \nObject\n>\n \nlist\n \n=\n \nnew\n \nLinkedList\n<\nObject\n>\n();\n\n\nList\n<?\n \nsuper\n \nInteger\n>\n \nlist\n \n=\n \nnew\n \nLinkedList\n<>\n();\n\n\n\n\n\n\n\n\nConsider a generic class \nA<T>\n with a type parameter \nT\n and a constructor with no argument.  Which of the following statements are valid (i.e., no compilation error) ways of creating a new object of type \nA\n? We still consider the statement as valid if the Java compiler produces a warning.\n\n\n\n\nnew A<int>();\n\n\nnew A<>();\n\n\nnew A();\n\n\n\n\n\n\n\n\nIn this question, we will explore the more strange behavior of \nInteger\n class.\n\n\nRemember that \n==\n compares only references: whether the two references are pointing to the same object or not.   The \nequals\n method has been overridden to compare if the values are the same or not.  Try the following in \njshell\n:\n\n\n1\n2\n3\nInteger\n \nx\n \n=\n \n1\n;\n\n\nInteger\n \ny\n \n=\n \n1\n;\n\n\nx\n \n==\n \ny\n;\n\n\n\n\n\n\n\nWhat do you expect the comparison \n==\n to return?  What did it return?\n\n\nNow try:\n\n\n1\n2\n3\nInteger\n \nx\n \n=\n \n1000\n;\n\n\nInteger\n \ny\n \n=\n \n1000\n;\n\n\nx\n \n==\n \ny\n;\n\n\n\n\n\n\n\nWhat do you expect it to return?  What did it return?\n\n\nLook up on the Internet (e.g., StackOverflow) on why this happens.  (Hint: \nInteger\n caching)\n\n\nThe moral of the story here is to always use \nequals\n to compare two reference variables.\n\n\n\n\n\n\nConsider a method declared as \nint foo(double x)\n Which of the following statements will NOT result in a compilation error:\n\n\n\n\nint cs = foo(2030);\n\n\ndouble cs = foo(2.030);\n\n\nint cs = foo(new Double(2.030));\n\n\nInteger cs = foo(new Double(2.030));\n\n\n\n\n\n\n\n\nIn this question, we will explore the behavior of \nArrayList\n class and autoboxing/unboxing.  Will the following code compile?  If so, what will be printed?\n\n\n(a) \n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nList\n<\nInteger\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<>();\n\n\nint\n \none\n \n=\n \n1\n;\n\n\nInteger\n \ntwo\n \n=\n \n2\n;\n\n\n\nlist\n.\nadd\n(\none\n);\n\n\nlist\n.\nadd\n(\ntwo\n);\n\n\nlist\n.\nadd\n(\n3\n);\n\n\n\nfor\n \n(\nInteger\n \nnum\n \n:\n \nlist\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\nnum\n);\n\n\n}\n\n\n\n\n\n\n(b)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nList\n<\nInteger\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<>();\n\n\nint\n \none\n \n=\n \n1\n;\n\n\nInteger\n \ntwo\n \n=\n \n2\n;\n\n\n\nlist\n.\nadd\n(\none\n);\n\n\nlist\n.\nadd\n(\ntwo\n);\n\n\nlist\n.\nadd\n(\n3\n);\n\n\n\nfor\n \n(\nint\n \nnum\n \n:\n \nlist\n)\n \n{\n \n// Integer -> int\n\n  \nSystem\n.\nout\n.\nprintln\n(\nnum\n);\n\n\n}\n\n\n\n\n\n\n\u00a9\n\n1\n2\n3\n4\n5\nList\n<\nInteger\n>\n \nlist\n \n=\n \nArrays\n.\nasList\n(\n1\n,\n \n2\n,\n \n3\n);\n\n\n\nfor\n \n(\nDouble\n \nnum\n \n:\n \nlist\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\nnum\n);\n\n\n}\n\n\n\n\n\n\n(d)\n\n1\n2\n3\n4\n5\nList\n<\nInteger\n>\n \nlist\n \n=\n \nArrays\n.\nasList\n(\n1\n,\n \n2\n,\n \n3\n);\n\n\n\nfor\n \n(\ndouble\n \nnum\n \n:\n \nlist\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\nnum\n);\n\n\n}\n\n\n\n\n\n\n(e)\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nList\n<\nInteger\n>\n \nlist\n \n=\n \nnew\n \nLinkedList\n<>();\n\n\nlist\n.\nadd\n(\n5\n);\n\n\nlist\n.\nadd\n(\n4\n);\n\n\nlist\n.\nadd\n(\n3\n);\n\n\nlist\n.\nadd\n(\n2\n);\n\n\nlist\n.\nadd\n(\n1\n);\n\n\n\nIterator\n<\nInteger\n>\n \nit\n \n=\n \nlist\n.\niterator\n();\n\n\nwhile\n \n(\nit\n.\nhasNext\n())\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\nit\n.\nnext\n());\n\n\n}\n\n\n\n\n\n\n\n\n\n\nHere is another set of questions to explore about the behavior of autoboxing/unboxing and primitive type conversion.\n\n\n(a)\n\n1\n2\n3\n4\n5\ndouble\n \nd\n \n=\n \n5\n;\n\n\nint\n \ni\n \n=\n \n2.5\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n(b)\n\n1\n2\n3\n4\n5\ndouble\n \nd\n \n=\n \n(\nint\n)\n \n5\n;\n\n\nint\n \ni\n \n=\n \n(\ndouble\n)\n \n2.5\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n\u00a9\n\n1\n2\n3\n4\n5\ndouble\n \nd\n \n=\n \n(\nint\n)\n \n5.5\n;\n\n\nint\n \ni\n \n=\n \n(\nint\n)\n \n2.5\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n(d)\n\n1\n2\n3\n4\n5\nDouble\n \nd\n \n=\n \n5\n;\n\n\nInteger\n \ni\n \n=\n \n2.5\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n(e)\n\n1\n2\n3\n4\n5\nDouble\n \nd\n \n=\n \n(\ndouble\n)\n \n5\n;\n\n\nInteger\n \ni\n \n=\n \n(\nint\n)\n \n2.5\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n(f)\n\n1\n2\n3\n4\n5\ndouble\n \nd\n \n=\n \n(\nInteger\n)\n \n5\n;\n\n\nint\n \ni\n \n=\n \n(\nInteger\n)\n \n2\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n(g)\n\n1\n2\n3\n4\n5\ndouble\n \nd\n \n=\n \n(\nDouble\n)\n \n5\n;\n\n\nint\n \ni\n \n=\n \n(\nInteger\n)\n \n2\n;\n\n\n\nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis is widely considered as a bad practice (or \nanti-pattern\n), called the \nconstant interface anti-pattern\n.\u00a0\n\u21a9\n\n\n\n\n\n\nLook up bridge methods if you want to know the gory details.\u00a0\n\u21a9\n\n\n\n\n\n\nIf you want to do so, however, it is likely more useful to inherit from the abstract class \nAbstractCollection<E>\n (which implements most of the basic methods of the interface) rather than implementing the interface \nCollection<E>\n directly.\u00a0\n\u21a9\n\n\n\n\n\n\nLater in CS2030, you will see how we significantly reduce the verbosity of this code!  But let's do it the hard way first.\u00a0\n\u21a9",
            "title": "5. Generics and Collections"
        },
        {
            "location": "/lec05/index.html#lecture-5-generics-and-collections",
            "text": "",
            "title": "Lecture 5: Generics and Collections"
        },
        {
            "location": "/lec05/index.html#learning-outcomes",
            "text": "Be able to understand the difference between concrete class, abstract class, and interface with default methods  Appreciate why generics is helpful  Be able to create a generic class with one or more type parameters, and instantiate the parameterized type(s) by passing in type argument(s).  Understand the subtype relationships between generic classes  Understand type erasure, generic methods, wildcard types, bounded wildcard types.  Familiar with wrapper classes with primitives and autoboxing/unboxing; when to use primitive types and when to use wrapper classes  Familiar with Java collection frameworks:  Set ,  List ,  Map  and their concrete class  HashSet ,  LinkedList ,  ArrayList , and  HashMap .  Aware of the other classes in Java Collection and is comfortable to look them up by reading the Java documentation.  Understand there are differences between the collection classes and know when to use which one",
            "title": "Learning Outcomes"
        },
        {
            "location": "/lec05/index.html#abstract-class-and-interface-with-default-methods",
            "text": "We have seen how a class can inherit from a parent class, and implement one or more interfaces.  So far, the parent class that we have seen is a  concrete  class -- it has fields and methods, complete with method implementation.  Such concrete parent class can be instantiated into objects.     On the other hand, we have  pure  interfaces, which is completely virtual or abstract.  It declares what public methods it should provide -- together with, for each method, the return type, the exception(s) it throws, and its method signature.  It can only have constant fields 1  and no implementation.  Between these two extremes, there are two other possibilities in Java:   An  abstract class , which is just like a class, but it is declared as  abstract , and some of its methods are declared as  abstract , without implementation.  An abstract class cannot be instantiated, and any subclass who wish to be concrete needs to implement these abstract methods.  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 abstract   class   PaintedShape   { \n   Color   fillColor ; \n     : \n   void   fillWith ( Color   c )   { \n     fillColor   =   c ; \n   } \n     : \n   abstract   double   getArea (); \n   abstract   double   getPerimeter (); \n     :  }    An interface with default implementations.  Introduced only in Java 8, with the goal of allowing an interface to evolve, an interface can now contain default implementation of its methods.  Such interface still cannot be instantiated into objects, but classes that implement such interface need not provide an implementation for a method where a default implementation exists.  For instance, we can have: 1\n2\n3\n4\n5\n6\n7\n8 interface   Shape   { \n   public   double   getArea (); \n   public   double   getPerimeter (); \n   public   boolean   contains ( Point   p ); \n   default   public   boolean   cover ( Point   p )   { \n     return   contains ( p ); \n   }  }   \nwhere  cover  is a new method with default implementation, denoted with keyword  default .     The reason Java 8 introduced default methods for interface is for backward compatibility.  For instance, the implementer of  Shape  can add  cover  to a new version of interface  Shape  without breaking all the existing code that implements  Shape .  Abstract class, however, should be used in general in the design of a class hierarchy -- in a case where it is more meaningful for the subclass to implement its own method than the superclass.  For example, in the  PaintedShape  abstract class above, it can implement the methods related to styles, but it is not meaningful to provide an implementation of  getArea  and  getPerimeter . We will see more examples of abstract class later.",
            "title": "Abstract Class and Interface with Default Methods"
        },
        {
            "location": "/lec05/index.html#generics",
            "text": "Now let's move on to the topic of generics.\nSuppose you want to create a new class that encapsulates a queue of circles.  You wrote:  1\n2\n3\n4\n5\n6\n7\n8\n9 class   CircleQueue   { \n   private   Circle []   circles ; \n    : \n   public   CircleQueue ( int   size )   {...} \n   public   boolean   isFull() { ...} \n   public   boolean   isEmpty() { ...} \n   public   void   enqueue ( Circle   c )   {...} \n   public   Circle   dequeue() { ...}  }    Later, you found that you need a new class that encapsulates a queue of points.  You wrote: 1\n2\n3\n4\n5\n6\n7\n8\n9 class   PointQueue   { \n   private   Point []   points ; \n    : \n   public   PointQueue ( int   size )   {...} \n   public   boolean   isFull() { ...} \n   public   boolean   isEmpty() { ...} \n   public   void   enqueue ( Point   p )   {...} \n   public   Point   dequeue() { ...}  }    And you realize that there are actually a lot of similar code.  Invoking the  abstraction principle , which states that  \"Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts \", you decided to create a queue of Objects to replace the two classes above.  1\n2\n3\n4\n5\n6\n7\n8\n9 class   ObjectQueue   { \n   private   Object []   objects ; \n    : \n   public   ObjectQueue ( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( Object   o )   {...} \n   public   Object   dequeue ()   {...}  }    Now you have a very general class, that you can use to store objects of any kind, including a queue of strings, a queue of colors, etc.  You are quite pleased with yourself, as you should!  The early Java collection library contains many such generic data structures that stores elements of type  Object .  To create a queue of 10 circles and add some circles, you just need: 1\n2\n3\n4 ObjectQueue   cq   =   new   ObjectQueue ( 10 );  cq . enqueue ( new   Circle ( new   Point ( 0 ,   0 ),   10 ));  cq . enqueue ( new   Circle ( new   Point ( 1 ,   1 ),   5 )); \n  :    Getting a circle out of the queue is a bit more troublesome: 1 Circle   c   =   cq . dequeue ();   \nWould generate a compilation error, since we are trying to perform a narrowing reference conversion -- we cannot assign a variable of type  Object  to a variable of type  Circle  without type casting:  1 Circle   c   =   ( Circle ) cq . dequeue ();    As we have seen in  Lecture 4 , the code above might generate a runtime  ClassCastException  if there is an object in the queue that is not  Circle  or its subclass.  To avoid runtime error, we should check the type first:  1\n2\n3\n4 Object   o   =   cq . dequeue ();  if   ( o   instanceof   Circle )   { \n     Circle   c   =   ( Circle ) o ;  }    Wouldn't it be nice if we can still have code that is general, but we let the compiler generates an error if we try to add a non- Circle  into our queue of  Circle  objects, so that we don't have to check for the type of an object all the time?  Java 5 introduces generics, which is a significant improvement to the type systems in Java.  It allows a  generic class  or a  generic interface  of some type  T  to be written:  1\n2\n3\n4\n5\n6\n7\n8\n9 class   Queue < T >   { \n   private   T []   objects ; \n    : \n   public   Queue ( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( T   o )   {...} \n   public   T   dequeue ()   {...}  }    T  is known as  type parameter .\nThe same code as before can be written as:  1\n2\n3\n4 Queue < Circle >   cq   =   new   Queue < Circle >( 10 );  cq . enqueue ( new   Circle ( new   Point ( 0 ,   0 ),   10 ));  cq . enqueue ( new   Circle ( new   Point ( 1 ,   1 ),   5 ));  Circle   c   =   cq . dequeue ();    Here, we pass  Circle  as the  type argument  to  T , creating a  parameterized type   Queue<Circle> .  In Line 4, we no longer need to cast, and there is no danger of runtime error due to an object of the wrong class being added to the queue, for doing this: 1\n2 Queue < Circle >   cq   =   new   Queue < Circle >( 10 );  cq . enqueue ( new   Point ( 1 ,   3 ));   \nwill generate a compile-time error.  Generic typing is a type of polymorphism as well and is also known as  parametric polymorphism .   In Other Languages  Many modern programming languages support generics: C++ (known as  template ), Swift, Kotlin, C#, etc. For dynamically typed languages such as Python, one can already write generic code without regards to the type of the variables, so generic is kinda \"build in\".  In C (the 2011 version, C11), there is a  _Generic  expression, which is not to be confused with generics we are talking about here.   We can use parameterized type anywhere a type is used, including as type argument.  If we want to have a queue of a queue of circles, we can:  1 Queue < Queue < Circle >>   cqq   =   new   Queue <>( 10 );",
            "title": "Generics"
        },
        {
            "location": "/lec05/index.html#variance-of-generic-types",
            "text": "In  Lecture 4 , we discuss about subtypes and the variance of types.  Recall that  T T  is a subtype of  S S  if everywhere we use  S S , we can substitute with  T T .    Suppose a class or interface  B  is a subtype of  A , then  B<T>  is also a subtype of  A<T> , i.e., they are covariant.  Generics, however, are  invariant , with respect to the type parameter.  That is, if a class or interface  B  is a subtype of  A , then neither is  C<B>  a subtype of  C<A> , nor is  C<A>  a subtype of  C<B> .  A parameterized type must be used with exactly with same type argument.  For instance:  1\n2\n3 Queue < Circle >   qc   =   new   Queue < Shape >();    // error  Queue < Shape >   qs   =   new   Queue < Circle >();   // error  Queue < Shape >   qs   =   ( Queue < Shape >)   new   Queue < Circle >();   // error    will lead to compile-time error.  Attempting to type cast just like when we do a narrowing reference conversion will fail as well.",
            "title": "Variance of Generic Types"
        },
        {
            "location": "/lec05/index.html#wildcards",
            "text": "Subtyping among generic types are achieved through wildcard types  ? .   ?  itself is not a type, but a notation to denote variance of generic types.  We can replace type parameter  T  with  ? , to indicate that  T  can be any type.  This creates a subtype relationship.  For instance,  Queue<Shape>  is a subtype of  Queue <? > ,  Queue<Object>  is a subtype of  Queue <? > .  1 Queue <? >   qc   =   new   Queue < Shape > ();     // OK    Since the wildcard  ?  is not a type, we cannot declare a class like this: 1\n2\n3 class   Bar <?>   { \n     private   ?   x ;  }    We only use  ?  when specifying the type of a variable, field, or parameter.  Wildcards can be bounded.  Java uses the keyword  extends  and  super  to specify the bound.  For instance,  Queue<Circle>  and  Queue<Shape>  are both subtypes of  Queue <?   extends   Shape > , but  Queue<Object>  is not a subtype of  Queue <? >   Queue <?   extends   Shape > .  To be more general, if  T  is a subtype of  S , then  Queue<T>  is a subtype of  Queue <?   extends   S > .  In other words, the use of  ? extends  is covariant.  Further,  Queue <?   extends   T >  is a subtype of  Queue <?   extends   S > .  The  super  keyword is used to specify the contravariant relationship.\nIf  T  is a subtype of  S , then  Queue<S>  is a subtype of  Queue <?   super   T > .    More intuitively, we can replace  ? extends X  with type X or any subtype that extends X;  ? super X  with type X or any supertype of X.   Wildcard type in Other Languages  The use of wildcard type  ?  is not common in other programming languages.  Partly because Java introduces generics late and has to use type erasure to implement generic types.",
            "title": "Wildcards"
        },
        {
            "location": "/lec05/index.html#type-erasure",
            "text": "In Java, for backward compatibility, generic typing is implemented with a process called  type erasure .  The type argument is erased during compile time, and the type parameter  T  is replaced with either  Object  (if it is unbounded) or the bound (if it is bounded). For instance,  Queue<Circle>  will be replaced by  Queue  and  T  will be replaced by  Object , just like how Java code is written before generic type is introduced in Java 5.   Queue <?   extends   Shape >  will be replaced with  Queue  and  T  will be replaced with  Shape .  The compiler also inserts type casting and additional methods 2  to preserve the semantics of generic type.  Java's design decision to use type erasure to implement generics has several important implications.    First, unlike other languages, such as C++, Java does not support generics of a primitive type.  We cannot create a  Queue<int> , for instance.  We can only use reference types as type argument (anything that is a subtype of  Object ).  Second, we cannot have code that looks like the following:  1\n2\n3\n4 class   A   { \n   void   foo ( Queue < Circle >   c )   {} \n   void   foo ( Queue < Point >   c )   {}  }    Even though both  foo  above seem like they have different method signatures and is a valid application of method overloading, the compiler actually translates them both to:  1\n2\n3\n4 class   A   { \n   void   foo ( Queue   c )   {} \n   void   foo ( Queue   c )   {}  }    and bummer, we have a compilation error!  Third, using static methods or static fields in generic class becomes trickier.  Consider the example  1\n2\n3\n4\n5 class   Queue < T >   { \n   static   int   x   =   1 ; \n   static   T   y ; \n   static   T   foo ( T   t )   {};  }    Queue<Circle>  and  Queue<Point>  both gets compiled to  Queue .  So they share the same  x , even though you might think  Queue<CIrcle>  and  Queue<Point>  as two different distinct classes.    Further, the next two liens  static T y  and  static T foo(T t) {}  will generate a compilation error.  Since there will only be a copy of  y  shared by both  Queue<Circle>  and  Queue<Point> , the compiler does not know whether to replace  T  with  Circle  or  Point , and will complain.  Fourth, we cannot create an array of parameterized types.  1\n2\n3 Queue < Circle >[]   twoQs   =   new   Queue < Circle >[ 2 ];   // compiler error  twoQs [ 0 ]   =   new   Queue < Circle >();  twoQs [ 1 ]   =   new   Queue < Point >();    After type erasure, we get 1\n2\n3 Queue []   twoQs   =   new   Queue [ 2 ];   // compiler error  twoQs [ 0 ]   =   new   Queue ();  twoQs [ 1 ]   =   new   Queue ();    If Java would have allowed us to create an array of a parameterized type, then we could have added an element of incompatible type  Queue<Point>  into an array of  Queue<Circle>  without raising a run-time error.    Generics in Java is added as an afterthought and to maintain backward compatibility, the compiler has to erase the type parameter during compile type.  During runtime, the type information is no longer available, and this design causes the quirks above.",
            "title": "Type Erasure"
        },
        {
            "location": "/lec05/index.html#raw-types",
            "text": "One final note: for backward compatibility, Java allows us to use a generic class to be used without the type argument.  For instance, even though we declare  Queue<T> , we can just use  Queue .    1 Queue < Circle >   cq   =   new   Queue ();    After all, during compile time,  Queue<Circle>  is translated into  Queue  anyway.  In Java 5 or later, if we just use  Queue , we get a  Queue  of  Object s.  This is called a  raw type .  Recent Java compilers will warn you if you use a raw type in your code.",
            "title": "Raw Types"
        },
        {
            "location": "/lec05/index.html#wrapper-classes",
            "text": "We can get around the problem of not being able to create generics of primitive types using wrapper classes.  Java provides a set of wrapper classes, one for each primitive type:  Boolean ,  Byte ,  Character ,  Integer ,  Double ,  Long ,  Float , and  Short .  1\n2\n3\n4 Queue < Integer >   iq   =   new   Queue < Integer >( 10 );  cq . enqueue ( new   Integer ( 4 ));  cq . enqueue ( new   Integer ( 8 ));  cq . enqueue ( new   Integer ( 15 ));    Java 5 introduces something called  autoboxing  and  unboxing , which creates the wrapper objects automatically (autoboxing) and retrieves its value (unboxing) automatically.  With autoboxing and unboxing, we can just write:  1\n2\n3\n4 Queue < Integer >   iq   =   new   Queue < Integer >( 10 );  cq . enqueue ( 4 );  cq . enqueue ( 8 );  cq . enqueue ( 15 );    Note that  enqueue  expects an  Integer  object, but we pass in an  int .  This would cause the  int  variable to automatically be boxed (i.e., be wrapped in Integer object) and put onto the call stack of  enqueue .",
            "title": "Wrapper Classes"
        },
        {
            "location": "/lec05/index.html#performance-penalty",
            "text": "If the wrapper class is so great, why not use it all the time and forget about primitive types?  The answer: performance.  Because using an object comes with the cost of allocating memory for the object and collecting of garbage afterward, it is less efficient than primitive types.  Consider the following two programs:  1\n2\n3\n4\n5 Double   sum ;  for   ( int   i   =   0 ;   i   <   Integer . MAX_VALUE ;   i ++)  { \n     sum   +=   i ;  }   \nvs. 1\n2\n3\n4\n5 double   sum ;  for   ( int   i   =   0 ;   i   <   Integer . MAX_VALUE ;   i ++)  { \n     sum   +=   i ;  }    The second one is 2 times faster!  Due to autoboxing and unboxing, the cost of creating objects become hidden and often forgotten.  All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed.  Thus, every time  sum  in the example above is updated, a new object gets created.",
            "title": "Performance Penalty"
        },
        {
            "location": "/lec05/index.html#generic-methods",
            "text": "We can get around the problem of not being able to define static methods using generic methods.  Generic methods are just like generic type, but the scope of the type parameter is limited to only the method itself.  1\n2\n3 class   Queue < T >   { \n   static   < T >   T   foo ( T   t )   {   return   t ;   };  }    The above would compile.  Note that the  <T>  in  static <T> T foo(T t)  effectively declares a new type parameter  T , scoped to the method  foo , and has nothing to do with the type parameter  <T>  for  Queue<T> .  \n(Recall that, since  foo  is static and is associated with the class  Queue ).  As a convention, it is common to use the single letter  T  here, which may be confusing.  We can actually use any other single letter to represent the type parameter. 1\n2\n3 class   Queue < T >   { \n   static   < X >   X   foo ( X   t )   {   return   t ;   };  }    To invoke a generic method, we can call it like this: 1 Queue .< Point > foo ( new   Point ( 0 ,   0 ));    or simply: 1 Queue . foo ( new   Point ( 0 ,   0 ));",
            "title": "Generic Methods"
        },
        {
            "location": "/lec05/index.html#type-inference",
            "text": "In the last example, Java compiler uses  type inference  to determine what  T  should be: in this case, we are passing in a  Point  object, so  T  should be replaced with  Point .  Type inference can also be used with constructors. 1 Queue < Point >   q   =   new   Queue <>();    In the line above, we use the  diamond operator   <>  to ask Java to fill in the type for us.  Again, type inference allows Java to infer that we are creating a  Point  object.  In cases where the type inference finds multiple matching types, the most specific type is chosen.   Local variable type inference in Java 10  Java 10, which is scheduled to be released next month, supports type inference for a local variable.  We can write 1 var   q   =   new   Queue < Point >();   \nand Java 10 compiler can infer that q should have the type  Queue<Point> .",
            "title": "Type Inference"
        },
        {
            "location": "/lec05/index.html#java-collections",
            "text": "Now, we turn our attention to the Java Collection Framework.  Java provides a rich set of classes for managing and manipulating data.  They efficiently implement many useful data structures (hash tables, red-black trees, etc.) and algorithms (sorting, searching, etc.) so that we no longer have to.  As computer scientists, it is still very important for us to know how these data structures and algorithms can be implemented, how to prove some behaviors (such as running time) and their correctness, how certain trade-offs are made, etc. They are so important that we have two modules dedicated to them, CS2040 and CS3230, in the core CS curriculum.  In CS2030, however, we will only use them but not study how to implement them.  Most importantly, Java Collection Framework is mostly well-designed and serves as real-world examples of how all the OO principles and programming language concepts are used.  We can see how all the things that we have learned so far is applied.",
            "title": "Java Collections"
        },
        {
            "location": "/lec05/index.html#collection",
            "text": "One of the basic interfaces in Java Collection Framework is  Collection<E> , it looks like:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 public   interface   Collection < E >   extends   Iterable < E >   { \n   boolean   add ( E   e ); \n   boolean   contains ( Object   o ); \n   boolean   remove ( Object   o ); \n   void   clear (); \n   boolean   isEmpty (); \n   int   size (); \n\n   Object []   toArray (); \n   < T >   T []   toArray ( T []   a ); \n\n   boolean   addAll ( Collection <?   extends   E >   c ); \n   boolean   containsAll ( Collection <?>   c ); \n   boolean   removeAll ( Collection <?>   c ); \n   boolean   retainAll ( Collection <?>   c ); \n     :  }    There are some newly added methods in Java 8 that we will visit in the second half of this module, but first,\nlet's try to understand what the definition above means.  First, like a generic class that you have seen,  Collection  is a  generic interface  parameterized with a type parameter  E .  It extends a generic  Iterable<E>  interface (we will get to this later).  The first six methods of  Collection<E>  should be self-explanatory.   add  adds an element into the collection;  contains  checks if a given object is in the collection;   remove  removes a single instance of the given object from the collection;   clear  removes all objects from the collection;   isEmpty()  checks if the collection has no elements or not; and finally,  size  returns the number of elements.  Note that  contains()  relies on the implementation of  equals()  to check if the object exists in the collection or not.  Similarly,  remove()  relies on  equals()  to find the matching objects.  We said earlier that it is useful to override the  equals  methods of  Object  instead of implementing our own  equals , because the overridden  equals()  will be called elsewhere.  This is one of the \"elsewhere\" I mentioned.  The documentation of  contains(o)  mentions that it is guaranteed to return  true  if there exists an element  e  such that  e.equals(o)  or  e == null  (if  o == null ).  Ditto for  remove(o) .   Non-generic Methods  You might notice that, instead of  contains(E e) and  remove(E e) , the  Collection  interface uses  contains(Object o)  and  remove(Object o) .  This little inconsistency, however, is harmless.  For instance, if you have a collection intended for circles only, adding a non-circle could be disastrous.  Trying to remove a non-circle or checking for a non-circle, would just return false.\nMore information can be found on this  StackOverflow  thread.   Java Collection Framework allows classes that implement an interface to throw an  UnsupportedOperationException  if the implementation decides not to implement one of the operations (but still need to have the method in the class).  The method  toArray()  on Line 9 returns an array containing all the elements inside this collection.  The second overloaded  toArray  method takes in an array of generic type  T .  If the collections fit in  a ,  a  is filled and returned.  Else, it allocates a new array of type  T  and returned.  The second  toArray  method is an example of a generic method.  It is the caller responsibility to pass in the right type, otherwise, an  ArrayStoreException  will be thrown.  The next group of methods operates on another collection.   addAll  add all the elements of collection  c  into the current collection;  containsAll  checks if all the elements of collection  c  are contained in the current collection;  removeAll  removes all elements from collection  c , and finally,  retainsAll  remove all elements not in  c .  What is more interesting about the methods is the type of  c .  In  containsAll ,  removeAll , and  retainAll , the collection  c  has the type  Collection <? > .  Recall that  Collection <? >  is a supertype of  Collection<T> , whatever  T  is.  So, we can pass in a  Collection  of any reference type to check for equality.  In this case, we are not adding anything to the collection, so the type of  c  is set to be as general as possible.  In  addAll , however,  c  is declared as  Collection <?   extends   E > .  Since we are adding to the collection, we can only add elements that either has the type  E  or a type that is a subtype of  E .  This constraint is enforced during compile time through the covariance relationship between  Collection <?   extends   E >  and  Collection<E> .   Iterable  The  Iterable<E>  interface provides only a single method,  Iterator<E> iterator() , which returns a generic interface called  Iterator<E>  over the collection.  An  Iterator  is another interface that allows us to go through all the elements in a  Collection<E> .  Useful methods include  hasNext() , which returns if there is a next element in the  Collection<E> ;  next() , which returns the next element (with parameterized type  E ); and  remove() , which removes the last returned element from the  Collection<E> .   So far we have not seen any example code using  Collection .  This is because Java Collection Framework does not provide a class that implements the  Collection<E>  directly.  The documentation recommends that we implement the  Collection<E>  interface 3  if we want a collection of objects that allows duplicates and does not care about the orders.",
            "title": "Collection"
        },
        {
            "location": "/lec05/index.html#set-and-list",
            "text": "The  Set<E>  and  List<E>  interfaces extend the  Collection<E>  interface.   Set<E>  is meant for implementing a collection of objects that does not allow duplicates (but still does not care about order of elements), while  List<E>  is for implementing a collection of objects that allow duplicates, but the order of elements matters.  Mathematically, a  Collection<E>  is used to represent a bag,  Set<E> , a set, and  List<E> , a sequence.  The  List<E>  interface has additional methods for adding and removing elements.   add(e)  by default would just add to the end of the list.   add(i, e)  inserts  e  to position  i .   get(i)  returns the element at position  i ,  remove(i)  removes the elements at position  i ;  set(i,e)  replace the  i -th element with  e .  Useful classes in Java collection that implement  List<E>  include  ArrayList  and  LinkedList , and useful classes that implement  Set<E>  include  HashSet .  Let's see some examples:  1\n2\n3\n4\n5 List < String >   names   =   new   ArrayList ();  names . add ( \"Cersei\" );  names . add ( \"Joffrey\" );  names . add ( 0 ,   \"Gregor\" );  System . out . println ( names . get ( 1 ));    Line 1 above creates an empty array list.  The second line adds two strings into the list, each appending them to the list.  After executing Line 3, it would contain the sequence  <\"Cersei\",\"Joffrey\"> .  Line 4 inserts the string  \"Gregor\"  to position 0, moving the rest of the list down by 1 position.  The sequence is now  <\"Gregor\",\"Cersei\",\"Joffrey\"> .  Finally, calling  get(1)  would return the string  \"Cersei\" .  Note that we declare  names  with the interface type  List<String> .  We should always do this to keep our code flexible.  If we want to change our implementation to  LinkedList , we only need to change Line 1 to: 1 List < String >   names   =   new   LinkedList ();",
            "title": "Set and List"
        },
        {
            "location": "/lec05/index.html#comparator",
            "text": "The  List<E>  interface also specifies a  sort  method, with the following specification: 1 default   void   sort ( Comparator <?   super   E >   c )    List<E>  is an example of an interface with default method.  The keyword  default  indicates that the interface  List<E>  comes with a default  sort  implementation, so a class that implements the interface needs not implement it again unless the class wants to override the method.  This method specification is also interesting and worth looking closer.  It takes in an object  c  with generic interface  Comparator <?   super   E > .  The  Comparator  interface allows us to specify how to compare two elements, by implementing a  compare()  method.   compare(o1,o2)  should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise.  Let's write  Comparator  class 4 :  1\n2\n3\n4\n5 class   NameComparator   implements   Comparator < String >   { \n     public   int   compare ( String   s1 ,   String   s2 )   { \n         return   s1 . compareTo ( s2 ); \n     }  }    In the above, we use the  compareTo  method provided by the  String  class to do the comparison.  With the above, we can now sort the  names :  1 names . sort ( new   NameComparator ());    This would result in the sequence being changed to  <\"Cersei\",\"Gregor\",\"Joffrey\"> .  We can easily change how we want to sort the names, for instance, to 1\n2\n3\n4\n5 class   NameComparator   implements   Comparator < String >   { \n     public   int   compare ( String   s1 ,   String   s2 )   { \n         return   s1 . length ()   -   s2 . length (); \n     }  }   \nif we want to sort by the length of the names.  One last thing to note about the method  sort  is that it takes in  Comparator <?   super   E >  that is contravariant.  Recall that  Comparator<Object>  is a subtype of  Comparator <?   super   E > , so we can pass in more general  Comparator  object to  sort  (e.g., a class that implements  Comprator<Object>",
            "title": "Comparator"
        },
        {
            "location": "/lec05/index.html#map",
            "text": "One of the more powerful data structures provided by Java Collection is maps (also known as a dictionary in other languages).  A map allows us to store a (unique key, value) pair into the collection, and retrieve the value later by looking up the key.  The  Map<K,V>  interface is again generic, but this time, has two type parameters,  K  for the type of the key, and  V  for the type of the value.  These parameters make the  Map  interface flexible -- we can use any type as the key and value.  The two most important methods for  Map  is  put  and  get :  1\n2      V   put ( K   key ,   V   value ); \n     V   get ( Object   k );    A useful class that implements  Map  interface is  HashMap :  1\n2\n3\n4 Map < String , Integer >   population   =   new   HashMap < String , Integer >();  population . put ( \"Oldtown\" , 500000 );  population . put ( \"Kings Landing\" , 500000 );  population . put ( \"Lannisport\" , 300000 );    Later, if we want to lookup the value, we can: 1 population . get ( \"Kings Landing\" );",
            "title": "Map"
        },
        {
            "location": "/lec05/index.html#which-collection-class",
            "text": "Java provides many collection classes, more than what we have time to go through.  It is important to know which one to use to get the best performance out of them.  For the few classes we have seen:   Use  HashMap  if you want to keep a (key, value) pair for lookup later.  Use  HashSet  if you have a collection of elements with no duplicates and order is not important.  Use  ArrayList  if you have a collection of elements with possible duplicates and order is important, and retrieving a specific location is more important than removing elements from the list.  Use  LinkedList  if you have a collection of elements with possibly duplicates and order is important, retriving a specific location is less important than removing elements from the list.   You should understand the reasons above after CS2040.  Further, if you want to check if a given object is contained in the list, then  ArrayList  and  LinkedList  are not good candidates.   HashSet , on the other hand, can quickly check if an item is already contained in the set.  There is, unfortunately, no standard collection class that supports fast  contain  and allow duplicates.",
            "title": "Which Collection Class?"
        },
        {
            "location": "/lec05/index.html#exercise",
            "text": "Consider the following code snippet:\n      1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 interface   I   { \n   void   f (); \n   default   void   g ()   {  \n   }  }  abstract   class   A   implements   I   { \n   abstract   void   h (); \n   abstract   void   h ( int   x ); \n   void   j ()   { \n   }  }  class   B   extends   A   { \n   :  }    Class  B  is a concrete class.  What are the methods that  B  needs to implement?    For each of the statement below, indicate if it is a valid statement (no compilation error). Explain why in one sentence.   List <? >   list   =   new   ArrayList < String > ();  List <?   super   Integer >   list   =   new   List < Object > ();  List <?   extends   Object >   list   =   new   LinkedList < Object > ();  List <?   super   Integer >   list   =   new   LinkedList <> ();     Consider a generic class  A<T>  with a type parameter  T  and a constructor with no argument.  Which of the following statements are valid (i.e., no compilation error) ways of creating a new object of type  A ? We still consider the statement as valid if the Java compiler produces a warning.   new A<int>();  new A<>();  new A();     In this question, we will explore the more strange behavior of  Integer  class.  Remember that  ==  compares only references: whether the two references are pointing to the same object or not.   The  equals  method has been overridden to compare if the values are the same or not.  Try the following in  jshell :  1\n2\n3 Integer   x   =   1 ;  Integer   y   =   1 ;  x   ==   y ;    What do you expect the comparison  ==  to return?  What did it return?  Now try:  1\n2\n3 Integer   x   =   1000 ;  Integer   y   =   1000 ;  x   ==   y ;    What do you expect it to return?  What did it return?  Look up on the Internet (e.g., StackOverflow) on why this happens.  (Hint:  Integer  caching)  The moral of the story here is to always use  equals  to compare two reference variables.    Consider a method declared as  int foo(double x)  Which of the following statements will NOT result in a compilation error:   int cs = foo(2030);  double cs = foo(2.030);  int cs = foo(new Double(2.030));  Integer cs = foo(new Double(2.030));     In this question, we will explore the behavior of  ArrayList  class and autoboxing/unboxing.  Will the following code compile?  If so, what will be printed?  (a)   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 List < Integer >   list   =   new   ArrayList <>();  int   one   =   1 ;  Integer   two   =   2 ;  list . add ( one );  list . add ( two );  list . add ( 3 );  for   ( Integer   num   :   list )   { \n   System . out . println ( num );  }    (b)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 List < Integer >   list   =   new   ArrayList <>();  int   one   =   1 ;  Integer   two   =   2 ;  list . add ( one );  list . add ( two );  list . add ( 3 );  for   ( int   num   :   list )   {   // Integer -> int \n   System . out . println ( num );  }    \u00a9 1\n2\n3\n4\n5 List < Integer >   list   =   Arrays . asList ( 1 ,   2 ,   3 );  for   ( Double   num   :   list )   { \n   System . out . println ( num );  }    (d) 1\n2\n3\n4\n5 List < Integer >   list   =   Arrays . asList ( 1 ,   2 ,   3 );  for   ( double   num   :   list )   { \n   System . out . println ( num );  }    (e)  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 List < Integer >   list   =   new   LinkedList <>();  list . add ( 5 );  list . add ( 4 );  list . add ( 3 );  list . add ( 2 );  list . add ( 1 );  Iterator < Integer >   it   =   list . iterator ();  while   ( it . hasNext ())   { \n   System . out . println ( it . next ());  }      Here is another set of questions to explore about the behavior of autoboxing/unboxing and primitive type conversion.  (a) 1\n2\n3\n4\n5 double   d   =   5 ;  int   i   =   2.5 ;  System . out . println ( d );  System . out . println ( i );    (b) 1\n2\n3\n4\n5 double   d   =   ( int )   5 ;  int   i   =   ( double )   2.5 ;  System . out . println ( d );  System . out . println ( i );    \u00a9 1\n2\n3\n4\n5 double   d   =   ( int )   5.5 ;  int   i   =   ( int )   2.5 ;  System . out . println ( d );  System . out . println ( i );    (d) 1\n2\n3\n4\n5 Double   d   =   5 ;  Integer   i   =   2.5 ;  System . out . println ( d );  System . out . println ( i );    (e) 1\n2\n3\n4\n5 Double   d   =   ( double )   5 ;  Integer   i   =   ( int )   2.5 ;  System . out . println ( d );  System . out . println ( i );    (f) 1\n2\n3\n4\n5 double   d   =   ( Integer )   5 ;  int   i   =   ( Integer )   2 ;  System . out . println ( d );  System . out . println ( i );    (g) 1\n2\n3\n4\n5 double   d   =   ( Double )   5 ;  int   i   =   ( Integer )   2 ;  System . out . println ( d );  System . out . println ( i );          This is widely considered as a bad practice (or  anti-pattern ), called the  constant interface anti-pattern .\u00a0 \u21a9    Look up bridge methods if you want to know the gory details.\u00a0 \u21a9    If you want to do so, however, it is likely more useful to inherit from the abstract class  AbstractCollection<E>  (which implements most of the basic methods of the interface) rather than implementing the interface  Collection<E>  directly.\u00a0 \u21a9    Later in CS2030, you will see how we significantly reduce the verbosity of this code!  But let's do it the hard way first.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec06/index.html",
            "text": "Lecture 6: Hash Code, Nested Classes, Enum\n\n\nLearning Outcomes\n\n\n\n\nUnderstand the need to override \nhashCode\n whenever \nequals\n is overridden and how to use \nArrays\n' \nhashCode\n method to compute a hash code\n\n\nUnderstand static vs. non-static nested class, local class, and anonymous class and when to use / not to use one\n\n\nUnderstand the rules about final / effectively final variable access for local class and anonymous class\n\n\nAware of the limitation when declaring a new anonymous class\n\n\nUnderstand the concept of variable capture\n\n\nBe aware that \nenum\n is a special case of a \nclass\n and share many features as a class -- not just constants can be defined.\n\n\nUnderstand how \nenum\n is expanded into a subclass of \nEnum\n\n\nKnow that enum constants can have customized fields and methods.\n\n\n\n\n1. Hash Code\n\n\nWe have seen how \nHashMap\n in Java Collections allows us to store a key-value pair and lookup a value with the key, and how \nHashSet\n stores item with no duplicates. \n\n\nInternally, \nHashMap\n and \nHashSet\n organize the items into \"buckets\".  Such organization improves efficiency if we need to search through the items, either to find a pair with a given key, or to check if an item already exists in the set.  We no longer need to search through the entire collection, but only the \"bucket\" that the item, if exists, would have been organized into.  For this idea to work, each item must be \nhashed\n deterministically into a bucket. \n\n\nIn Java objects, such hashing operation is determined by the method \nhashCode()\n of a given key object.  \nhashCode()\n returns an \nint\n, which \nHashMap\n, \nHashSet\n, or other data structures can use to determine which \"bucket\" to store a (key, value) pair or an item into.\n\n\nYou will learn more about hashing and hash tables in CS2040.\n\n\nBut, what is important here is that two keys (two objects, in general) which are the same (\nequals()\n returns \ntrue\n), must have the same \nhashCode()\n.  Otherwise, \nHashMap\n would fail.\n\n\nSo it is important to ensure that if \no1.equals(o2)\n, then \no1.hashCode() == o2.hashCode()\n.  Note that the reverse does not have to be true -- two objects with the same hash code does not have to be equals.\n\n\nThis property is also useful for implementing \nequals()\n.  For a complex object, comparing every field for equality can be expensive.  If we can compare the hash code first, we could filter out objects with different hash code (since they cannot be equal).  We only need to compare field by field if the hash code is the same.\n\n\nLet's see some example:\n\n\n1\n2\n3\n4\n5\n6\nString\n \ns1\n \n=\n \n\"hello\"\n;\n\n\nString\n \ns2\n \n=\n \nnew\n \nString\n(\n\"hello\"\n);\n\n\nString\n \ns3\n \n=\n \n\"goodbye\"\n;\n\n\ns1\n.\nhashCode\n();\n\n\ns2\n.\nhashCode\n();\n\n\ns3\n.\nhashCode\n();\n\n\n\n\n\n\n\nLines 4-5 both return 99162326, an integer value that is calculated using a mathematical function, called \nhash function\n, so that two strings with the same content returns the same value.  Line 6 returns 207022353.\n\n\nWe can see the problem when we don't define \nhashCode()\n.  Take our \nPoint\n class from before:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\njshell\n>\n \nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\np\n \n==>\n \n(\n0.0\n,\n0.0\n)\n\n\n\njshell\n>\n \nPoint\n \nq\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\nq\n \n==>\n \n(\n0.0\n,\n0.0\n)\n\n\n\njshell\n>\n \np\n.\nequals\n(\nq\n);\n\n\n$5\n \n==>\n \ntrue\n\n\n\njshell\n>\n \nHashSet\n<\nPoint\n>\n \nset\n \n=\n \nnew\n \nHashSet\n<>();\n\n\nset\n \n==>\n \n[]\n\n\n\njshell\n>\n \nset\n.\nadd\n(\np\n);\n\n\n$7\n \n==>\n \ntrue\n\n\n\njshell\n>\n \nset\n.\nadd\n(\nq\n);\n\n\n$8\n \n==>\n \ntrue\n\n\n\njshell\n>\n \nset\n\n\nset\n \n==>\n \n[(\n0.0\n,\n0.0\n),\n \n(\n0.0\n,\n0.0\n)]\n\n\n\n\n\n\n\nYou can see that we have added two points that are the same into the set, which usually is not what we want.  To fix this, we need to write our own \nhashCode()\n, by overriding the \nhashCode()\n method in the \nObject\n class.\n\n\nCalculating good hash code is an involved topic, and is beyond the scope of CS2030.  In Java, the utility class \nArrays\n provide us some convenient \nhashCode\n methods to help us.  We can pack the fields of a class into an array, and then call \nArrays.hashCode()\n to compute the hash code of these fields.  Let's add the following to \nPoint\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nPoint\n \n{\n\n    \n:\n\n  \n@Override\n\n  \npublic\n \nint\n \nhashCode\n()\n \n{\n\n    \ndouble\n[]\n \na\n \n=\n \nnew\n \ndouble\n[\n2\n];\n\n    \na\n[\n0\n]\n \n=\n \nthis\n.\nx\n;\n\n    \na\n[\n1\n]\n \n=\n \nthis\n.\ny\n;\n\n    \nreturn\n \nArrays\n.\nhashCode\n(\na\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNow, \nset.add(q)\n above returns false -- we can no longer add point (0,0) twice in to the set.\n\n\n\n\nXOR-ing hash codes\n\n\nIf you have fields in a class that are of different types (and cannot be packed into a single array), you can pack them into different arrays, call \nArrays.hashCode()\n for each of the arrays, and combine the hash code together with the XOR operator \n^\n.  XOR is mathematically a good operator for combining two hash codes, since given two numbers with equal distribution of 0s and 1s, XOR-ing them will give another number with equal distribution of 0s and 1s.\n\n\n\n\n2. Nested Class\n\n\nThe second topic for today is nested class.  There are four kinds of nested classes in Java.  You have seen a static nested class, used inappropriately in \nLab 1a\n.  Let's see where are some good use cases to use nested classes.\n\n\nNested classes are used to group logically relevant classes together.  Typically, a nested class is tightly coupled with the container class, and would have no use outside of the container class.  Nested classes can be used to encapsulate information within a container class, for instance, when implementation of a class becomes too complex.  As such, it is useful for \"helper\" classes that serve specific purposes.\n\n\nA nested class is a field of the containing class, and can access fields and methods of the containing class, including those declared as \nprivate\n.  We can keep the nested class within the abstraction barrier, and declare a nested class as \nprivate\n, if there is no need for it to be exposed to the client outside the barrier.\nOn the other hand, because of this, you should really have a nested class only if the nested class belongs to the same encapsulation.  Otherwise, the containing class would leak its implementation details to the nested class. \n\n\nTake the \nHashMap<K,V>\n class for instance.  \nThe implementation of \nHashMap<K,V>\n contains several nested classes, including \nHashIterator\n, which implement an \nIterator<E>\n interface for iterating through the key and value pairs in the map, and an \nEntry<K,V>\n class, which encapsulates a key-value pair in the map.  Some of these classes are declared \nprivate\n, if they are only used within the \nHashMap<K,V>\n class.\n\n\nA nested class can be either static or non-static.  Just like static fields and static methods, a \nstatic nested class\n is associated with the containing \nclass\n, NOT an \ninstance\n.  So, it can only access static fields and static methods of the containing class.  A \nnon-static nested class\n, on the other hand, can access all fields and methods of the containing class.  A \nnon-static nested class\n is also known as an \ninner class\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n;\n\n  \nstatic\n \nint\n \ny\n;\n\n\n  \nclass\n \nB\n \n{\n\n    \nvoid\n \nfoo\n()\n \n{\n\n      \nx\n \n=\n \n1\n;\n \n// accessing x from A is OK\n\n    \n}\n\n  \n}\n\n\n  \nstatic\n \nclass\n \nC\n \n{\n\n    \nvoid\n \nbar\n()\n \n{\n\n      \nx\n \n=\n \n1\n;\n \n// accessing x from A is not OK since C is static\n\n      \ny\n \n=\n \n1\n;\n \n// accessing y is OK\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nLocal Class\n\n\nWe can also declare a class within a function as well, just like a local variable.  One example is the \nNameComparator\n class in \nLecture 5\n.  In that example, we created another top-level class (and so, a new file) just to define how to compare two strings, which is a little bit silly.\n\n\nWe can actually just define the \nNameComparator\n class when we need it, just before we sort:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvoid\n \nsortNames\n(\nList\n<\nString\n>\n \nnames\n)\n \n{\n\n\n  \nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n    \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n      \nreturn\n \ns1\n.\nlength\n()\n \n-\n \ns2\n.\nlength\n();\n\n    \n}\n\n  \n}\n\n\n  \nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n\n}\n\n\n\n\n\n\n\nThis makes the code easier to read since we keep the definition of the class and its usage closer together. \n\n\nClasses like \nNameComparator\n that are declared inside a method (to be more precise, inside a block of code between \n{\n and \n}\n) is called a \nlocal class\n.  Just like a local variable, a local class is scoped within the method.  Like a nested class, a local class has access to the variables of the enclosing class.  Further, it can access the variables of the local variables of the enclosing method.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nA\n \n{\n\n  \nint\n \nx\n \n=\n \n1\n;\n\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nint\n \ny\n \n=\n \n1\n;\n\n\n    \nclass\n \nB\n \n{\n\n      \nvoid\n \ng\n()\n \n{\n\n        \nx\n \n=\n \ny\n;\n \n// accessing x and y is OK.\n\n      \n}\n\n    \n}\n\n\n    \nnew\n \nB\n().\ng\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nVariable Capture\n\n\nRecall that when a method returns, all local variables of the methods are removed from the stack.  But, an instance of that local class might still exist.  Consider the following example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ninterface\n \nC\n \n{\n\n  \nvoid\n \ng\n();\n\n\n}\n\n\nclass\n \nA\n \n{\n\n  \nint\n \nx\n \n=\n \n1\n;\n\n\n  \nC\n \nf\n()\n \n{\n\n    \nint\n \ny\n \n=\n \n1\n;\n\n\n    \nclass\n \nB\n \nimplements\n \nC\n \n{\n\n      \nvoid\n \ng\n()\n \n{\n\n        \nx\n \n=\n \ny\n;\n \n// accessing x and y is OK.\n\n      \n}\n\n    \n}\n\n\n    \nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n    \nreturn\n \nb\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nCalling \n\n1\n2\n3\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nC\n \nb\n \n=\n \na\n.\nf\n();\n\n\nb\n.\ng\n();\n\n\n\n\n\n\nwill give us a reference to an object of type \nB\n now.  But, if we call \nb.g()\n, what is the value of \ny\n? \n\n\nFor this reason, even though a local class can access the local variables in the enclosing method, the local class makes \na copy of local variables\n inside itself.  We say that a local class \ncaptures\n the local variables.   \n\n\nEffectively \nfinal\n\n\nVariable captures could be confusing.  Consider the following code:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nvoid\n \nsortNames\n(\nList\n<\nString\n>\n \nnames\n)\n \n{\n\n  \nboolean\n \nascendingOrder\n \n=\n \ntrue\n;\n\n  \nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n    \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n      \nif\n \n(\nascendingOrder\n)\n \n        \nreturn\n \ns1\n.\nlength\n()\n \n-\n \ns2\n.\nlength\n();\n\n      \nelse\n \n        \nreturn\n \ns2\n.\nlength\n()\n \n-\n \ns1\n.\nlength\n();\n\n    \n}\n\n  \n}\n\n\n  \nascendingOrder\n \n=\n \nfalse\n;\n\n  \nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n\n}\n\n\n\n\n\n\n\nWill \nsort\n sorts in ascending order or descending order?\n\n\nTo avoid confusing code like this, Java only allows a local class to access variables that are explicitly declared \nfinal\n or implicitly final (or \neffectively\n final).  An implicitly final variable is one that does not change after initialization.  Therefore, Java saves us from such hair-pulling situation and disallow such code -- \nascendingOrder\n is not effectively final so the code above does not compile.\n\n\n\n\nVariable Capture in Javascript\n\n\nThose of you who did CS1101S or otherwise familiar with Javascript might want to note that this is different from Javascript, which does not enforce the final/effectively final restriction in variable captures.\n\n\n\n\nI do not see a good use case for local class -- if you have information and behavior inside a block of code that is so complex that you need to encapsulate it within a local class, it is time to rethink your design.\n\n\nWhat about the use case of \nNameComparator\n above?  There are actually better ways to write the class.  We will look at \nanonymous class\n today.\n\n\nAnonymous Class\n\n\nAn anonymous class is one where you declare a class and instantiate it in a single statement.  It's anonymous since We do not even have to give the class a name.\n\n1\n2\n3\n4\n5\nnames\n.\nsort\n(\nnew\n \nComparator\n<\nString\n>()\n \n{\n\n  \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n    \nreturn\n \ns1\n.\nlength\n()\n \n-\n \ns2\n.\nlength\n();\n\n  \n}\n\n\n});\n\n\n\n\n\n\nThe example above removes the need to declare a class just for the purpose of comparing two strings.  \n\n\nAn anonymous class has the following format: \nnew X (arguments) { body }\n, where:\n\n\n\n\nX\n is a class that the anonymous class extends or an interface that the anonymous class implements.  X cannot be empty.  This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time.  Furthermore, an anonymous class cannot implement more than one interface. \n\n\narguments\n are the arguments that you want to pass into the constructor of the anonymous class.  If the anonymous class is extending an interface, then there is no constructor, but we still need \n()\n.\n\n\nbody\n is the body of the class as per normal, except that we cannot have a constructor for an anonymous class.\n\n\n\n\nThe syntax might look overwhelming at the beginning, but we can also write it as:\n\n\n1\n2\n3\n4\n5\n6\nComparator\n<\nString\n>\n \ncmp\n \n=\n \nnew\n \nComparator\n<\nString\n>()\n \n{\n\n  \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n    \nreturn\n \ns1\n.\nlength\n()\n \n-\n \ns2\n.\nlength\n();\n\n  \n}\n\n\n};\n\n\nnames\n.\nsort\n(\ncmp\n);\n\n\n\n\n\n\n\nLine 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a \n{ .. }\n body.\n\n\nAn anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local class applies.\n\n\n3. Enum\n\n\nAn \nenum\n is a special type of class in Java.  Variable of an enum type can only be one of the predefined constants.  Using enum has one advantage over the use of \nint\n for predefined constant -- it is type safe.  Consider how we have been defining different event types in \nLab 1a\n.\n\n\n1\n2\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_ARRIVE\n \n=\n \n1\n;\n\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_DONE\n \n=\n \n2\n;\n\n\n\n\n\n\n\nBut, we cannot prevent someone from creating an event \nnew Event(time, 100)\n, passing in an invalid event type (type 100).  \n\n\nIf we define the event type as enum, then we can write like this:\n\n\n1\n2\n3\n4\nenum\n \nEventType\n \n{\n\n  \nCUSTOMER_ARRIVE\n,\n \n  \nCUSTOMER_DONE\n\n\n}\n\n\n\n\n\n\n\nand the field \neventType\n in \nEvent\n now has a type \nEventType\n instead of \nint\n:\n\n1\n2\n3\n4\nclass\n \nEvent\n \n{\n\n  \nprivate\n \ndouble\n \ntime\n;\n \n  \nprivate\n \nEventType\n \neventType\n;\n \n\n}\n\n\n\n\n\n\nTrying to assign anything other than the two predefined event type to \neventType\n would result in compilation error.  Remember, an error caught at compile time is much better than an error caught during run time, so this is good!\n\n\n\n\nIn other languages\n\n\nEnumerated types like \nenum\n are common in other langauges, including procedural languages like C.  But, \nenum\n in Java is more powerful, as seen below.\n\n\n\n\nEnum's Fields and Methods\n\n\nEach constant of an enum type is actually an instance of the enum class and is a field in the enum class declared with \npublic static final\n.\n\nSince enum in Java is a class, we can define constructors, methods, and fields in enums.  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nenum\n \nColor\n \n{\n\n  \nBLACK\n(\n0\n,\n \n0\n,\n \n0\n),\n\n  \nWHITE\n(\n1\n,\n \n1\n,\n \n1\n),\n\n  \nRED\n(\n1\n,\n \n0\n,\n \n0\n),\n\n  \nBLUE\n(\n0\n,\n \n0\n,\n \n1\n),\n\n  \nGREEN\n(\n0\n,\n \n1\n,\n \n0\n),\n\n  \nYELLOW\n(\n1\n,\n \n1\n,\n \n0\n),\n\n  \nPURPLE\n(\n1\n,\n \n0\n,\n \n1\n);\n\n\n  \nprivate\n \nfinal\n \ndouble\n \nr\n;\n\n  \nprivate\n \nfinal\n \ndouble\n \ng\n;\n\n  \nprivate\n \nfinal\n \ndouble\n \nb\n;\n\n\n  \nColor\n(\ndouble\n \nr\n,\n \ndouble\n \ng\n,\n \ndouble\n \nb\n)\n \n{\n\n    \nthis\n.\nr\n \n=\n \nr\n;\n\n    \nthis\n.\ng\n \n=\n \ng\n;\n\n    \nthis\n.\nb\n \n=\n \nb\n;\n\n  \n}\n\n\n  \npublic\n \ndouble\n \nluminance\n()\n \n{\n\n    \nreturn\n \n(\n0.2126\n \n*\n \nr\n)\n \n+\n \n(\n0.7152\n \n*\n \ng\n)\n \n+\n \n(\n0.0722\n \n*\n \nb\n);\n\n  \n}\n\n\n  \npublic\n \nString\n \ntoString\n()\n \n{\n\n    \nreturn\n \n\"(\"\n \n+\n \nr\n \n+\n \n\", \"\n \n+\n \ng\n \n+\n \n\", \"\n \n+\n \nb\n \n+\n \n\")\"\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nIn the example above, we represent a color with its RGB component.  Enum values should only constants, so \nr\n, \ng\n, \nb\n are declared as \nfinal\n.  We have a method that computes the luminance (the \"brightness\") of a color, and a \ntoString()\n method.  \n\n\nThe enum values are now written as \nBLACK(0, 0, 0)\n, with arguments passed into its constructor.\n\n\nCustom Methods for Each Enum\n\n\nEnum in Java is more powerful than the above -- we can define custom methods for each of the enum constant, by writing \nconstant-specific class body\n.  If we do this, then each constant becomes an anonymous class that extends the enclosing enum.   \n\n\nConsider the enum \nEventType\n.  You can do the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nenum\n \nEventType\n \n{\n\n  \nCUSTOMER_ARRIVE\n \n{\n\n    \nvoid\n \nlog\n(\ndouble\n \ntime\n,\n \nCustomer\n \nc\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\ntime\n \n+\n \n\" \"\n \n+\n \nc\n \n+\n \n\" arrives\"\n);\n\n    \n}\n\n  \n},\n\n  \nCUSTOMER_DONE\n \n{\n\n    \nvoid\n \nlog\n(\ndouble\n \ntime\n,\n \nCustomer\n \nc\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\ntime\n \n+\n \n\" \"\n \n+\n \nc\n \n+\n \n\" done\"\n);\n\n    \n}\n\n  \n};\n\n\n  \nabstract\n \nvoid\n \nlog\n(\ndouble\n \ntime\n,\n \nCustomer\n \nc\n);\n\n\n}\n\n\n\n\n\n\n\nIn the code above, \nEventType\n is an abstract class -- \nlog\n is defined as \nabstract\n with no implementation.  Each enum constant has its own implementation to log that particular event.\n\n\n1\nEventType\n.\nCUSTOMER_DONE\n.\nlog\n(\ntime\n,\n \ncustomer\n)\n\n\n\n\n\n\n\nto log that particular event.\n\n\nI admit that this example is rather contrived -- we can do the same with a polymorphism in a much cleaner way.\n\n\nThe Class \nEnum\n\n\nenum\n is a special type of class in Java.  All \nenum\n inherits from the class \nEnum\n implicitly.  Since \nenum\n is a class, we can extend \nenum\n from interfaces as per normal class.  Unfortunately, \nenum\n cannot extend another class, since it already extends from \nEnum\n.\n\n\nOne implicitly declared method in \nenum\n is a static method:\n\n\n1\npublic\n \nstatic\n \nE\n[]\n \nvalues\n();\n\n\n\n\n\n\n\nWe can call \nEventType.values()\n or \nColor.values()\n to return an array  of event types or an array of colors.  \nE\n is a type parameter, corresponding to the enum type (either \nEventType\n, \nColor\n, etc).  To maintain flexibility and type safety, the class \nEnum\n which all enums inherit from has to be a generic class with \nE\n as a type parameter.\n\n\nConsidering \nEventType\n,\n\n1\n2\n3\n4\nenum\n \nEventType\n \n{\n\n  \nCUSTOMER_ARRIVE\n,\n \n  \nCUSTOMER_DONE\n\n\n}\n\n\n\n\n\n\nis actually \n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\npublic\n \nfinal\n \nclass\n \nEventType\n \nextends\n \nEnum\n<\nEventType\n>\n \n{\n\n  \npublic\n \nstatic\n \nfinal\n \nEventType\n[]\n \nvalues\n \n{\n \n..\n \n}\n\n  \npublic\n \nstatic\n \nEventType\n \nvalueOf\n(\nString\n \nname\n)\n \n{\n \n..\n \n}\n\n\n  \npublic\n \nstatic\n \nfinal\n \nEventType\n \nCUSTOMER_ARRIVE\n;\n\n  \npublic\n \nstatic\n \nfinal\n \nEventType\n \nCUSTOMER_DONE\n;\n\n    \n:\n\n\n  \nstatic\n \n{\n\n    \nCUSTOMER_ARRIVE\n \n=\n \nnew\n \nEventType\n();\n\n    \nCUSTOMER_DONE\n \n=\n \nnew\n \nEventType\n();\n\n      \n:\n\n  \n}\n\n\n}\n\n\n\n\n\n\nEven though we can't extend from \nEnum\n directly, Java wants to ensure that \nE\n must be a subclass of \nEnum\n (so that we can't do something non-sensical like \nEnum<String>\n.  Furthermore, some methods from \nEnum\n (such as \ncompareTo()\n) are inherited to the enum class, and these methods involved generic type \nE\n.  To ensure that the generic type \nE\n actually inherits from \nEnum<E>\n, Java defines the class \nEnum\n to have bounded generic type \nEnum<E extends Enum<E>>\n.\n\n\nThe expansion of enum \nEventType\n to a class above also illustrates a few points:\n\n\n\n\nAn \nenum\n is final.  We cannot inherit from enum (those with constant-specific body are exceptions).\n\n\nA class in Java can contain fields of the same class.\n\n\nThe block marked by \nstatic { .. }\n are \nstatic initializers\n, they are called when the class is first used.  They are the counterpart to constructors for objects, and are useful for non-trivial initialization of static fields in a class.\n\n\n\n\nEnum-related Collections\n\n\nJava Collection Frameworks provide two useful classes \nEnumSet\n and \nEnumMap\n -- they can be viewed as special cases of \nHashSet\n and \nHashMap\n respectively -- the only difference is that we can only put enum values into \nEnumSet\n and enum-type keys into \nEnumMap\n. \n\n\nExercise\n\n\n\n\n\n\nExplain how each of the following language features of Java ensures type safety. You can give an example.\n\n\n(a) enum\n(b) generics\n\n\n\n\n\n\nConsider the program below:\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nclass\n \nB\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n\n    \nint\n \nx\n \n=\n \n0\n;\n\n\n    \nclass\n \nA\n \n{\n\n      \nint\n \ny\n \n=\n \n0\n;\n\n      \nA\n()\n \n{\n\n        \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n      \n}\n\n    \n}\n\n\n    \nA\n \na\n \n=\n \nnew\n \nA\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nSuppose that a variable \nb\n is an instance of class \nB\n, and a program calls \nb.f()\n. Sketch the content of the stack and heap immediately after the Line \nA a = new A()\n is executed. Label the values and variables / fields clearly. You can assume b is already on the heap and you can ignore all other content of the stack and the heap before \nb.f()\n is called.",
            "title": "6. hashCode, Nested Class, enum"
        },
        {
            "location": "/lec06/index.html#lecture-6-hash-code-nested-classes-enum",
            "text": "",
            "title": "Lecture 6: Hash Code, Nested Classes, Enum"
        },
        {
            "location": "/lec06/index.html#learning-outcomes",
            "text": "Understand the need to override  hashCode  whenever  equals  is overridden and how to use  Arrays '  hashCode  method to compute a hash code  Understand static vs. non-static nested class, local class, and anonymous class and when to use / not to use one  Understand the rules about final / effectively final variable access for local class and anonymous class  Aware of the limitation when declaring a new anonymous class  Understand the concept of variable capture  Be aware that  enum  is a special case of a  class  and share many features as a class -- not just constants can be defined.  Understand how  enum  is expanded into a subclass of  Enum  Know that enum constants can have customized fields and methods.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/lec06/index.html#1-hash-code",
            "text": "We have seen how  HashMap  in Java Collections allows us to store a key-value pair and lookup a value with the key, and how  HashSet  stores item with no duplicates.   Internally,  HashMap  and  HashSet  organize the items into \"buckets\".  Such organization improves efficiency if we need to search through the items, either to find a pair with a given key, or to check if an item already exists in the set.  We no longer need to search through the entire collection, but only the \"bucket\" that the item, if exists, would have been organized into.  For this idea to work, each item must be  hashed  deterministically into a bucket.   In Java objects, such hashing operation is determined by the method  hashCode()  of a given key object.   hashCode()  returns an  int , which  HashMap ,  HashSet , or other data structures can use to determine which \"bucket\" to store a (key, value) pair or an item into.  You will learn more about hashing and hash tables in CS2040.  But, what is important here is that two keys (two objects, in general) which are the same ( equals()  returns  true ), must have the same  hashCode() .  Otherwise,  HashMap  would fail.  So it is important to ensure that if  o1.equals(o2) , then  o1.hashCode() == o2.hashCode() .  Note that the reverse does not have to be true -- two objects with the same hash code does not have to be equals.  This property is also useful for implementing  equals() .  For a complex object, comparing every field for equality can be expensive.  If we can compare the hash code first, we could filter out objects with different hash code (since they cannot be equal).  We only need to compare field by field if the hash code is the same.  Let's see some example:  1\n2\n3\n4\n5\n6 String   s1   =   \"hello\" ;  String   s2   =   new   String ( \"hello\" );  String   s3   =   \"goodbye\" ;  s1 . hashCode ();  s2 . hashCode ();  s3 . hashCode ();    Lines 4-5 both return 99162326, an integer value that is calculated using a mathematical function, called  hash function , so that two strings with the same content returns the same value.  Line 6 returns 207022353.  We can see the problem when we don't define  hashCode() .  Take our  Point  class from before:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 jshell >   Point   p   =   new   Point ( 0 , 0 );  p   ==>   ( 0.0 , 0.0 )  jshell >   Point   q   =   new   Point ( 0 , 0 );  q   ==>   ( 0.0 , 0.0 )  jshell >   p . equals ( q );  $5   ==>   true  jshell >   HashSet < Point >   set   =   new   HashSet <>();  set   ==>   []  jshell >   set . add ( p );  $7   ==>   true  jshell >   set . add ( q );  $8   ==>   true  jshell >   set  set   ==>   [( 0.0 , 0.0 ),   ( 0.0 , 0.0 )]    You can see that we have added two points that are the same into the set, which usually is not what we want.  To fix this, we need to write our own  hashCode() , by overriding the  hashCode()  method in the  Object  class.  Calculating good hash code is an involved topic, and is beyond the scope of CS2030.  In Java, the utility class  Arrays  provide us some convenient  hashCode  methods to help us.  We can pack the fields of a class into an array, and then call  Arrays.hashCode()  to compute the hash code of these fields.  Let's add the following to  Point :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   Point   { \n     : \n   @Override \n   public   int   hashCode ()   { \n     double []   a   =   new   double [ 2 ]; \n     a [ 0 ]   =   this . x ; \n     a [ 1 ]   =   this . y ; \n     return   Arrays . hashCode ( a ); \n   }  }    Now,  set.add(q)  above returns false -- we can no longer add point (0,0) twice in to the set.   XOR-ing hash codes  If you have fields in a class that are of different types (and cannot be packed into a single array), you can pack them into different arrays, call  Arrays.hashCode()  for each of the arrays, and combine the hash code together with the XOR operator  ^ .  XOR is mathematically a good operator for combining two hash codes, since given two numbers with equal distribution of 0s and 1s, XOR-ing them will give another number with equal distribution of 0s and 1s.",
            "title": "1. Hash Code"
        },
        {
            "location": "/lec06/index.html#2-nested-class",
            "text": "The second topic for today is nested class.  There are four kinds of nested classes in Java.  You have seen a static nested class, used inappropriately in  Lab 1a .  Let's see where are some good use cases to use nested classes.  Nested classes are used to group logically relevant classes together.  Typically, a nested class is tightly coupled with the container class, and would have no use outside of the container class.  Nested classes can be used to encapsulate information within a container class, for instance, when implementation of a class becomes too complex.  As such, it is useful for \"helper\" classes that serve specific purposes.  A nested class is a field of the containing class, and can access fields and methods of the containing class, including those declared as  private .  We can keep the nested class within the abstraction barrier, and declare a nested class as  private , if there is no need for it to be exposed to the client outside the barrier.\nOn the other hand, because of this, you should really have a nested class only if the nested class belongs to the same encapsulation.  Otherwise, the containing class would leak its implementation details to the nested class.   Take the  HashMap<K,V>  class for instance.   The implementation of  HashMap<K,V>  contains several nested classes, including  HashIterator , which implement an  Iterator<E>  interface for iterating through the key and value pairs in the map, and an  Entry<K,V>  class, which encapsulates a key-value pair in the map.  Some of these classes are declared  private , if they are only used within the  HashMap<K,V>  class.  A nested class can be either static or non-static.  Just like static fields and static methods, a  static nested class  is associated with the containing  class , NOT an  instance .  So, it can only access static fields and static methods of the containing class.  A  non-static nested class , on the other hand, can access all fields and methods of the containing class.  A  non-static nested class  is also known as an  inner class .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   private   int   x ; \n   static   int   y ; \n\n   class   B   { \n     void   foo ()   { \n       x   =   1 ;   // accessing x from A is OK \n     } \n   } \n\n   static   class   C   { \n     void   bar ()   { \n       x   =   1 ;   // accessing x from A is not OK since C is static \n       y   =   1 ;   // accessing y is OK \n     } \n   }  }",
            "title": "2. Nested Class"
        },
        {
            "location": "/lec06/index.html#local-class",
            "text": "We can also declare a class within a function as well, just like a local variable.  One example is the  NameComparator  class in  Lecture 5 .  In that example, we created another top-level class (and so, a new file) just to define how to compare two strings, which is a little bit silly.  We can actually just define the  NameComparator  class when we need it, just before we sort:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 void   sortNames ( List < String >   names )   { \n\n   class   NameComparator   implements   Comparator < String >   { \n     public   int   compare ( String   s1 ,   String   s2 )   { \n       return   s1 . length ()   -   s2 . length (); \n     } \n   } \n\n   names . sort ( new   NameComparator ());  }    This makes the code easier to read since we keep the definition of the class and its usage closer together.   Classes like  NameComparator  that are declared inside a method (to be more precise, inside a block of code between  {  and  } ) is called a  local class .  Just like a local variable, a local class is scoped within the method.  Like a nested class, a local class has access to the variables of the enclosing class.  Further, it can access the variables of the local variables of the enclosing method.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   A   { \n   int   x   =   1 ; \n\n   void   f ()   { \n     int   y   =   1 ; \n\n     class   B   { \n       void   g ()   { \n         x   =   y ;   // accessing x and y is OK. \n       } \n     } \n\n     new   B (). g (); \n   }  }",
            "title": "Local Class"
        },
        {
            "location": "/lec06/index.html#variable-capture",
            "text": "Recall that when a method returns, all local variables of the methods are removed from the stack.  But, an instance of that local class might still exist.  Consider the following example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 interface   C   { \n   void   g ();  }  class   A   { \n   int   x   =   1 ; \n\n   C   f ()   { \n     int   y   =   1 ; \n\n     class   B   implements   C   { \n       void   g ()   { \n         x   =   y ;   // accessing x and y is OK. \n       } \n     } \n\n     B   b   =   new   B (); \n     return   b ; \n   }  }    Calling  1\n2\n3 A   a   =   new   A ();  C   b   =   a . f ();  b . g ();    will give us a reference to an object of type  B  now.  But, if we call  b.g() , what is the value of  y ?   For this reason, even though a local class can access the local variables in the enclosing method, the local class makes  a copy of local variables  inside itself.  We say that a local class  captures  the local variables.",
            "title": "Variable Capture"
        },
        {
            "location": "/lec06/index.html#effectively-final",
            "text": "Variable captures could be confusing.  Consider the following code:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 void   sortNames ( List < String >   names )   { \n   boolean   ascendingOrder   =   true ; \n   class   NameComparator   implements   Comparator < String >   { \n     public   int   compare ( String   s1 ,   String   s2 )   { \n       if   ( ascendingOrder )  \n         return   s1 . length ()   -   s2 . length (); \n       else  \n         return   s2 . length ()   -   s1 . length (); \n     } \n   } \n\n   ascendingOrder   =   false ; \n   names . sort ( new   NameComparator ());  }    Will  sort  sorts in ascending order or descending order?  To avoid confusing code like this, Java only allows a local class to access variables that are explicitly declared  final  or implicitly final (or  effectively  final).  An implicitly final variable is one that does not change after initialization.  Therefore, Java saves us from such hair-pulling situation and disallow such code --  ascendingOrder  is not effectively final so the code above does not compile.   Variable Capture in Javascript  Those of you who did CS1101S or otherwise familiar with Javascript might want to note that this is different from Javascript, which does not enforce the final/effectively final restriction in variable captures.   I do not see a good use case for local class -- if you have information and behavior inside a block of code that is so complex that you need to encapsulate it within a local class, it is time to rethink your design.  What about the use case of  NameComparator  above?  There are actually better ways to write the class.  We will look at  anonymous class  today.",
            "title": "Effectively final"
        },
        {
            "location": "/lec06/index.html#anonymous-class",
            "text": "An anonymous class is one where you declare a class and instantiate it in a single statement.  It's anonymous since We do not even have to give the class a name. 1\n2\n3\n4\n5 names . sort ( new   Comparator < String >()   { \n   public   int   compare ( String   s1 ,   String   s2 )   { \n     return   s1 . length ()   -   s2 . length (); \n   }  });    The example above removes the need to declare a class just for the purpose of comparing two strings.    An anonymous class has the following format:  new X (arguments) { body } , where:   X  is a class that the anonymous class extends or an interface that the anonymous class implements.  X cannot be empty.  This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time.  Furthermore, an anonymous class cannot implement more than one interface.   arguments  are the arguments that you want to pass into the constructor of the anonymous class.  If the anonymous class is extending an interface, then there is no constructor, but we still need  () .  body  is the body of the class as per normal, except that we cannot have a constructor for an anonymous class.   The syntax might look overwhelming at the beginning, but we can also write it as:  1\n2\n3\n4\n5\n6 Comparator < String >   cmp   =   new   Comparator < String >()   { \n   public   int   compare ( String   s1 ,   String   s2 )   { \n     return   s1 . length ()   -   s2 . length (); \n   }  };  names . sort ( cmp );    Line 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a  { .. }  body.  An anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local class applies.",
            "title": "Anonymous Class"
        },
        {
            "location": "/lec06/index.html#3-enum",
            "text": "An  enum  is a special type of class in Java.  Variable of an enum type can only be one of the predefined constants.  Using enum has one advantage over the use of  int  for predefined constant -- it is type safe.  Consider how we have been defining different event types in  Lab 1a .  1\n2    public   static   final   int   CUSTOMER_ARRIVE   =   1 ; \n   public   static   final   int   CUSTOMER_DONE   =   2 ;    But, we cannot prevent someone from creating an event  new Event(time, 100) , passing in an invalid event type (type 100).    If we define the event type as enum, then we can write like this:  1\n2\n3\n4 enum   EventType   { \n   CUSTOMER_ARRIVE ,  \n   CUSTOMER_DONE  }    and the field  eventType  in  Event  now has a type  EventType  instead of  int : 1\n2\n3\n4 class   Event   { \n   private   double   time ;  \n   private   EventType   eventType ;   }    Trying to assign anything other than the two predefined event type to  eventType  would result in compilation error.  Remember, an error caught at compile time is much better than an error caught during run time, so this is good!   In other languages  Enumerated types like  enum  are common in other langauges, including procedural languages like C.  But,  enum  in Java is more powerful, as seen below.",
            "title": "3. Enum"
        },
        {
            "location": "/lec06/index.html#enums-fields-and-methods",
            "text": "Each constant of an enum type is actually an instance of the enum class and is a field in the enum class declared with  public static final . \nSince enum in Java is a class, we can define constructors, methods, and fields in enums.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 enum   Color   { \n   BLACK ( 0 ,   0 ,   0 ), \n   WHITE ( 1 ,   1 ,   1 ), \n   RED ( 1 ,   0 ,   0 ), \n   BLUE ( 0 ,   0 ,   1 ), \n   GREEN ( 0 ,   1 ,   0 ), \n   YELLOW ( 1 ,   1 ,   0 ), \n   PURPLE ( 1 ,   0 ,   1 ); \n\n   private   final   double   r ; \n   private   final   double   g ; \n   private   final   double   b ; \n\n   Color ( double   r ,   double   g ,   double   b )   { \n     this . r   =   r ; \n     this . g   =   g ; \n     this . b   =   b ; \n   } \n\n   public   double   luminance ()   { \n     return   ( 0.2126   *   r )   +   ( 0.7152   *   g )   +   ( 0.0722   *   b ); \n   } \n\n   public   String   toString ()   { \n     return   \"(\"   +   r   +   \", \"   +   g   +   \", \"   +   b   +   \")\" ; \n   }  }    In the example above, we represent a color with its RGB component.  Enum values should only constants, so  r ,  g ,  b  are declared as  final .  We have a method that computes the luminance (the \"brightness\") of a color, and a  toString()  method.    The enum values are now written as  BLACK(0, 0, 0) , with arguments passed into its constructor.",
            "title": "Enum's Fields and Methods"
        },
        {
            "location": "/lec06/index.html#custom-methods-for-each-enum",
            "text": "Enum in Java is more powerful than the above -- we can define custom methods for each of the enum constant, by writing  constant-specific class body .  If we do this, then each constant becomes an anonymous class that extends the enclosing enum.     Consider the enum  EventType .  You can do the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 enum   EventType   { \n   CUSTOMER_ARRIVE   { \n     void   log ( double   time ,   Customer   c )   { \n       System . out . println ( time   +   \" \"   +   c   +   \" arrives\" ); \n     } \n   }, \n   CUSTOMER_DONE   { \n     void   log ( double   time ,   Customer   c )   { \n       System . out . println ( time   +   \" \"   +   c   +   \" done\" ); \n     } \n   }; \n\n   abstract   void   log ( double   time ,   Customer   c );  }    In the code above,  EventType  is an abstract class --  log  is defined as  abstract  with no implementation.  Each enum constant has its own implementation to log that particular event.  1 EventType . CUSTOMER_DONE . log ( time ,   customer )    to log that particular event.  I admit that this example is rather contrived -- we can do the same with a polymorphism in a much cleaner way.",
            "title": "Custom Methods for Each Enum"
        },
        {
            "location": "/lec06/index.html#the-class-enum",
            "text": "enum  is a special type of class in Java.  All  enum  inherits from the class  Enum  implicitly.  Since  enum  is a class, we can extend  enum  from interfaces as per normal class.  Unfortunately,  enum  cannot extend another class, since it already extends from  Enum .  One implicitly declared method in  enum  is a static method:  1 public   static   E []   values ();    We can call  EventType.values()  or  Color.values()  to return an array  of event types or an array of colors.   E  is a type parameter, corresponding to the enum type (either  EventType ,  Color , etc).  To maintain flexibility and type safety, the class  Enum  which all enums inherit from has to be a generic class with  E  as a type parameter.  Considering  EventType , 1\n2\n3\n4 enum   EventType   { \n   CUSTOMER_ARRIVE ,  \n   CUSTOMER_DONE  }    is actually   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 public   final   class   EventType   extends   Enum < EventType >   { \n   public   static   final   EventType []   values   {   ..   } \n   public   static   EventType   valueOf ( String   name )   {   ..   } \n\n   public   static   final   EventType   CUSTOMER_ARRIVE ; \n   public   static   final   EventType   CUSTOMER_DONE ; \n     : \n\n   static   { \n     CUSTOMER_ARRIVE   =   new   EventType (); \n     CUSTOMER_DONE   =   new   EventType (); \n       : \n   }  }    Even though we can't extend from  Enum  directly, Java wants to ensure that  E  must be a subclass of  Enum  (so that we can't do something non-sensical like  Enum<String> .  Furthermore, some methods from  Enum  (such as  compareTo() ) are inherited to the enum class, and these methods involved generic type  E .  To ensure that the generic type  E  actually inherits from  Enum<E> , Java defines the class  Enum  to have bounded generic type  Enum<E extends Enum<E>> .  The expansion of enum  EventType  to a class above also illustrates a few points:   An  enum  is final.  We cannot inherit from enum (those with constant-specific body are exceptions).  A class in Java can contain fields of the same class.  The block marked by  static { .. }  are  static initializers , they are called when the class is first used.  They are the counterpart to constructors for objects, and are useful for non-trivial initialization of static fields in a class.",
            "title": "The Class Enum"
        },
        {
            "location": "/lec06/index.html#enum-related-collections",
            "text": "Java Collection Frameworks provide two useful classes  EnumSet  and  EnumMap  -- they can be viewed as special cases of  HashSet  and  HashMap  respectively -- the only difference is that we can only put enum values into  EnumSet  and enum-type keys into  EnumMap .",
            "title": "Enum-related Collections"
        },
        {
            "location": "/lec06/index.html#exercise",
            "text": "Explain how each of the following language features of Java ensures type safety. You can give an example.  (a) enum\n(b) generics    Consider the program below:     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 class   B   { \n   void   f ()   { \n     int   x   =   0 ; \n\n     class   A   { \n       int   y   =   0 ; \n       A ()   { \n         y   =   x   +   1 ; \n       } \n     } \n\n     A   a   =   new   A (); \n   }  }    Suppose that a variable  b  is an instance of class  B , and a program calls  b.f() . Sketch the content of the stack and heap immediately after the Line  A a = new A()  is executed. Label the values and variables / fields clearly. You can assume b is already on the heap and you can ignore all other content of the stack and the heap before  b.f()  is called.",
            "title": "Exercise"
        },
        {
            "location": "/lec07/index.html",
            "text": "Lecture 7: Functions\n\n\nLearning Objectives\n\n\nAfter this lecture, students should be familiar with:\n\n\n\n\nthe concept of functions as a side-effect free programming constructs and its relation to functions in mathematics.\n\n\nthe \nFunction\n interface in Java 8, including the methods \napply\n, \ncompose\n, and \nandThen\n methods.\n\n\nthe interfaces \nPredicate\n, \nSupplier\n, \nConsumer\n, and \nBiFunction\n.\n\n\nthe syntax of method reference and lambda expression\n\n\nhow to write functions with multiple arguments using curried functions \n\n\n\n\nJava 8 introduces several new important new features, including lambda expressions and the stream APIs.  We will spend the next few lectures exploring these new features and how it allows us to write more succinct code and hopefully, less buggy code.  The stream APIs also makes it possible for us to parallelize our code for execution on multiple cores/processors with ease.\n\n\nAbstraction Principles Revisited\n\n\nLet's revisit the abstraction principles we first visited in Lecture 2.  It says that \n\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"\n\n\nWe have seen this principle being applied in several ways.\n\n\nFirst, you should be all be familiar with abstracting out code with the same logic but applied to different variables.   Consider the following sample code from \nRandomGenerator\n class:\n\n\n1\n2\n3\n4\n5\n6\n7\n  \ndouble\n \ngenInterArrivalTime\n()\n \n{\n\n    \nreturn\n \n-\nMath\n.\nlog\n(\nthis\n.\nrngArrival\n.\nnextDouble\n())\n \n/\n \nthis\n.\ncustomerArrivalRate\n;\n\n  \n}\n\n\n  \ndouble\n \ngenServiceTime\n()\n \n{\n\n    \nreturn\n \n-\nMath\n.\nlog\n(\nthis\n.\nrngService\n.\nnextDouble\n())\n \n/\n \nthis\n.\ncustomerServiceRate\n;\n\n  \n}\n\n\n\n\n\n\n\nYou can see that the two methods above have similar implementation.  They all generate an exponentially distributed random number, with a different rate using a different random number generator.  One could apply the abstraction principle and write the code as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\ndouble\n \nrandomExponentialValue\n(\nRandom\n \nrng\n,\n \ndouble\n \nrate\n)\n \n{\n\n  \nreturn\n \n-\nMath\n.\nlog\n(\nrng\n.\nnextDouble\n())\n \n/\n \nrate\n;\n\n\n}\n\n\n\ndouble\n \ngenerateServiceTime\n()\n \n{\n\n  \nreturn\n \nrandomExponentialValue\n(\nthis\n.\nrngService\n,\n \nthis\n.\nserviceRate\n);\n\n\n}\n\n\n\ndouble\n \ngenerateInterArrivalTime\n()\n \n{\n\n  \nreturn\n \nrandomExponentialValue\n(\nthis\n.\nrngArrival\n,\n \nthis\n.\narrivalRate\n);\n\n\n}\n\n\n\n\n\n\n\nNow, when we need a new exponentially distributed random number, say for rest period (see Lab 5), you can just write a method that calls \nrandomExponentialValue()\n method with the appropriate \nRandom\n object and rate, without worrying about the formula to generate an exponential random variable.\n\n\n1\n2\n3\ndouble genRestPeriod() {\n  return randomExponentialValue(rngRestPeriod, this.serverRestingRate);\n}\n\n\n\n\n\n\nHere, the varying parts that we abstracted out is the variables.  \n\n\nSecond, consider the \nCircleQueue\n and \nPointQueue\n examples from Lecture 4.  The two classes implement similar methods with similar logic.  The only difference is the type.  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nCircleQueue\n \n{\n\n  \nprivate\n \nCircle\n[]\n \ncircles\n;\n\n   \n:\n\n  \npublic\n \nCircleQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nCircle\n \nc\n)\n \n{...}\n\n  \npublic\n \nCircle\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\nclass\n \nPointQueue\n \n{\n\n  \nprivate\n \nPoint\n[]\n \npoints\n;\n\n   \n:\n\n  \npublic\n \nPointQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nPoint\n \np\n)\n \n{...}\n\n  \npublic\n \nPoint\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nWe then replace the two classes (and any future class that we might write to implement such queues) with a generic \nQueue<T>\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nprivate\n \nT\n[]\n \nobjects\n;\n\n   \n:\n\n  \npublic\n \nQueue\n<\nT\n>(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nT\n \no\n)\n \n{...}\n\n  \npublic\n \nT\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nHere, the varying parts that we abstracted out is the type of the elements.  \n\n\nThird, consider how we tell \nArrayList.sort()\n to sort the items in the array in \nLecture 5\n.  By passing in \nNameComparator\n, we can tell \nArrayList\n to sort in alphabetical order, either in ascending order or descending order, or by the length of the strings, or any other ways we like.   An alternative would be to have our own \nStringList\n class and implements methods \nsortAlphabeticallyAscending()\n, \nsortAlphabeticallyDescending()\n, \nsortByLengthAscending()\n, \nsortByLengthDescending()\n, etc.  But all of these methods would be implementing the same sorting algorithms, the only part that is different is the comparison method to determine the order of the elements.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nimport\n \njava.util.*\n;\n\n\n\nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n  \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n    \n// return (s1.compareTo(s2));\n\n    \n// return (s2.compareTo(s1));\n\n    \nreturn\n \n(\ns2\n.\nlength\n()\n \n-\n \ns1\n.\nlength\n());\n\n  \n}\n\n\n}\n\n\n\nclass\n \nSortedList\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nArrayList\n<\nString\n>();\n\n\n    \nnames\n.\nadd\n(\n0\n,\n \n\"Joffrey\"\n);\n\n    \nnames\n.\nadd\n(\n1\n,\n \n\"Cersei\"\n);\n\n    \nnames\n.\nadd\n(\n2\n,\n \n\"Meryn\"\n);\n\n    \nnames\n.\nadd\n(\n3\n,\n \n\"Walder\"\n);\n\n      \n:\n\n      \n:\n\n\n    \nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nHere, the varying parts that we abstracted out is a snippet of the code, or functionality, of the methods.  This idea is much more powerful than just abstracting out how we compare and sort.  We will see how it can lead to a significantly different way of writing code.\n\n\nFunctions\n\n\nWhile we have been using the terms functions and methods (and occasionally, procedure) interchangeably, we will now use the term function to refer to methods with specific properties.  \n\n\nA function, in mathematics, refers to a mapping from a set of inputs (\ndomain\n) \nX\nX\n to a set of output values (\ncodomain\n) \nY\nY\n.  We write \nf: X \\rightarrow Y\nf: X \\rightarrow Y\n.  Every input in the domain must map to exactly one output but multiple inputs can map to the same output.  Not all values in the codomain need to be mapped.  The set of elements in the codomain that is mapped is called the \nimage\n.  \n\n\nFunctions in programming languages is the same as functions in mathematics.  Given an input, the function computes and returns an output.  A \npure\n function does nothing else -- it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments.  We say that a pure function does not cause any \nside effect\n.  \n\n\nHere are two examples of pure functions:\n\n\n1\n2\n3\n4\n5\n6\n7\nint\n \nsquare\n(\nint\n \ni\n)\n \n{\n\n  \nreturn\n \ni\n \n*\n \ni\n;\n\n\n}\n\n\n\nint\n \nadd\n(\nint\n \ni\n,\n \nint\n \nj\n)\n \n{\n\n  \nreturn\n \ni\n \n+\n \nj\n;\n\n\n}\n\n\n\n\n\n\n\nand some examples of non-pure functions:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nint\n \ndiv\n(\nint\n \ni\n,\n \nint\n \nj\n)\n \n{\n\n  \nreturn\n \ni\n \n/\n \nj\n;\n  \n// may throw an exception\n\n\n}\n\n\n\nint\n \nincrCount\n(\nint\n \ni\n)\n \n{\n\n  \nreturn\n \nthis\n.\ncount\n \n+\n \ni\n;\n \n// assume that count is not final.\n\n                         \n// this may give diff results for the same i.\n\n\n}\n\n\n\nvoid\n \nincrCount\n(\nint\n \ni\n)\n \n{\n\n  \nthis\n.\ncount\n \n+=\n \ni\n;\n \n// does not return a value\n\n                   \n// and has side effects on count\n\n\n}\n\n\n\nint\n \naddToList\n(\nArrayList\n \nqueue\n,\n \nint\n \ni\n)\n \n{\n\n  \nqueue\n.\nadd\n(\ni\n);\n  \n// has side effects on queue\n\n\n}\n\n\n\n\n\n\nA pure function must also be deterministic.  Given the same input, the function must produce the same output, \nevery single time\n.\n\n\nIn OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance.  Such methods are not pure functions.  How do we write classes with methods that do not have side effects (do not update the fields in the class)?  We can do so by making our class \nimmutable\n.  Recall that classes such as \nString\n are immutable.  If we want to modify a \nString\n object, we have to create a new one containing the modified string.  Such operations on the \nString\n object has no side-effect (the original string is still in tact).\n\n\nIn computer science, we refer to the style of programming where we build a program from pure functions as \nfunctional programming\n (FP).  Many modern programming languages, such as Java, now supports this style of programming.  As Java is inherently still an OO language, we cannot build a program from only pure functions.  As such, I will refer to this style as \nfunctional-style programming\n within an OO language.\n\n\nWhile the notion of pure functions might seems restrictive, recall how many times your program has a bug that is related to incorrect side effects or unintended side effects?  Or, how much effort is needed to trace through the code in different classes to see what is going on in one line of code.  Take the following line, for instance,\n\n\n1\nserver\n.\nserve\n(\ncustomer\n);\n\n\n\n\n\n\n\nWhat is updated in the server?  How about the customer?  Is the variable \nnumOfServedCustomer\n updated?  Is a new \nDoneEvent\n being created and scheduled?\n\n\nIf we design and write our program with pure functions as much as possible, we could significantly reduce the number of bugs.\n\n\nMichael Feathers tweeted that \"(OO makes code understandable by encapsulating moving parts.  FP makes code understandable by minimizing moving parts.)[\nhttps://twitter.com/mfeathers/status/29581296216?lang=en\n]\"  The moving parts here refers to changing states.  He succintly highlights one of the major differences between OOP and FP.\n\n\nIn mathematics, we say that a mapping is a \npartial function\n if not all elements in the domain are mapped.   A common programming error is to treat a partial function like a function -- for instance, the \ndiv\n method above is written as if it is defined for all int values, but it is not defined when \nj\n is 0.  Another common error is that a function may produce a value that is not in the codomain, e.g., \nnull\n.  \n\n\nMathematically, a function takes in only one value and return one value (e.g., \nsquare\n above).  In programming, we often need to write functions that take in more than one arguments (e.g., \nadd\n above).  We will see how to reconcile this later.\n\n\nThe \nFunction\n interface in Java 8\n\n\nLet's explore functions in Java 8 by looking at the \nFunction\n interface, it is a generic interface with two type parameters, \nFunction<T, R>\n, \nT\n is the type of the input, \nR\n is the type of the Result.  It has one abstract method \nR apply(T t)\n that applies the function to a given argument.\n\n\nLet's write a class that implements \nFunction\n.\n\n\n1\n2\n3\n4\n5\nclass\n \nSquare\n \nimplements\n \nFunction\n<\nInteger\n,\n \nInteger\n>\n \n{\n\n  \npublic\n \nInteger\n \napply\n(\nInteger\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n*\nx\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nTo use it, we can:\n\n1\nint\n \nx\n \n=\n \nnew\n \nSquare\n().\napply\n(\n4\n);\n\n\n\n\n\n\nSo far, everything is as you have seen before, and is significantly more complex than just writing:\n\n\n1\nint\n \nx\n \n=\n \nsquare\n(\n4\n);\n\n\n\n\n\n\n\nSo, what is the use of this?  Consider now if we have a \nList<Integer>\n of integers, and we want to return another list where the elements are the square of the first list.  We can write a method:\n\n1\n2\n3\n4\n5\n6\n7\nList\n<\nInteger\n>\n \nsquareList\n(\nList\n<\nInteger\n>\n \nlist\n)\n \n{\n\n  \nList\n<\nInteger\n>\n \nnewList\n \n=\n \nnew\n \nArrayList\n<\nInteger\n>();\n\n  \nfor\n \n(\nInteger\n \ni\n:\n \nlist\n)\n \n{\n\n    \nnewList\n.\nadd\n(\nsquare\n(\ni\n));\n\n  \n}\n\n  \nreturn\n \nnewList\n;\n\n\n}\n\n\n\n\n\nCreating a new list out of an existing list is actually a common pattern.  We might want to, say, create a list with the absolute values:\n\n1\n2\n3\n4\n5\n6\n7\nList\n<\nInteger\n>\n \nnegativeList\n(\nList\n<\nInteger\n>\n \nlist\n)\n \n{\n\n  \nList\n<\nInteger\n>\n \nnewList\n \n=\n \nnew\n \nArrayList\n<\nInteger\n>();\n\n  \nfor\n \n(\nInteger\n \ni\n:\n \nlist\n)\n \n{\n\n    \nnewList\n.\nadd\n(\nMath\n.\nabs\n(\ni\n));\n\n  \n}\n\n  \nreturn\n \nnewList\n;\n\n\n}\n\n\n\n\n\n\nThis is actually a common pattern.  Applying the abstraction principle, we can generalize the method to:\n\n1\n2\n3\n4\n5\n6\n7\nList\n<\nInteger\n>\n \napplyList\n(\nList\n<\nInteger\n>\n \nlist\n,\n \nFunction\n<\nInteger\n,\nInteger\n>\n \nf\n)\n \n{\n\n  \nList\n<\nInteger\n>\n \nnewList\n \n=\n \nnew\n \nArrayList\n<\nInteger\n>();\n\n  \nfor\n \n(\nInteger\n \ni\n:\n \nlist\n)\n \n{\n\n    \nnewList\n.\nadd\n(\nf\n.\napply\n(\ni\n));\n\n  \n}\n\n  \nreturn\n \nnewList\n;\n\n\n}\n\n\n\n\n\n\nand call:\n\n1\napplyList\n(\nlist\n,\n \nnew\n \nSquare\n());\n\n\n\n\n\n\nto return a list of squares.\n\n\nIf we do not want to create a new class just for this, we can, as before, use an anonymous class:\n\n1\n2\n3\n4\n5\napplyList\n(\nlist\n,\n \nnew\n \nFunction\n<\nInteger\n,\nInteger\n>()\n \n{\n \n  \npublic\n \nInteger\n \napply\n(\nInteger\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n \n*\n \nx\n;\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\nMap\n\n\nThe \napplyList\n method above is most commonly referred to as \nmap\n.\n\n\n\n\nLambda Expression\n\n\nThe code is still pretty ugly, and there is much boiler plate code.  The key line is actually Line 3 above, \nreturn x * x\n.  Fortunately, Java 8 provides a clean way to write this:\n\n\n1\n2\n3\napplyList\n(\nlist\n,\n \n(\nInteger\n \nx\n)\n \n->\n \n{\n \nreturn\n \nx\n \n*\n \nx\n;\n \n});\n\n\napplyList\n(\nlist\n,\n \nx\n \n->\n \n{\n \nreturn\n \nx\n \n*\n \nx\n;\n \n});\n\n\napplyList\n(\nlist\n,\n \nx\n \n->\n \nx\n \n*\n \nx\n);\n\n\n\n\n\n\n\nThe expressions above, including \nx -> x * x\n, are \nlambda expressions\n.  You can recognize one by the use of \n->\n.   The left hand side lists the arguments (use \n()\n if there is no argument), while the right hand side is the computation.  We do not need the type in cases where Java can infer the type, nor need the return statements and the curly brackets.\n\n\n\n\nlambda\n\n\nAlonzo Church invented lambda calculus (\n\\lambda\n\\lambda\n-calculus) in 1936, before electronic computers, as a way to express computation.  In \n\\lambda\n\\lambda\n-calculus, all functions are anonymous.  The term lambda expression originated from there.\n\n\n\n\nWe can use lambda expressions just like any other values in Java.  We have seen above that we can pass a lambda expression to a method.  We can also assign a lambda expression to a variable:\n\n1\n2\nFunction\n<\nInteger\n,\nInteger\n>\n \nsquare\n \n=\n \nx\n \n->\n \nx\n \n*\n \nx\n;\n\n\nsquare\n.\napply\n(\n4\n);\n\n\n\n\n\n\nMethod Reference\n\n\nWe can use a lambda expression to implement \napplyList\n with \nabs()\n method in \nMath\n.\n\n1\napplyList\n(\nlist\n,\n \nx\n \n->\n \nMath\n.\nabs\n(\nx\n));\n\n\n\n\n\n\nIf we look carefully at \nabs()\n, however, it takes in an \nint\n, and returns an \nint\n.  So, it already fits the \nFunction<Integer,Integer>\n interface (with autoboxing and unboxing).  As such, we can refer to the method with a method reference: \nMath::abs\n.  The code above can be simplified to:\n\n1\napplyList\n(\nlist\n,\n \nMath\n::\nabs\n);\n\n\n\n\n\n\nAgain, we can assign method reference and pass them around like any other objects.\n\n1\n2\nFunction\n<\nInteger\n,\nInteger\n>\n \nf\n \n=\n \nMath\n::\nabs\n;\n\n\nf\n.\napply\n(-\n4\n);\n\n\n\n\n\n\nComposing Functions\n\n\nThe \nFunction\n interface has two default methods:\n\n1\n2\ndefault\n \n<\nV\n>\n \nFunction\n<\nT\n,\nV\n>\n \nandThen\n(\nFunction\n<?\n \nsuper\n \nR\n,?\n \nextends\n \nV\n>\n \nafter\n);\n\n\ndefault\n \n<\nV\n>\n \nFunction\n<\nV\n,\nR\n>\n \ncompose\n(\nFunction\n<?\n \nsuper\n \nV\n,?\n \nextends\n \nT\n>\n \nbefore\n);\n\n\n\n\n\n\nfor composing two functions.  The term \ncompose\n here is used in the mathematical sense (i.e., the \n\\cdot\n\\cdot\n operator in \nf \\cdot g\nf \\cdot g\n).\n\n\nThese two methods, \nandThen\n and \ncompose\n, return another function, and they are generic methods with type parameter \n<V>\n.  Suppose we want to write a function that returns the square root of the absolute value of an int, we can write:\n\n1\n2\n3\ndouble\n \nSquareRootAbs\n(\nint\n \nx\n)\n \n{\n\n  \nreturn\n \nMath\n.\nsqrt\n(\nMath\n.\nabs\n(\nx\n));\n\n\n}\n\n\n\n\n\n\nor, we can write either\n\n1\n2\n3\nFunction\n<\nInteger\n,\nInteger\n>\n \nabs\n \n=\n \nMath\n::\nabs\n;\n\n\nFunction\n<\nInteger\n,\nDouble\n>\n \nsqrt\n \n=\n \nMath\n::\nsqrt\n;\n\n\napplyList\n(\nlist\n,\n \nabs\n.\nandThen\n(\nsqrt\n))\n\n\n\n\n\n\nor \n\n1\n2\nsqrt\n.\ncompose\n(\nabs\n)\n\n\napplyList\n(\nlist\n,\n \nsqrt\n.\ncompose\n(\nabs\n))\n\n\n\n\n\n\nBut isn't writing the plain old method \nSquareRootAbs()\n clearer?  Why bother with \nFunction\n?  The difference is that, \nSquareRootAbs()\n has to be written before we compile our code, and is fixed once we compile.  Using the \nFunction\n interface, we can compose functions at \nrun time\n, dynamically as needed! \n\n\n\n\nIn other languages\n\n\nLambda expression and \nFunction\ns are introduced in Java only recently in Java 8, and still relies on classes and interfaces internally to implement them.  As such, despite the elegance and beauty of pure functions, the syntax for it in Java is neither elegant nor pretty.  Take Haskell, a pure functional programming language, for example.  To compose two functions, we can use the \n.\n operator: \nsqrt . abs\n\n\n\n\nGenerics Revisited: PECS\n\n\nWe will see many functional generic interfaces with bounded wildcards, so it is worth to spend a little more time to understand what is going on here. Take \nandThen\n for example:\n\n\n1\ndefault\n \n<\nV\n>\n \nFunction\n<\nT\n,\nV\n>\n \nandThen\n(\nFunction\n<?\n \nsuper\n \nR\n,?\n \nextends\n \nV\n>\n \nafter\n);\n\n\n\n\n\n\n\nwhich is a method in the interface \nFunction<T,R>\n.  The method declaration would be clearer if it is written as\n\n1\ndefault\n \n<\nV\n>\n \nFunction\n<\nT\n,\nV\n>\n \nandThen\n(\nFunction\n<\nR\n,\n \nV\n>\n \nafter\n);\n\n\n\n\n\n\nHere, composing a function \nT :\\rightarrow R\nT :\\rightarrow R\n followed by \nR :\\rightarrow V\nR :\\rightarrow V\n gives us a function \nT \\rightarrow V\nT \\rightarrow V\n.  The issue with this \nandThen\n declaration, is that it is not very general.  The argument \nafter\n must be exactly a function with argument type \nR\nR\n and return type \nV\nV\n.  \n\n\nWe can make the method more general, but allowing it to take a function with \nR\n or any superclass of \nR\n as input -- surely if the function can take in a superclass of \nR\n, it can take in \nR\n.   Thus, we can relax input type, or what the function \nconsumes\n, from \nR\n to \n? super R\n.\n\n\nSimilarly, if we are expecting the function \nafter\n to return a more general type \nV\n, it is fine if it returns \nV\n or a subclass of \nV\n.  Thus, we can relax the return type, or what the function \nproduces\n, from \nV\n to \n? extends V\n.\n\n\nBoth are widening type conversions that are safe.  \n\n\nThis introduces us to a principle of using generics, with a mnemonic \"producer \nextends\n; consumer \nsuper\n\", or PECS, for short.\n\n\nOther Functions\n\n\nJava 8 package \njava.util.function\n provides other useful interfaces, including:\n\n\n\n\nPredicate<T>\n with a \nboolean test(T t)\n method \n\n\nSupplier<T>\n with a \nT get()\n method\n\n\nConsumer<T>\n with a \nvoid accept(T t)\n method\n\n\nBiFunction<T,U,R>\n with a \nR apply(T t, U u)\n method\n\n\n\n\nOther variations that involve primitive types are also provided.\n\n\nHere are some examples of how these types are used:\n\n1\n2\n3\n4\n5\n6\n7\n8\nPredicate\n<\nInteger\n>\n \nisEven\n \n=\n \nx\n \n->\n \n(\nx\n \n%\n \n2\n)\n \n==\n \n0\n;\n \n\n\nRandom\n \nrng\n \n=\n \nnew\n \nRandom\n(\n1\n);\n\n\nSupplier\n<\nInteger\n>\n \nrandomInteger\n \n=\n \n()\n \n->\n \nrng\n.\nnextInt\n();\n \n\n\nConsumer\n<\nBoolean\n>\n \nprinter\n \n=\n \nSystem\n.\nout\n::\nprintln\n;\n \n\n\nprinter\n.\naccept\n(\nisEven\n.\ntest\n(\nrandomInteger\n.\nget\n()));\n\n\n\n\n\n\n\n\nImpure Functions\n\n\nSince we use a random number generator, \nrandomInteger\n is not a pure function -- invoking it changes the internal state of the random number generator, causing it to give us a different number the next time it is invoked.  So is the function \nprinter\n, which causes a side effect of having something printed on the standard output.  While there are ways to generate random numbers and perform I/O in functional way, I prefer to keep things simple in CS2030 and use random generator and I/O in the traditional way when we explore functional-style programming.  We should still isolate these non-pure functions with clear variable names so that the intention of the program is clear.\n\n\n\n\nCurried Functions\n\n\nFunctions have an \narity\n.  The \nFunction\n interface is for unary functions that take in a single argument; the \nBiFunction\n inteface for binary functions, with two arguments.  But we can have functions that take more than two arguments.  We can, however, build functions that take in multiple arguments with only unary functions.   Let's look at this mathematically first.  Consider a binary function \nf: (X, Y) \\rightarrow Z\nf: (X, Y) \\rightarrow Z\n.  We can introduce \nF\nF\n as a set of all functions \nf': Y \\rightarrow Z\nf': Y \\rightarrow Z\n, and rewrite \nf\nf\n as \nf: X \\rightarrow F\nf: X \\rightarrow F\n, of \nf: X \\rightarrow Y \\rightarrow Z\nf: X \\rightarrow Y \\rightarrow Z\n.\n\n\nA trivial example for this is the \nadd\n method that adds two \nint\n values. \n\n1\n2\n3\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n  \nreturn\n \nx\n \n+\n \ny\n;\n\n\n}\n\n\n\n\n\n\nThis can be written as\n\n1\nFunction\n<\nInteger\n,\n \nFunction\n<\nInteger\n,\n \nInteger\n>>\n \nadd\n \n=\n \nx\n \n->\n \ny\n \n->\n \n(\nx\n \n+\n \ny\n);\n\n\n\n\n\n\nTo calcualte 1 + 1, we call\n\n1\nadd\n.\napply\n(\n1\n).\napply\n(\n1\n);\n\n\n\n\n\n\nLet's break it down a little, \nadd\n is a function that takes in an \nInteger\n object and returns a unary \nFunction\n over \nInteger\n.  So \nadd.apply(1)\n returns the function \ny -> 1 + y\n.  We could assign this to a variable:\n\n1\nFunction\n<\nInteger\n,\nInteger\n>\n \nincr\n \n=\n \nadd\n.\napply\n(\n1\n);\n\n\n\n\n\n\nHere is the place where you need to change how you think: \nadd\n is not a function that takes two arguments and returns a value.  It is a \nhigher-order function\n that takes in a single argument, and return another function.\n\n\nThe technique that translates a general \nn\nn\n-ary function to a sequence of \nn\nn\n unary functions is called \ncurrying\n.  After currying, we have a sequence of \ncurried\n functions.  \n\n\n\n\nCurry\n\n\nCurrying is not related to food, but rather is named after computer scientist Haskell Curry, who popularized the technique.\n\n\n\n\nAgain, you might question why do we need this?  We can simply call \nadd(1, 1)\n, instead of \nadd.apply(1).apply(1)\n?  Well, the verbosity is the fault of Java instead of functional programming techniques.  Other languages like Haskell or Scala have much simpler syntax (e.g., \nadd 1 1\n or \nadd(1)(1)\n).  \n\n\nIf you get past the verbosity, there is another reason why currying is cool.  Consider \nadd(1, 1)\n -- we have to have both arguments available at the same time to compute the function.  With currying, we no longer have to.  We can evaluate the different arguments at a different time (as \nincr\n example above).  This feature is useful in cases where some arguments are not available until later.  We can \npartially apply\n a function first.  This is also useful if one of the arguments does not change often, or is expensive to compute.  We can save the partial results as a function and continue applying later.\n\n\nIn the former case, we can save the context of a function and carry it around, avoiding the need for multiple parameters, leading to clearer code and fewer states to keep.  \n\n\nLet's go back to the \nRandomGenerator\n example from your labs below\n\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n \nrandomExponentialValue\n(\nRandom\n \nrng\n,\n \ndouble\n \nrate\n)\n \n{\n\n  \nreturn\n \n-\nMath\n.\nlog\n(\nrng\n.\nnextDouble\n())\n \n/\n \nrate\n;\n\n\n}\n\n\n\ndouble\n \ngenerateServiceTime\n()\n \n{\n\n  \nreturn\n \nrandomExponentialValue\n(\nthis\n.\nrngService\n,\n \nthis\n.\nserviceRate\n);\n\n\n}\n\n\n\n\n\n\n\nIn the \nRandomGenerator\n class, we need to keep two states, a \nRandom\n object \nrngServer\n, and a double \nserviceRate\n to generate the service time required for a customer.  These states, however, does not change.\n\n\nOr we could just keep a field \nserviceTimeGenerator\n in \nRandomGenerator\n with the type \nSupplier<Double>\n, which is a partially applied version of \nrandomExponentialValue\n.\n\n\n1\n2\n3\nFunction\n<\nRandom\n,\n \nFunction\n<\nDouble\n,\n \nSupplier\n<\nDouble\n>>>\n \nrandomExponentialValue\n \n=\n \n    \nrng\n \n->\n \nrate\n \n->\n \n()\n \n->\n \n-\nMath\n.\nlog\n(\nrng\n.\nnextDouble\n())\n \n/\n \nrate\n;\n\n\nSupplier\n<\n \nDouble\n>\n \nserviceTimeGenerator\n \n=\n \nrandomExponentialValue\n.\napply\n(\nrngService\n).\napply\n(\nrate\n);\n\n\n\n\n\n\n\nWe can then call \nRandomGenerator.serviceTimeGenerator.get()\n to get the next service time.\n\n\nExercise\n\n\n\n\n\n\nWhich of the following are pure functions?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nint\n \nfff\n(\nint\n \ni\n)\n \n{\n\n  \nif\n \n(\ni\n \n<\n \n0\n)\n \n{\n\n    \nthrow\n \nnew\n \nIllegalArgumentException\n();\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \ni\n \n+\n \n1\n;\n\n\n}\n\n\n\nint\n \nggg\n(\nint\n \ni\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n  \nreturn\n \ni\n \n+\n \n1\n;\n\n\n}\n\n\n\nint\n \nhhh\n(\nint\n \ni\n)\n \n{\n\n  \nreturn\n \nnew\n \nRandom\n().\nnextInt\n()\n \n+\n \ni\n;\n\n\n}\n\n\n\nint\n \njjj\n(\nint\n \ni\n)\n \n{\n\n  \nreturn\n \nMath\n.\nabs\n(\ni\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nThe method \nand\n below takes in two \nPredicate\n objects \np1\n and \np2\n and returns a new \nPredicate\n that evaluates to \ntrue\n if and only if both \np1\n and \np2\n evaluate to \ntrue\n.\n\n\n1\n2\n3\nPredicate\n<\nT\n>\n \nand\n(\nPredicate\n<\nT\n>\n \np1\n,\n \nPredicate\n<\nT\n>\n \np2\n)\n \n{\n\n  \n// TODO\n\n\n}\n\n\n\n\n\n\n\nFill in the body of the method \nand\n\n\n\n\n\n\nJava implements lambda expressions as anonymous classes.  Suppose we have the following lambda expression \nFunction<String,Integer>\n:\n\n\n1\nstr -> str.indexOf(' ')\n\n\n\n\n\n\nWrite the equivalent anonymous class for the expression above.\n\n\n\n\n\n\nConsider the lambda expression:\n\n\n1\nx -> y -> z -> f(x,y,z)\n\n\n\n\n\n\nwhere \nx\n, \ny\n, \nz\n are of some type \nT\n and \nf\n returns a value of type \nR\n.\n\n\n(a) What is the type of the lambda expression above?\n\n\n(b) Suppose that the lambda expression above is assigned to a variable \nexp\n.  Given three variables \nx\n, \ny\n, and \nz\n, show how you can evaluate the lambda expression with \nx\n, \ny\n, \nz\n to obtain \nf(x,y,z)\n.\n\n\n\n\n\n\nWrite a class \nLambdaList<T>\n that is \nimmutable\n and supports \ngenerate\n, \nmap\n, \nfilter\n, \nreduce\n, and \nforEach\n, methods.  The skeleton is given below.  The \nmap\n method, similar to what you see in the lecture, is given.  The static method \nof\n can be used to build the class and is given as well.\n\n\nof\n constructs the list from some number of arguments.  We use the Java \nvarargs\n construct here \nT... varargs\n, which is a short cut for creating and passing in an array.\n\n1\n2\nLambdaList\n.\nof\n(\n1\n,\n \n3\n,\n \n4\n);\n\n\nLambdaList\n.\nof\n(\n\"one\"\n,\n \n\"three\"\n,\n \n\"four\"\n);\n\n\n\n\n\n\ngenerate\n is a static method that returns a new list with \ncount\n elements, where each element in the list is generated with a given Supplier \ns\n.  For example\n\n1\nLambdaList\n.\ngenerate\n(\n4\n,\n \nrng\n::\nnextInt\n);\n\n\n\n\n\n\nfilter\n returns a new list, containing only elements in the list that pass the predicate test (i.e., the predicate returns true).\nExample:\n\n1\n2\nLambdaList\n<\nString\n>\n \nlist\n \n=\n \nLambdaList\n.\nof\n(\n\"show\"\n,\n \n\"me\"\n,\n \n\"my\"\n,\n \n\"place\"\n,\n \n\"in\"\n,\n \n\"all\"\n,\n \n\"this\"\n);\n\n\nlist\n.\nfilter\n(\nx\n \n->\n \nx\n.\nlength\n()\n \n==\n \n2\n);\n \n// returns [me, my, in]\n\n\n\n\n\n\nreduce\n takes in a \nBiFunction\n that is called the \naccumulator\n -- it basically goes through the list, and accumulate all the values into one.  The accumulator requires an initial value to start with.  This initial value is the \nidentity\n of the \nBiFunction\n (in mathematical notation, for identity \ni\ni\n, \nf(i, x) = x\nf(i, x) = x\n for any \nx\nx\n).\n\n\nExample:\n\n1\n2\nLambdaList\n<\nInteger\n>\n \nlist\n \n=\n \nLambdaList\n.\nof\n(\n4\n,\n \n3\n,\n \n2\n,\n \n1\n);\n\n\nlist\n.\nreduce\n(\n1\n,\n \n(\nprod\n,\n \nx\n)\n \n->\n \nprod\n \n*\n \nx\n);\n \n// returns 24\n\n\n\n\n\n\nforEach\n consumes each element in the list with a consumer. \nExample:\n\n1\n2\nLambdaList\n<\nInteger\n>\n \nlist\n \n=\n \nLambdaList\n.\nof\n(\n4\n,\n \n3\n,\n \n2\n,\n \n1\n);\n\n\nlist\n.\nforEach\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\nThe skeleton code is given:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nimport\n \njava.util.ArrayList\n;\n\n\nimport\n \njava.util.List\n;\n\n\nimport\n \njava.util.function.BiFunction\n;\n\n\nimport\n \njava.util.function.Consumer\n;\n\n\nimport\n \njava.util.function.Function\n;\n\n\nimport\n \njava.util.function.Predicate\n;\n\n\nimport\n \njava.util.function.Supplier\n;\n\n\n\nclass\n \nLambdaList\n<\nT\n>\n \n{\n\n  \nList\n<\nT\n>\n \nlist\n;\n\n\n  \npublic\n \nstatic\n \n<\nT\n>\n \nLambdaList\n<\nT\n>\n \nof\n(\nT\n...\n \nvarargs\n)\n \n{\n\n    \nList\n<\nT\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<>();\n\n    \nfor\n \n(\nT\n \ne\n \n:\n \nvarargs\n)\n \n{\n\n      \nlist\n.\nadd\n(\ne\n);\n\n    \n}\n\n    \nreturn\n \nnew\n \nLambdaList\n<\nT\n>(\nlist\n);\n\n  \n}\n  \n\n  \nprivate\n \nLambdaList\n(\nList\n<\nT\n>\n \nlist\n)\n \n{\n\n    \nthis\n.\nlist\n \n=\n \nlist\n;\n\n  \n}\n\n\n  \npublic\n \nstatic\n \n<\nT\n>\n \nLambdaList\n<\nT\n>\n \ngenerate\n(\nint\n \ncount\n,\n \nSupplier\n<\nT\n>\n \ns\n)\n \n{\n\n    \n// TODO\n\n    \nreturn\n \nnull\n;\n\n  \n}\n\n\n  \npublic\n \n<\nV\n>\n \nLambdaList\n<\nV\n>\n \nmap\n(\nFunction\n<?\n \nsuper\n \nT\n,\n \n?\n \nextends\n \nV\n>\n \nf\n)\n \n{\n\n    \nList\n<\nV\n>\n \nnewList\n \n=\n \nnew\n \nArrayList\n<\nV\n>();\n\n    \nfor\n \n(\nT\n \ni\n:\n \nlist\n)\n \n{\n\n      \nnewList\n.\nadd\n(\nf\n.\napply\n(\ni\n));\n\n    \n}\n\n    \nreturn\n \nnew\n \nLambdaList\n<\nV\n>(\nnewList\n);\n\n  \n}\n\n\n  \npublic\n \n<\nU\n>\n \nU\n \nreduce\n(\nU\n \nidentity\n,\n \nBiFunction\n<?\n \nsuper\n \nU\n,\n \n?\n \nsuper\n \nT\n,\n \n?\n \nextends\n \nU\n>\n \naccumulator\n)\n \n{\n\n    \n// TODO\n\n    \nreturn\n \nnull\n;\n\n  \n}\n\n\n  \npublic\n \nLambdaList\n<\nT\n>\n \nfilter\n(\nPredicate\n<?\n \nsuper\n \nT\n>\n \npredicate\n)\n \n{\n\n    \n// TODO\n\n    \nreturn\n \nnull\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nforEach\n(\nConsumer\n<?\n \nsuper\n \nT\n>\n \naction\n)\n \n{\n\n    \n// TODO\n\n  \n}\n\n\n  \npublic\n \nString\n \ntoString\n()\n \n{\n\n    \nreturn\n \nlist\n.\ntoString\n();\n\n  \n}\n\n\n}",
            "title": "7. Functions"
        },
        {
            "location": "/lec07/index.html#lecture-7-functions",
            "text": "",
            "title": "Lecture 7: Functions"
        },
        {
            "location": "/lec07/index.html#learning-objectives",
            "text": "After this lecture, students should be familiar with:   the concept of functions as a side-effect free programming constructs and its relation to functions in mathematics.  the  Function  interface in Java 8, including the methods  apply ,  compose , and  andThen  methods.  the interfaces  Predicate ,  Supplier ,  Consumer , and  BiFunction .  the syntax of method reference and lambda expression  how to write functions with multiple arguments using curried functions    Java 8 introduces several new important new features, including lambda expressions and the stream APIs.  We will spend the next few lectures exploring these new features and how it allows us to write more succinct code and hopefully, less buggy code.  The stream APIs also makes it possible for us to parallelize our code for execution on multiple cores/processors with ease.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec07/index.html#abstraction-principles-revisited",
            "text": "Let's revisit the abstraction principles we first visited in Lecture 2.  It says that  \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"  We have seen this principle being applied in several ways.  First, you should be all be familiar with abstracting out code with the same logic but applied to different variables.   Consider the following sample code from  RandomGenerator  class:  1\n2\n3\n4\n5\n6\n7    double   genInterArrivalTime ()   { \n     return   - Math . log ( this . rngArrival . nextDouble ())   /   this . customerArrivalRate ; \n   } \n\n   double   genServiceTime ()   { \n     return   - Math . log ( this . rngService . nextDouble ())   /   this . customerServiceRate ; \n   }    You can see that the two methods above have similar implementation.  They all generate an exponentially distributed random number, with a different rate using a different random number generator.  One could apply the abstraction principle and write the code as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 double   randomExponentialValue ( Random   rng ,   double   rate )   { \n   return   - Math . log ( rng . nextDouble ())   /   rate ;  }  double   generateServiceTime ()   { \n   return   randomExponentialValue ( this . rngService ,   this . serviceRate );  }  double   generateInterArrivalTime ()   { \n   return   randomExponentialValue ( this . rngArrival ,   this . arrivalRate );  }    Now, when we need a new exponentially distributed random number, say for rest period (see Lab 5), you can just write a method that calls  randomExponentialValue()  method with the appropriate  Random  object and rate, without worrying about the formula to generate an exponential random variable.  1\n2\n3 double genRestPeriod() {\n  return randomExponentialValue(rngRestPeriod, this.serverRestingRate);\n}   Here, the varying parts that we abstracted out is the variables.    Second, consider the  CircleQueue  and  PointQueue  examples from Lecture 4.  The two classes implement similar methods with similar logic.  The only difference is the type.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   CircleQueue   { \n   private   Circle []   circles ; \n    : \n   public   CircleQueue ( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( Circle   c )   {...} \n   public   Circle   dequeue ()   {...}  }  class   PointQueue   { \n   private   Point []   points ; \n    : \n   public   PointQueue ( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( Point   p )   {...} \n   public   Point   dequeue ()   {...}  }    We then replace the two classes (and any future class that we might write to implement such queues) with a generic  Queue<T> .  1\n2\n3\n4\n5\n6\n7\n8\n9 class   Queue < T >   { \n   private   T []   objects ; \n    : \n   public   Queue < T >( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( T   o )   {...} \n   public   T   dequeue ()   {...}  }    Here, the varying parts that we abstracted out is the type of the elements.    Third, consider how we tell  ArrayList.sort()  to sort the items in the array in  Lecture 5 .  By passing in  NameComparator , we can tell  ArrayList  to sort in alphabetical order, either in ascending order or descending order, or by the length of the strings, or any other ways we like.   An alternative would be to have our own  StringList  class and implements methods  sortAlphabeticallyAscending() ,  sortAlphabeticallyDescending() ,  sortByLengthAscending() ,  sortByLengthDescending() , etc.  But all of these methods would be implementing the same sorting algorithms, the only part that is different is the comparison method to determine the order of the elements.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 import   java.util.* ;  class   NameComparator   implements   Comparator < String >   { \n   public   int   compare ( String   s1 ,   String   s2 )   { \n     // return (s1.compareTo(s2)); \n     // return (s2.compareTo(s1)); \n     return   ( s2 . length ()   -   s1 . length ()); \n   }  }  class   SortedList   { \n   public   static   void   main ( String []   args )   { \n     List < String >   names   =   new   ArrayList < String >(); \n\n     names . add ( 0 ,   \"Joffrey\" ); \n     names . add ( 1 ,   \"Cersei\" ); \n     names . add ( 2 ,   \"Meryn\" ); \n     names . add ( 3 ,   \"Walder\" ); \n       : \n       : \n\n     names . sort ( new   NameComparator ()); \n   }  }    Here, the varying parts that we abstracted out is a snippet of the code, or functionality, of the methods.  This idea is much more powerful than just abstracting out how we compare and sort.  We will see how it can lead to a significantly different way of writing code.",
            "title": "Abstraction Principles Revisited"
        },
        {
            "location": "/lec07/index.html#functions",
            "text": "While we have been using the terms functions and methods (and occasionally, procedure) interchangeably, we will now use the term function to refer to methods with specific properties.    A function, in mathematics, refers to a mapping from a set of inputs ( domain )  X X  to a set of output values ( codomain )  Y Y .  We write  f: X \\rightarrow Y f: X \\rightarrow Y .  Every input in the domain must map to exactly one output but multiple inputs can map to the same output.  Not all values in the codomain need to be mapped.  The set of elements in the codomain that is mapped is called the  image .    Functions in programming languages is the same as functions in mathematics.  Given an input, the function computes and returns an output.  A  pure  function does nothing else -- it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments.  We say that a pure function does not cause any  side effect .    Here are two examples of pure functions:  1\n2\n3\n4\n5\n6\n7 int   square ( int   i )   { \n   return   i   *   i ;  }  int   add ( int   i ,   int   j )   { \n   return   i   +   j ;  }    and some examples of non-pure functions:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 int   div ( int   i ,   int   j )   { \n   return   i   /   j ;    // may throw an exception  }  int   incrCount ( int   i )   { \n   return   this . count   +   i ;   // assume that count is not final. \n                          // this may give diff results for the same i.  }  void   incrCount ( int   i )   { \n   this . count   +=   i ;   // does not return a value \n                    // and has side effects on count  }  int   addToList ( ArrayList   queue ,   int   i )   { \n   queue . add ( i );    // has side effects on queue  }    A pure function must also be deterministic.  Given the same input, the function must produce the same output,  every single time .  In OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance.  Such methods are not pure functions.  How do we write classes with methods that do not have side effects (do not update the fields in the class)?  We can do so by making our class  immutable .  Recall that classes such as  String  are immutable.  If we want to modify a  String  object, we have to create a new one containing the modified string.  Such operations on the  String  object has no side-effect (the original string is still in tact).  In computer science, we refer to the style of programming where we build a program from pure functions as  functional programming  (FP).  Many modern programming languages, such as Java, now supports this style of programming.  As Java is inherently still an OO language, we cannot build a program from only pure functions.  As such, I will refer to this style as  functional-style programming  within an OO language.  While the notion of pure functions might seems restrictive, recall how many times your program has a bug that is related to incorrect side effects or unintended side effects?  Or, how much effort is needed to trace through the code in different classes to see what is going on in one line of code.  Take the following line, for instance,  1 server . serve ( customer );    What is updated in the server?  How about the customer?  Is the variable  numOfServedCustomer  updated?  Is a new  DoneEvent  being created and scheduled?  If we design and write our program with pure functions as much as possible, we could significantly reduce the number of bugs.  Michael Feathers tweeted that \"(OO makes code understandable by encapsulating moving parts.  FP makes code understandable by minimizing moving parts.)[ https://twitter.com/mfeathers/status/29581296216?lang=en ]\"  The moving parts here refers to changing states.  He succintly highlights one of the major differences between OOP and FP.  In mathematics, we say that a mapping is a  partial function  if not all elements in the domain are mapped.   A common programming error is to treat a partial function like a function -- for instance, the  div  method above is written as if it is defined for all int values, but it is not defined when  j  is 0.  Another common error is that a function may produce a value that is not in the codomain, e.g.,  null .    Mathematically, a function takes in only one value and return one value (e.g.,  square  above).  In programming, we often need to write functions that take in more than one arguments (e.g.,  add  above).  We will see how to reconcile this later.",
            "title": "Functions"
        },
        {
            "location": "/lec07/index.html#the-function-interface-in-java-8",
            "text": "Let's explore functions in Java 8 by looking at the  Function  interface, it is a generic interface with two type parameters,  Function<T, R> ,  T  is the type of the input,  R  is the type of the Result.  It has one abstract method  R apply(T t)  that applies the function to a given argument.  Let's write a class that implements  Function .  1\n2\n3\n4\n5 class   Square   implements   Function < Integer ,   Integer >   { \n   public   Integer   apply ( Integer   x )   { \n     return   x * x ; \n   }  }    To use it, we can: 1 int   x   =   new   Square (). apply ( 4 );    So far, everything is as you have seen before, and is significantly more complex than just writing:  1 int   x   =   square ( 4 );    So, what is the use of this?  Consider now if we have a  List<Integer>  of integers, and we want to return another list where the elements are the square of the first list.  We can write a method: 1\n2\n3\n4\n5\n6\n7 List < Integer >   squareList ( List < Integer >   list )   { \n   List < Integer >   newList   =   new   ArrayList < Integer >(); \n   for   ( Integer   i :   list )   { \n     newList . add ( square ( i )); \n   } \n   return   newList ;  }   \nCreating a new list out of an existing list is actually a common pattern.  We might want to, say, create a list with the absolute values: 1\n2\n3\n4\n5\n6\n7 List < Integer >   negativeList ( List < Integer >   list )   { \n   List < Integer >   newList   =   new   ArrayList < Integer >(); \n   for   ( Integer   i :   list )   { \n     newList . add ( Math . abs ( i )); \n   } \n   return   newList ;  }    This is actually a common pattern.  Applying the abstraction principle, we can generalize the method to: 1\n2\n3\n4\n5\n6\n7 List < Integer >   applyList ( List < Integer >   list ,   Function < Integer , Integer >   f )   { \n   List < Integer >   newList   =   new   ArrayList < Integer >(); \n   for   ( Integer   i :   list )   { \n     newList . add ( f . apply ( i )); \n   } \n   return   newList ;  }    and call: 1 applyList ( list ,   new   Square ());    to return a list of squares.  If we do not want to create a new class just for this, we can, as before, use an anonymous class: 1\n2\n3\n4\n5 applyList ( list ,   new   Function < Integer , Integer >()   {  \n   public   Integer   apply ( Integer   x )   { \n     return   x   *   x ; \n   }  });     Map  The  applyList  method above is most commonly referred to as  map .",
            "title": "The Function interface in Java 8"
        },
        {
            "location": "/lec07/index.html#lambda-expression",
            "text": "The code is still pretty ugly, and there is much boiler plate code.  The key line is actually Line 3 above,  return x * x .  Fortunately, Java 8 provides a clean way to write this:  1\n2\n3 applyList ( list ,   ( Integer   x )   ->   {   return   x   *   x ;   });  applyList ( list ,   x   ->   {   return   x   *   x ;   });  applyList ( list ,   x   ->   x   *   x );    The expressions above, including  x -> x * x , are  lambda expressions .  You can recognize one by the use of  -> .   The left hand side lists the arguments (use  ()  if there is no argument), while the right hand side is the computation.  We do not need the type in cases where Java can infer the type, nor need the return statements and the curly brackets.   lambda  Alonzo Church invented lambda calculus ( \\lambda \\lambda -calculus) in 1936, before electronic computers, as a way to express computation.  In  \\lambda \\lambda -calculus, all functions are anonymous.  The term lambda expression originated from there.   We can use lambda expressions just like any other values in Java.  We have seen above that we can pass a lambda expression to a method.  We can also assign a lambda expression to a variable: 1\n2 Function < Integer , Integer >   square   =   x   ->   x   *   x ;  square . apply ( 4 );",
            "title": "Lambda Expression"
        },
        {
            "location": "/lec07/index.html#method-reference",
            "text": "We can use a lambda expression to implement  applyList  with  abs()  method in  Math . 1 applyList ( list ,   x   ->   Math . abs ( x ));    If we look carefully at  abs() , however, it takes in an  int , and returns an  int .  So, it already fits the  Function<Integer,Integer>  interface (with autoboxing and unboxing).  As such, we can refer to the method with a method reference:  Math::abs .  The code above can be simplified to: 1 applyList ( list ,   Math :: abs );    Again, we can assign method reference and pass them around like any other objects. 1\n2 Function < Integer , Integer >   f   =   Math :: abs ;  f . apply (- 4 );",
            "title": "Method Reference"
        },
        {
            "location": "/lec07/index.html#composing-functions",
            "text": "The  Function  interface has two default methods: 1\n2 default   < V >   Function < T , V >   andThen ( Function <?   super   R ,?   extends   V >   after );  default   < V >   Function < V , R >   compose ( Function <?   super   V ,?   extends   T >   before );    for composing two functions.  The term  compose  here is used in the mathematical sense (i.e., the  \\cdot \\cdot  operator in  f \\cdot g f \\cdot g ).  These two methods,  andThen  and  compose , return another function, and they are generic methods with type parameter  <V> .  Suppose we want to write a function that returns the square root of the absolute value of an int, we can write: 1\n2\n3 double   SquareRootAbs ( int   x )   { \n   return   Math . sqrt ( Math . abs ( x ));  }    or, we can write either 1\n2\n3 Function < Integer , Integer >   abs   =   Math :: abs ;  Function < Integer , Double >   sqrt   =   Math :: sqrt ;  applyList ( list ,   abs . andThen ( sqrt ))    or  1\n2 sqrt . compose ( abs )  applyList ( list ,   sqrt . compose ( abs ))    But isn't writing the plain old method  SquareRootAbs()  clearer?  Why bother with  Function ?  The difference is that,  SquareRootAbs()  has to be written before we compile our code, and is fixed once we compile.  Using the  Function  interface, we can compose functions at  run time , dynamically as needed!    In other languages  Lambda expression and  Function s are introduced in Java only recently in Java 8, and still relies on classes and interfaces internally to implement them.  As such, despite the elegance and beauty of pure functions, the syntax for it in Java is neither elegant nor pretty.  Take Haskell, a pure functional programming language, for example.  To compose two functions, we can use the  .  operator:  sqrt . abs",
            "title": "Composing Functions"
        },
        {
            "location": "/lec07/index.html#generics-revisited-pecs",
            "text": "We will see many functional generic interfaces with bounded wildcards, so it is worth to spend a little more time to understand what is going on here. Take  andThen  for example:  1 default   < V >   Function < T , V >   andThen ( Function <?   super   R ,?   extends   V >   after );    which is a method in the interface  Function<T,R> .  The method declaration would be clearer if it is written as 1 default   < V >   Function < T , V >   andThen ( Function < R ,   V >   after );    Here, composing a function  T :\\rightarrow R T :\\rightarrow R  followed by  R :\\rightarrow V R :\\rightarrow V  gives us a function  T \\rightarrow V T \\rightarrow V .  The issue with this  andThen  declaration, is that it is not very general.  The argument  after  must be exactly a function with argument type  R R  and return type  V V .    We can make the method more general, but allowing it to take a function with  R  or any superclass of  R  as input -- surely if the function can take in a superclass of  R , it can take in  R .   Thus, we can relax input type, or what the function  consumes , from  R  to  ? super R .  Similarly, if we are expecting the function  after  to return a more general type  V , it is fine if it returns  V  or a subclass of  V .  Thus, we can relax the return type, or what the function  produces , from  V  to  ? extends V .  Both are widening type conversions that are safe.    This introduces us to a principle of using generics, with a mnemonic \"producer  extends ; consumer  super \", or PECS, for short.",
            "title": "Generics Revisited: PECS"
        },
        {
            "location": "/lec07/index.html#other-functions",
            "text": "Java 8 package  java.util.function  provides other useful interfaces, including:   Predicate<T>  with a  boolean test(T t)  method   Supplier<T>  with a  T get()  method  Consumer<T>  with a  void accept(T t)  method  BiFunction<T,U,R>  with a  R apply(T t, U u)  method   Other variations that involve primitive types are also provided.  Here are some examples of how these types are used: 1\n2\n3\n4\n5\n6\n7\n8 Predicate < Integer >   isEven   =   x   ->   ( x   %   2 )   ==   0 ;   Random   rng   =   new   Random ( 1 );  Supplier < Integer >   randomInteger   =   ()   ->   rng . nextInt ();   Consumer < Boolean >   printer   =   System . out :: println ;   printer . accept ( isEven . test ( randomInteger . get ()));     Impure Functions  Since we use a random number generator,  randomInteger  is not a pure function -- invoking it changes the internal state of the random number generator, causing it to give us a different number the next time it is invoked.  So is the function  printer , which causes a side effect of having something printed on the standard output.  While there are ways to generate random numbers and perform I/O in functional way, I prefer to keep things simple in CS2030 and use random generator and I/O in the traditional way when we explore functional-style programming.  We should still isolate these non-pure functions with clear variable names so that the intention of the program is clear.",
            "title": "Other Functions"
        },
        {
            "location": "/lec07/index.html#curried-functions",
            "text": "Functions have an  arity .  The  Function  interface is for unary functions that take in a single argument; the  BiFunction  inteface for binary functions, with two arguments.  But we can have functions that take more than two arguments.  We can, however, build functions that take in multiple arguments with only unary functions.   Let's look at this mathematically first.  Consider a binary function  f: (X, Y) \\rightarrow Z f: (X, Y) \\rightarrow Z .  We can introduce  F F  as a set of all functions  f': Y \\rightarrow Z f': Y \\rightarrow Z , and rewrite  f f  as  f: X \\rightarrow F f: X \\rightarrow F , of  f: X \\rightarrow Y \\rightarrow Z f: X \\rightarrow Y \\rightarrow Z .  A trivial example for this is the  add  method that adds two  int  values.  1\n2\n3 int   add ( int   x ,   int   y )   { \n   return   x   +   y ;  }    This can be written as 1 Function < Integer ,   Function < Integer ,   Integer >>   add   =   x   ->   y   ->   ( x   +   y );    To calcualte 1 + 1, we call 1 add . apply ( 1 ). apply ( 1 );    Let's break it down a little,  add  is a function that takes in an  Integer  object and returns a unary  Function  over  Integer .  So  add.apply(1)  returns the function  y -> 1 + y .  We could assign this to a variable: 1 Function < Integer , Integer >   incr   =   add . apply ( 1 );    Here is the place where you need to change how you think:  add  is not a function that takes two arguments and returns a value.  It is a  higher-order function  that takes in a single argument, and return another function.  The technique that translates a general  n n -ary function to a sequence of  n n  unary functions is called  currying .  After currying, we have a sequence of  curried  functions.     Curry  Currying is not related to food, but rather is named after computer scientist Haskell Curry, who popularized the technique.   Again, you might question why do we need this?  We can simply call  add(1, 1) , instead of  add.apply(1).apply(1) ?  Well, the verbosity is the fault of Java instead of functional programming techniques.  Other languages like Haskell or Scala have much simpler syntax (e.g.,  add 1 1  or  add(1)(1) ).    If you get past the verbosity, there is another reason why currying is cool.  Consider  add(1, 1)  -- we have to have both arguments available at the same time to compute the function.  With currying, we no longer have to.  We can evaluate the different arguments at a different time (as  incr  example above).  This feature is useful in cases where some arguments are not available until later.  We can  partially apply  a function first.  This is also useful if one of the arguments does not change often, or is expensive to compute.  We can save the partial results as a function and continue applying later.  In the former case, we can save the context of a function and carry it around, avoiding the need for multiple parameters, leading to clearer code and fewer states to keep.    Let's go back to the  RandomGenerator  example from your labs below  1\n2\n3\n4\n5\n6\n7 double   randomExponentialValue ( Random   rng ,   double   rate )   { \n   return   - Math . log ( rng . nextDouble ())   /   rate ;  }  double   generateServiceTime ()   { \n   return   randomExponentialValue ( this . rngService ,   this . serviceRate );  }    In the  RandomGenerator  class, we need to keep two states, a  Random  object  rngServer , and a double  serviceRate  to generate the service time required for a customer.  These states, however, does not change.  Or we could just keep a field  serviceTimeGenerator  in  RandomGenerator  with the type  Supplier<Double> , which is a partially applied version of  randomExponentialValue .  1\n2\n3 Function < Random ,   Function < Double ,   Supplier < Double >>>   randomExponentialValue   =  \n     rng   ->   rate   ->   ()   ->   - Math . log ( rng . nextDouble ())   /   rate ;  Supplier <   Double >   serviceTimeGenerator   =   randomExponentialValue . apply ( rngService ). apply ( rate );    We can then call  RandomGenerator.serviceTimeGenerator.get()  to get the next service time.",
            "title": "Curried Functions"
        },
        {
            "location": "/lec07/index.html#exercise",
            "text": "Which of the following are pure functions?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 int   fff ( int   i )   { \n   if   ( i   <   0 )   { \n     throw   new   IllegalArgumentException (); \n   }   else   { \n     return   i   +   1 ;  }  int   ggg ( int   i )   { \n   System . out . println ( i ); \n   return   i   +   1 ;  }  int   hhh ( int   i )   { \n   return   new   Random (). nextInt ()   +   i ;  }  int   jjj ( int   i )   { \n   return   Math . abs ( i );  }      The method  and  below takes in two  Predicate  objects  p1  and  p2  and returns a new  Predicate  that evaluates to  true  if and only if both  p1  and  p2  evaluate to  true .  1\n2\n3 Predicate < T >   and ( Predicate < T >   p1 ,   Predicate < T >   p2 )   { \n   // TODO  }    Fill in the body of the method  and    Java implements lambda expressions as anonymous classes.  Suppose we have the following lambda expression  Function<String,Integer> :  1 str -> str.indexOf(' ')   Write the equivalent anonymous class for the expression above.    Consider the lambda expression:  1 x -> y -> z -> f(x,y,z)   where  x ,  y ,  z  are of some type  T  and  f  returns a value of type  R .  (a) What is the type of the lambda expression above?  (b) Suppose that the lambda expression above is assigned to a variable  exp .  Given three variables  x ,  y , and  z , show how you can evaluate the lambda expression with  x ,  y ,  z  to obtain  f(x,y,z) .    Write a class  LambdaList<T>  that is  immutable  and supports  generate ,  map ,  filter ,  reduce , and  forEach , methods.  The skeleton is given below.  The  map  method, similar to what you see in the lecture, is given.  The static method  of  can be used to build the class and is given as well.  of  constructs the list from some number of arguments.  We use the Java  varargs  construct here  T... varargs , which is a short cut for creating and passing in an array. 1\n2 LambdaList . of ( 1 ,   3 ,   4 );  LambdaList . of ( \"one\" ,   \"three\" ,   \"four\" );    generate  is a static method that returns a new list with  count  elements, where each element in the list is generated with a given Supplier  s .  For example 1 LambdaList . generate ( 4 ,   rng :: nextInt );    filter  returns a new list, containing only elements in the list that pass the predicate test (i.e., the predicate returns true).\nExample: 1\n2 LambdaList < String >   list   =   LambdaList . of ( \"show\" ,   \"me\" ,   \"my\" ,   \"place\" ,   \"in\" ,   \"all\" ,   \"this\" );  list . filter ( x   ->   x . length ()   ==   2 );   // returns [me, my, in]    reduce  takes in a  BiFunction  that is called the  accumulator  -- it basically goes through the list, and accumulate all the values into one.  The accumulator requires an initial value to start with.  This initial value is the  identity  of the  BiFunction  (in mathematical notation, for identity  i i ,  f(i, x) = x f(i, x) = x  for any  x x ).  Example: 1\n2 LambdaList < Integer >   list   =   LambdaList . of ( 4 ,   3 ,   2 ,   1 );  list . reduce ( 1 ,   ( prod ,   x )   ->   prod   *   x );   // returns 24    forEach  consumes each element in the list with a consumer. \nExample: 1\n2 LambdaList < Integer >   list   =   LambdaList . of ( 4 ,   3 ,   2 ,   1 );  list . forEach ( System . out :: println );    The skeleton code is given:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54 import   java.util.ArrayList ;  import   java.util.List ;  import   java.util.function.BiFunction ;  import   java.util.function.Consumer ;  import   java.util.function.Function ;  import   java.util.function.Predicate ;  import   java.util.function.Supplier ;  class   LambdaList < T >   { \n   List < T >   list ; \n\n   public   static   < T >   LambdaList < T >   of ( T ...   varargs )   { \n     List < T >   list   =   new   ArrayList <>(); \n     for   ( T   e   :   varargs )   { \n       list . add ( e ); \n     } \n     return   new   LambdaList < T >( list ); \n   }   \n\n   private   LambdaList ( List < T >   list )   { \n     this . list   =   list ; \n   } \n\n   public   static   < T >   LambdaList < T >   generate ( int   count ,   Supplier < T >   s )   { \n     // TODO \n     return   null ; \n   } \n\n   public   < V >   LambdaList < V >   map ( Function <?   super   T ,   ?   extends   V >   f )   { \n     List < V >   newList   =   new   ArrayList < V >(); \n     for   ( T   i :   list )   { \n       newList . add ( f . apply ( i )); \n     } \n     return   new   LambdaList < V >( newList ); \n   } \n\n   public   < U >   U   reduce ( U   identity ,   BiFunction <?   super   U ,   ?   super   T ,   ?   extends   U >   accumulator )   { \n     // TODO \n     return   null ; \n   } \n\n   public   LambdaList < T >   filter ( Predicate <?   super   T >   predicate )   { \n     // TODO \n     return   null ; \n   } \n\n   public   void   forEach ( Consumer <?   super   T >   action )   { \n     // TODO \n   } \n\n   public   String   toString ()   { \n     return   list . toString (); \n   }  }",
            "title": "Exercise"
        },
        {
            "location": "/lec08/index.html",
            "text": "Lecture 8: Lambdas and Streams\n\n\nLearning Objectives\n\n\nAfter this lecture, students should be familiar with:\n\n\n\n\nthe concept of closure and its relation to lambda expressions\n\n\nthe concept of eager evaluation vs. lazy evaluation\n\n\nJava \nOptional\n class and its operations\n\n\nthe concept of function as delayed data and its application in defining an infinite list\n\n\nJava \nStream\n class and its operations\n\n\nusing the stream operations to write declarative-style code, avoiding loops and branches\n\n\n\n\nWe continue where we left off in Lecture 7.\n\n\nLambda as Closure\n\n\nJust like a local class and an anonymous class, a lambda expression can capture the variables of the enclosing scope.  Recall that, a lambda expression is just a shorthand to an anonymous class after all.  \n\n\nFor instance, if you do not wish to generate the service time of a customer at the time of arrival, you can pass in a \nSupplier\n to \nCustomer\n instead:\n\n1\nCustomer c = new Customer(() -> rng.GenServiceTime());\n\n\n\n\n\nHere, \nrng\n is a variable captured from the enclosing scope.\n\n\nJust like in local and anonymous classes, a captured variable must be either explicitly declared as \nfinal\n or is effectively final.\n\n\nA lambda expression, therefore, stores more than just the function to invoke -- it also stores the data from the environment where it is defined.  We call such construct that stores a function together with the enclosing environment a \nclosure\n. \n\n\nFunction as Cross-Barrier State Manipulator\n\n\nWe have seen that functional-style programming allow us to do a few things that we couldn't before with functions: (i) we can assign function to a variable, pass functions around, return it from another function; (ii) we can compose and create functions dynamically during runtime; (iii) we can partially evaluate a function.\n\n\nLet's take a look at two ways functional-style programming helps us write better programs.\n\n\nWe have seen the \napplyList\n method last week, where we pass a \nFunction<T,R>\n object to manipulate the items in the list.  This method, commonly known as \nmap\n, saves us from writing loops and leads to shorter and less buggy code.  If we view the internal representation of the list of items as behind the abstraction barrier, then we are manipulating data behind the abstraction barrier without knowing the internals of the object -- something we could only do through the interfaces provided by the implementer earlier, before the introduction of functions.\n\n\nOptional\n\n\nAnother way passing in functions to manipulate internal data is helpful is the \nOptional<T>\n class.  \nOptional<T>\n is a wrapper around a reference to either a \nT\n object or a \nnull\n.  Recall that we said bugs can occur if we write functions that return a value not in its codomain, and we gave \nnull\n as an example.  Often, we write functions that return \nnull\n to indicate a special situation (e.g., \nserver = shop.findIdleServer()\n cannot find an idle server) but use the returned reference without checking for \nnull\n (e.g., \nserver.serve(customer)\n) leading to \nNullPointerException\n being raised, because \nnull\n is not a Server object.\n\n\nWrapping the returned reference with an \nOptional\n changes the codomain of the function written, as \nnull\n is now explicitly in the codomain.\n\n\n1\nOptional\n<\nServer\n>\n \nserver\n \n=\n \nshop\n.\nfindIdleServer\n();\n\n\n\n\n\n\n\nWe now have a reference to an \nOptional\n object, which wraps around either a server or \nnull\n.  We cannot call \nserver.serve(customer)\n since the actual reference to the server is behind the abstraction barrier.  The \nOptional\n class provides a method \nifPresent\n that takes in a \nConsumer\n.  So you can call:\n\n\n1\nserver\n.\nifPresent\n(\ns\n \n->\n \ns\n.\nserve\n(\ncustomer\n))\n\n\n\n\n\n\n\nIf server wraps around \nnull\n, then \nifPresent\n do nothing.  Using \nOptional\n means that we no longer have to write branching statements:\n\n1\n2\n3\n4\n   \nserver\n \n=\n \nshop\n.\nfindIdleServer\n();\n\n   \nif\n \n(\nserver\n \n!=\n \nnull\n)\n \n{\n \n     \nserver\n.\nserve\n(\ncustomer\n);\n\n   \n}\n\n\n\n\n\n\nIt can makes code with multiple-level of branching clearer.  Without \nOptional\n,\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n   \nserver\n \n=\n \nshop\n.\nfindIdleServer\n();\n\n   \nif\n \n(\nserver\n \n==\n \nnull\n)\n \n{\n \n     \nserver\n \n=\n \nshop\n.\nfindShortestQueue\n();\n\n     \nif\n \n(\nserver\n \n==\n \nnull\n)\n \n{\n\n        \ncustomer\n.\nleave\n();\n\n     \n}\n \nelse\n \n{\n\n        \nserver\n.\nserve\n(\ncustomer\n);\n\n     \n}\n\n   \n}\n \nelse\n \n{\n\n     \nserver\n.\nserve\n(\ncustomer\n);\n\n   \n}\n\n\n\n\n\n\n\nUsing \nOptional\n, we write\n\n\n1\n2\n3\n4\n5\nshop\n.\nfindIdleServer\n()\n\n    \n.\nor\n(\nshop\n::\nfindShortestQueue\n)\n\n    \n.\nifPresentOrElse\n(\n\n        \ns\n \n->\n \ns\n.\nserve\n(\ncustomer\n),\n\n        \ncustomer\n::\nleave\n);\n\n\n\n\n\n\n\n\n\nJava 8 vs. 9\n\n\nor\n and \nifPresentOrElse\n are available in Java 9 only.\n\n\n\n\nThe branching logic still exists, but is internalized, just like we have internalized loops with \napplyList\n method.  Furthermore, we do not explicitly compares with \nnull\n anymore and this code will never raise a \nNullPointerException\n.\n\n\n\n\nUpdated Notes\n\n\nThis whole section is more or less rewritten since published.  If you print your notes, please make sure that you have the latest version.\n\n\n\n\nInitializing an \nOptional\n\n\nTo wrap up the discussion, let's see how we can create an \nOptional\n object.  If you want to wrap a non-\nnull\n value in an \nOptional\n, call \nOptional.of(value)\n.  Otherwise, if you want to wrap it in a \nnull\n, call \nOptional.empty()\n.  \n\n\nAlternatively, if you do not want to check if the value is \nnull\n or not, call \nOptional.ofNullable(value)\n which will return one of the above appropriately for you.\n\n\n\n\nOptional\n In other languages\n\n\nScala has \nOption\n; Haskell has \nMaybe\n. If you use Python, check out the \nPyMonad\n library that supplies a \nMaybe\n class.\n\n\n\n\nFunction as Delayed Data\n\n\nConsider a function that produces a new value or values.  We can consider the function as a promise to provide us the given data sometime later, when needed.  For instance:\n\n1\n() -> rng.genServiceTime()\n\n\n\n\n\nis not the value of a service time, but rather, a supplier of the service time.  We invoke this supplier only when we need the service time.\n\n\nConsider the case where the function to generate data is an expensive one.  We can delay the execution of the expensive function until it is absolutely needed.  This is called \nlazy evaluation\n.  \n\n\nAn Infinite List\n\n\nLazy evaluation allows us to build data structures that we could not before.  For instance, we can create and manipulate a list that is infinitely long.\n\n\nHow can we represent and manipulate an infinitely long list?  If we store the values of each element in the list, then we will run out of memory pretty soon.  If we try to manipulate every element in the list, then we will enter an infinite loop.  \n\n\nThe trick to building an infinite list, is to treat the elements in the list as \ndelayed data\n, and store \na function that generates the elements\n, instead of the elements themselves.\n\n\nWe can think of an infinite list as consisting of two functions, the first is a function that generates the first element, and the second is a function that generates the rest of the list.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nclass\n \nInfiniteList\n<\nT\n>\n \n{\n\n  \nprivate\n \nSupplier\n<\nT\n>\n \nheadSupplier\n;\n\n  \nprivate\n \nSupplier\n<\nInfiniteList\n<\nT\n>>\n \ntailSupplier\n;\n\n\n  \npublic\n \nInfiniteList\n(\nSupplier\n<\nT\n>\n \nheadSupplier\n,\n \nSupplier\n<\nInfiniteList\n<\nT\n>>\n \ntailSupplier\n)\n \n{\n\n    \nthis\n.\nheadSupplier\n \n=\n \nheadSupplier\n;\n\n    \nthis\n.\ntailSupplier\n \n=\n \ntailSupplier\n;\n\n  \n}\n\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nWe can then construct an infinite list in different ways by passing in different suppliers.\n\n\nSuppose we want every element in the list to be generated using the same supplier.  We can write a method that does as follows:\n\n\n1\n2\n3\n4\n  \npublic\n \nstatic\n \n<\nT\n>\n \nInfiniteList\n<\nT\n>\n \ngenerate\n(\nSupplier\n<\nT\n>\n \nsupply\n)\n \n{\n\n    \nreturn\n \nnew\n \nInfiniteList\n<\nT\n>(\nsupply\n,\n\n        \n()\n \n->\n \nInfiniteList\n.\ngenerate\n(\nsupply\n));\n\n  \n}\n\n\n\n\n\n\n\nOr we can construct an infinite list consisting of a sequence of elements, each computed from the previous element using a \nnext\n function:\n\n\n1\n2\n3\n4\n  \npublic\n \nstatic\n \n<\nT\n>\n \nInfiniteList\n<\nT\n>\n \niterate\n(\nT\n \ninit\n,\n \nFunction\n<\nT\n,\n \nT\n>\n \nnext\n)\n \n{\n\n    \nreturn\n \nnew\n \nInfiniteList\n<\nT\n>(()\n \n->\n \ninit\n,\n\n      \n()\n \n->\n \nInfiniteList\n.\niterate\n(\nnext\n.\napply\n(\ninit\n),\n \nnext\n));\n\n  \n}\n\n\n\n\n\n\n\nHere are some examples of how to use the two methods above:\n\n\n1\n2\nInfiniteList\n<\nInteger\n>\n \nones\n \n=\n \nInfiniteList\n.\ngenerate\n(()\n \n->\n \n1\n);\n \n// 1, 1, 1, 1, ....\n\n\nInfiniteList\n<\nInteger\n>\n \neven\n \n=\n \nInfiniteList\n.\niterate\n(\n0\n,\n \nx\n \n->\n \nx\n \n+\n \n2\n);\n \n// 0, 2, 4, 6, ...\n\n\n\n\n\n\n\nA list that is defined this way is lazily evaluated.  We will not call the supplier to generate the elements until we need it -- this is in contrast to the eagerly evaluate \nLambdaList\n from the exercise in Lecture 7.\n\n\nLet's see how we can manipulate this list.  Consider the \nfindFirst\n method, which returns the first element in the list that satisfies the given predicate.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\npublic\n \nT\n \nfindFirst\n(\nPredicate\n<\nT\n>\n \npredicate\n)\n \n{\n\n  \nInfiniteList\n<\nT\n>\n \nlist\n \n=\n \nthis\n;\n\n  \nwhile\n \n(\ntrue\n)\n \n{\n\n    \nT\n \nnext\n \n=\n \nlist\n.\nheadSupplier\n.\nget\n();\n\n    \nif\n \n(\npredicate\n.\ntest\n(\nnext\n))\n \n{\n\n      \nreturn\n \nnext\n;\n\n    \n}\n\n    \nlist\n \n=\n \nlist\n.\ntailSupplier\n.\nget\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nIn the method above, we repeatedly invoke the supplier, until we find an element that matches the predicate.  This way, we never had to generate every element in the list just to find the first element that matches.\n\n\nStream\n\n\nSuch a list, possibly infinite, that is lazily evaluated on demand is also known as a \nstream\n.  Java 8 provides a class \nStream\n and a set of useful and powerful methods on streams, allowing programmers to manipulate data very easily.  Java 9 adds a couple of useful methods, \ntakeWhile\n and \ndropWhile\n, which is also invaluable.  To take full advantage of streams, we will be using Java 9, not Java 8 for the rest of this class.  \n\n\nStream Operations\n\n\nA few things to note before I show you how to use streams.  First, the operations on streams can be classified as either \nintermediate\n or \nterminal\n.  An \nintermediate\n operation returns another stream.  For instance, \nmap\n, \nfilter\n, \npeek\n are examples of intermediate operations.  An intermediate operation does not cause the stream to be evaluated.  A terminal operation, on the other hand, forces the streams to be evaluated.  It does not return a stream.  \nreduce\n, \nfindFirst\n, \nforEach\n are examples of terminal operation.  A typical way of writing code that operates on streams is to chain a series of intermediate operation together, ending with a terminal operation.  \n\n\nSecond, a stream can only be consumed once.  We cannot iterate through a stream multiple times.  We have to create the stream again if we want to do that:\n\n\n1\n2\n3\nStream\n<\nInteger\n>\n \ns\n \n=\n \nStream\n.\nof\n(\n1\n,\n2\n,\n3\n);\n\n\ns\n.\ncount\n();\n\n\ns\n.\ncount\n();\n \n// <- error\n\n\n\n\n\n\n\nIn the example above, we use the \nof\n static method with a variable number of arguments to create a stream.  We can also create a stream by:\n\n\n\n\nconverting an array to stream using \nArrays.stream\n method\n\n\nconverting a collection to stream using \nstream\n method\n\n\nreading from a file using \nFiles.lines\n method\n\n\nusing the \ngenerate\n method (provide a \nSupplier\n) or \niterate\n method (providing the initial value and incremental operation). \n\n\n\n\nYou have seen many of the stream operations before, in Question 5 of Exercise 7, including \nmap\n, \nreduce\n, \nfilter\n, and \nforEach\n.  Even though they are in the context of an eagerly evaluated list, the semantics are the same.  Here are a few more useful ones.\n\n\n\n\nflatMap\n is just like \nmap\n, but it takes in a function that produces another stream (instead of another element), and it \nflattens\n the stream by inserting the elements from the stream produced into the stream.\n\n\n\n\nLet see an example.  The lambda below takes a string and return a stream of \nInteger\n objects:\n\n\n1\nx\n \n->\n \nx\n.\nchars\n().\nboxed\n()\n\n\n\n\n\n\n\nWe can create a stream of strings using the static \nof\n method from \nStream\n:\n\n\n1\nStream\n.\nof\n(\n\"live\"\n,\n \n\"long\"\n,\n \n\"and\"\n,\n \n\"prosper\"\n)\n\n\n\n\n\n\n\nIf we chain the two together, using \nmap\n, however, we will produce a stream of stream of \nInteger\n.\n\n\n1\n2\nSteam\n.\nof\n(\n\"live\"\n,\n \n\"long\"\n,\n \n\"and\"\n,\n \n\"prosper\"\n)\n\n    \n.\nmap\n(\nx\n \n->\n \nx\n.\nchars\n().\nboxed\n())\n\n\n\n\n\n\n\nTo produce a stream of \nInteger\ns, we use \nflatMap()\n:\n\n\n1\n2\nStream\n.\nof\n(\n\"live\"\n,\n \n\"long\"\n,\n \n\"and\"\n,\n \n\"prosper\"\n)\n\n    \n.\nflatMap\n(\nx\n \n->\n \nx\n.\nchars\n().\nboxed\n())\n\n\n\n\n\n\n\n\n\n\n\nsorted\n is an intermediate operation that returns a stream with the elements in the stream sorted.  Without argument, it sorts according to the natural order.  You can also pass in a \nComparator\n to tell \nsorted\n how to sort.\n\n\n\n\n\n\ndistinct\n is another intermediate operation that returns a stream with only distinct elements in the stream. \n\n\n\n\n\n\ndistinct\n and \nsorted\n are stateful operations -- it needs to keep track of states in order to perform the operation.  \nsorted\n, in particular, needs to know every element in the stream before it can output the result.  They are also known as \nbounded\n operations, since they should only be called on a finite stream -- calling them on an infinite stream is a very bad idea.\n\n\nLet's look at an example.  The code below shows how we can print out the unique characters of a given sequence of streams in sorted order\n\n1\n2\n3\n4\n5\n6\nStream\n.\nof\n(\n\"live\"\n,\n \n\"long\"\n,\n \n\"and\"\n,\n \n\"prosper\"\n)\n\n    \n.\nflatMap\n(\nx\n \n->\n \nx\n.\nchars\n().\nboxed\n())\n\n    \n.\ndistinct\n()\n\n    \n.\nsorted\n()\n\n    \n.\nmap\n(\nCharacter\n::\ntoChars\n)\n\n    \n.\nforEach\n(\nSystem\n.\nout\n::\nprint\n);\n\n\n\n\n\n\nThere are several intermediate operations that convert from infinite stream to finite stream.  \n\n\n\n\nlimit\n takes in an \nint\n \nn\nn\n and returns a stream containing the first \nn\nn\n elements of the stream;\n\n\ntakeWhile\n takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false.  The resulting stream might still be infinite if the predicate never becomes false.\n\n\n\n\nHere are more useful terminal operations:\n\n\n\n\nnoneMatch\n returns true if none of the elements pass the given predicate.\n\n\nallMatch\n returns true if every element passes the given predicate.\n\n\nanyMatch\n returns true if at least one element passes the given predicate.\n\n\n\n\nTo illustrate the use of the \nStream\n class and its methods, let's look at an example.\n\n\nExample: Is this a prime?\n\n\nConsider the method below, which checks if a given \nint\n is a prime:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nboolean\n \nisPrime\n(\nint\n \nx\n)\n \n{\n\n  \nfor\n \n(\ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nx\n-\n1\n;\n \ni\n++)\n \n{\n\n    \nif\n \n(\nx\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nThe code coudln't be simpler -- or can it?  With streams, we can write it as:\n\n1\n2\n3\n4\nboolean\n \nisPrime\n(\nint\n \nx\n)\n \n{\n\n  \nreturn\n \nIntStream\n.\nrange\n(\n2\n,\n \nx\n)\n\n      \n.\nnoneMatch\n(\ni\n \n->\n \nx\n \n%\n \ni\n \n==\n \n0\n);\n\n\n}\n\n\n\n\n\n\nIntStream\n is a special \nStream\n for primitive type \nint\n, the \nrange(x,y)\n method generates a stream of \nint\n from \nx\n to \ny-1\n.\n\n\nWhat if we want to print out the first 500 prime numbers, starting from 2?  Normally, we would do the following:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \nfiveHundredPrime\n()\n \n{\n\n  \nint\n \ncount\n \n=\n \n0\n;\n\n  \nint\n \ni\n \n=\n \n2\n;\n\n  \nwhile\n \n(\ncount\n \n<\n \n500\n)\n \n{\n\n    \nif\n \n(\nisPrime\n(\ni\n))\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n      \ncount\n++;\n\n    \n}\n\n    \ni\n++;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter, or put the increment in the wrong place).  If you look at the code, there are a couple of components:\n\n\n\n\nLines 3 and 9 deal with iterating through different numbers for primality testing\n\n\nLine 4 is the test\n\n\nLines 2, 4, and 7, deal with limiting the output to 500 primes\n\n\nLine 5 is the action to perform on the prime\n\n\n\n\nWith streams, we can write it like the following:\n\n1\n2\n3\n4\nIntStream\n.\niterate\n(\n2\n,\n \nx\n \n->\n \nx\n+\n1\n)\n\n    \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n    \n.\nlimit\n(\n500\n)\n\n    \n.\nforEach\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\nNotice how each of the four components matches neatly with one operation on stream!  \n\n\nWith stream, we no longer have to write loops, we have moved the iterations to within each operation in stream.  We no longer need to maintain states and counters, they are done within each operation as needed as well.  This has another powerful implication: our code become more \ndeclarative\n, we only need to concern about what we want at each step, much less about how to do it.\n\n\nYou should take a look at the methods provided by the \nStream\n class, and read through the APIs, a few times, they formed the fundamental building blocks for writing functional-style data processing code in Java.\n\n\nExercise\n\n\n\n\n\n\nWrite your own \nOptional\n class with the following skeleton:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass\n \nOptional\n<\nT\n>\n \n{\n\n  \nT\n \nvalue\n;\n\n\n  \npublic\n \nstatic\n \n<\nT\n>\n \nOptional\n<\nT\n>\n \nof\n(\nT\n \nv\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nstatic\n \n<\nT\n>\n \nOptional\n<\nT\n>\n \nofNullable\n(\nT\n \nv\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nstatic\n \n<\nT\n>\n \nOptional\n<\nT\n>\n \nempty\n(\nT\n \nv\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nifPresent\n(\nConsumer\n<?\n \nsuper\n \nT\n>\n \nconsumer\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nOptional\n<\nT\n>\n \nfilter\n(\nPredicate\n<?\n \nsuper\n \nT\n>\n \npredicate\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \n<\nU\n>\n \nOptional\n<\nU\n>\n \nmap\n(\nFunction\n<?\n \nsuper\n \nT\n,\n \n?\n \nextends\n \nU\n>\n \nmapper\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n<\nU\n>\n \nOptional\n<\nU\n>\n \nflatMap\n(\nFunction\n<?\n \nsuper\n \nT\n,\n \nOptional\n<\nU\n>>\n \nmapper\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n  \npublic\n \nT\n \norElseGet\n(\nSupplier\n<?\n \nextends\n \nT\n>\n \nother\n)\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nSolve each of the following with Java 9 \nStream\n.\n\n\n\n\n\n\nWrite a method \nfactors\n with signature \nLongStream factors(long x)\n that takes in \nlong x\n and return a \nLongStream\n consisting of the factors of \nx\n.  For instance, factors(6) should return the stream 1, 2, 3, 6.\n\n\n\n\n\n\nWrite a method \nprimeFactors\n with signature \nLongStream primeFactors(long x)\n that takes in \nlong x\n and return a \nLongStream\n consisting of the prime factors of \nx\n (a prime factor is a factor that is a prime number, excluding 1).  For instance, prime factors of 6 are 2 and 3.\n\n\n\n\n\n\nWrite a method \nomega\n with signature \nLongStream omega(int n)\n that takes in an \nint n\n and return a \nLongStream\n containing the first \nn\nn\n \nomega numbers\n.  The \ni\ni\n-th omega number is the number of distinct prime factors for the number \ni\ni\n.  The first 10 omega numbers are 0, 1, 1, 1, 1, 2, 1, 1, 1, 2.\n\n\n\n\n\n\n\n\n\n\nWrite a method \nproduct\n that takes in two \nList\n objects \nlist1\n and \nlist2\n, and produce a \nStream\n containing elements combining each element from \nlist1\n with every element from \nlist2\n using a given \nBiFunction\n.  This operation is similar to a Cartesian product.\n\n\nFor instance,\n\n\n1\n2\n3\n4\n5\n6\nArrayList\n<\nInteger\n>\n \nlist1\n \n=\n \nnew\n \nArrayList\n<>();\n\n\nArrayList\n<\nInteger\n>\n \nlist2\n \n=\n \nnew\n \nArrayList\n<>();\n\n\nCollections\n.\naddAll\n(\nlist1\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n);\n\n\nCollections\n.\naddAll\n(\nlist2\n,\n \n10\n,\n \n20\n);\n\n\nproduct\n(\nlist1\n,\n \nlist2\n,\n \n(\nstr1\n,\n \nstr2\n)\n \n->\n \nstr1\n \n+\n \nstr2\n)\n\n    \n.\nforEach\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\ngives the output:\n\n1\n2\n3\n4\n5\n6\n7\n8\n11\n21\n12\n22\n13\n23\n14\n24\n\n\n\n\n\nThe signature for \nproduct\n is\n\n1\n2\n  \npublic\n \nstatic\n \n<\nT\n,\nU\n,\nR\n>\n \nStream\n<\nR\n>\n \nproduct\n(\nList\n<\nT\n>\n \nlist1\n,\n \nList\n<\nU\n>\n \nlist2\n,\n \n      \nBiFunction\n<?\n \nsuper\n \nT\n,\n \n?\n \nsuper\n \nU\n,\n \nR\n>\n \nf\n)\n\n\n\n\n\n\n\n\n\n\nWrite a method that returns the first \nn\nn\n Fibonacci numbers as a \nStream<BigInteger>\n.  For instance, the first 10 Fibonacci numbers are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55.  It would be useful to write a new \nPair<T, U>\n class that keeps two items around in the stream.  We use the \nBigInteger\n class to avoid overflow.",
            "title": "8. Streams"
        },
        {
            "location": "/lec08/index.html#lecture-8-lambdas-and-streams",
            "text": "",
            "title": "Lecture 8: Lambdas and Streams"
        },
        {
            "location": "/lec08/index.html#learning-objectives",
            "text": "After this lecture, students should be familiar with:   the concept of closure and its relation to lambda expressions  the concept of eager evaluation vs. lazy evaluation  Java  Optional  class and its operations  the concept of function as delayed data and its application in defining an infinite list  Java  Stream  class and its operations  using the stream operations to write declarative-style code, avoiding loops and branches   We continue where we left off in Lecture 7.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec08/index.html#lambda-as-closure",
            "text": "Just like a local class and an anonymous class, a lambda expression can capture the variables of the enclosing scope.  Recall that, a lambda expression is just a shorthand to an anonymous class after all.    For instance, if you do not wish to generate the service time of a customer at the time of arrival, you can pass in a  Supplier  to  Customer  instead: 1 Customer c = new Customer(() -> rng.GenServiceTime());   Here,  rng  is a variable captured from the enclosing scope.  Just like in local and anonymous classes, a captured variable must be either explicitly declared as  final  or is effectively final.  A lambda expression, therefore, stores more than just the function to invoke -- it also stores the data from the environment where it is defined.  We call such construct that stores a function together with the enclosing environment a  closure .",
            "title": "Lambda as Closure"
        },
        {
            "location": "/lec08/index.html#function-as-cross-barrier-state-manipulator",
            "text": "We have seen that functional-style programming allow us to do a few things that we couldn't before with functions: (i) we can assign function to a variable, pass functions around, return it from another function; (ii) we can compose and create functions dynamically during runtime; (iii) we can partially evaluate a function.  Let's take a look at two ways functional-style programming helps us write better programs.  We have seen the  applyList  method last week, where we pass a  Function<T,R>  object to manipulate the items in the list.  This method, commonly known as  map , saves us from writing loops and leads to shorter and less buggy code.  If we view the internal representation of the list of items as behind the abstraction barrier, then we are manipulating data behind the abstraction barrier without knowing the internals of the object -- something we could only do through the interfaces provided by the implementer earlier, before the introduction of functions.",
            "title": "Function as Cross-Barrier State Manipulator"
        },
        {
            "location": "/lec08/index.html#optional",
            "text": "Another way passing in functions to manipulate internal data is helpful is the  Optional<T>  class.   Optional<T>  is a wrapper around a reference to either a  T  object or a  null .  Recall that we said bugs can occur if we write functions that return a value not in its codomain, and we gave  null  as an example.  Often, we write functions that return  null  to indicate a special situation (e.g.,  server = shop.findIdleServer()  cannot find an idle server) but use the returned reference without checking for  null  (e.g.,  server.serve(customer) ) leading to  NullPointerException  being raised, because  null  is not a Server object.  Wrapping the returned reference with an  Optional  changes the codomain of the function written, as  null  is now explicitly in the codomain.  1 Optional < Server >   server   =   shop . findIdleServer ();    We now have a reference to an  Optional  object, which wraps around either a server or  null .  We cannot call  server.serve(customer)  since the actual reference to the server is behind the abstraction barrier.  The  Optional  class provides a method  ifPresent  that takes in a  Consumer .  So you can call:  1 server . ifPresent ( s   ->   s . serve ( customer ))    If server wraps around  null , then  ifPresent  do nothing.  Using  Optional  means that we no longer have to write branching statements: 1\n2\n3\n4     server   =   shop . findIdleServer (); \n    if   ( server   !=   null )   {  \n      server . serve ( customer ); \n    }    It can makes code with multiple-level of branching clearer.  Without  Optional ,   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11     server   =   shop . findIdleServer (); \n    if   ( server   ==   null )   {  \n      server   =   shop . findShortestQueue (); \n      if   ( server   ==   null )   { \n         customer . leave (); \n      }   else   { \n         server . serve ( customer ); \n      } \n    }   else   { \n      server . serve ( customer ); \n    }    Using  Optional , we write  1\n2\n3\n4\n5 shop . findIdleServer () \n     . or ( shop :: findShortestQueue ) \n     . ifPresentOrElse ( \n         s   ->   s . serve ( customer ), \n         customer :: leave );     Java 8 vs. 9  or  and  ifPresentOrElse  are available in Java 9 only.   The branching logic still exists, but is internalized, just like we have internalized loops with  applyList  method.  Furthermore, we do not explicitly compares with  null  anymore and this code will never raise a  NullPointerException .   Updated Notes  This whole section is more or less rewritten since published.  If you print your notes, please make sure that you have the latest version.",
            "title": "Optional"
        },
        {
            "location": "/lec08/index.html#initializing-an-optional",
            "text": "To wrap up the discussion, let's see how we can create an  Optional  object.  If you want to wrap a non- null  value in an  Optional , call  Optional.of(value) .  Otherwise, if you want to wrap it in a  null , call  Optional.empty() .    Alternatively, if you do not want to check if the value is  null  or not, call  Optional.ofNullable(value)  which will return one of the above appropriately for you.   Optional  In other languages  Scala has  Option ; Haskell has  Maybe . If you use Python, check out the  PyMonad  library that supplies a  Maybe  class.",
            "title": "Initializing an Optional"
        },
        {
            "location": "/lec08/index.html#function-as-delayed-data",
            "text": "Consider a function that produces a new value or values.  We can consider the function as a promise to provide us the given data sometime later, when needed.  For instance: 1 () -> rng.genServiceTime()   is not the value of a service time, but rather, a supplier of the service time.  We invoke this supplier only when we need the service time.  Consider the case where the function to generate data is an expensive one.  We can delay the execution of the expensive function until it is absolutely needed.  This is called  lazy evaluation .",
            "title": "Function as Delayed Data"
        },
        {
            "location": "/lec08/index.html#an-infinite-list",
            "text": "Lazy evaluation allows us to build data structures that we could not before.  For instance, we can create and manipulate a list that is infinitely long.  How can we represent and manipulate an infinitely long list?  If we store the values of each element in the list, then we will run out of memory pretty soon.  If we try to manipulate every element in the list, then we will enter an infinite loop.    The trick to building an infinite list, is to treat the elements in the list as  delayed data , and store  a function that generates the elements , instead of the elements themselves.  We can think of an infinite list as consisting of two functions, the first is a function that generates the first element, and the second is a function that generates the rest of the list.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 class   InfiniteList < T >   { \n   private   Supplier < T >   headSupplier ; \n   private   Supplier < InfiniteList < T >>   tailSupplier ; \n\n   public   InfiniteList ( Supplier < T >   headSupplier ,   Supplier < InfiniteList < T >>   tailSupplier )   { \n     this . headSupplier   =   headSupplier ; \n     this . tailSupplier   =   tailSupplier ; \n   } \n\n     :  }    We can then construct an infinite list in different ways by passing in different suppliers.  Suppose we want every element in the list to be generated using the same supplier.  We can write a method that does as follows:  1\n2\n3\n4    public   static   < T >   InfiniteList < T >   generate ( Supplier < T >   supply )   { \n     return   new   InfiniteList < T >( supply , \n         ()   ->   InfiniteList . generate ( supply )); \n   }    Or we can construct an infinite list consisting of a sequence of elements, each computed from the previous element using a  next  function:  1\n2\n3\n4    public   static   < T >   InfiniteList < T >   iterate ( T   init ,   Function < T ,   T >   next )   { \n     return   new   InfiniteList < T >(()   ->   init , \n       ()   ->   InfiniteList . iterate ( next . apply ( init ),   next )); \n   }    Here are some examples of how to use the two methods above:  1\n2 InfiniteList < Integer >   ones   =   InfiniteList . generate (()   ->   1 );   // 1, 1, 1, 1, ....  InfiniteList < Integer >   even   =   InfiniteList . iterate ( 0 ,   x   ->   x   +   2 );   // 0, 2, 4, 6, ...    A list that is defined this way is lazily evaluated.  We will not call the supplier to generate the elements until we need it -- this is in contrast to the eagerly evaluate  LambdaList  from the exercise in Lecture 7.  Let's see how we can manipulate this list.  Consider the  findFirst  method, which returns the first element in the list that satisfies the given predicate.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 public   T   findFirst ( Predicate < T >   predicate )   { \n   InfiniteList < T >   list   =   this ; \n   while   ( true )   { \n     T   next   =   list . headSupplier . get (); \n     if   ( predicate . test ( next ))   { \n       return   next ; \n     } \n     list   =   list . tailSupplier . get (); \n   }  }    In the method above, we repeatedly invoke the supplier, until we find an element that matches the predicate.  This way, we never had to generate every element in the list just to find the first element that matches.",
            "title": "An Infinite List"
        },
        {
            "location": "/lec08/index.html#stream",
            "text": "Such a list, possibly infinite, that is lazily evaluated on demand is also known as a  stream .  Java 8 provides a class  Stream  and a set of useful and powerful methods on streams, allowing programmers to manipulate data very easily.  Java 9 adds a couple of useful methods,  takeWhile  and  dropWhile , which is also invaluable.  To take full advantage of streams, we will be using Java 9, not Java 8 for the rest of this class.",
            "title": "Stream"
        },
        {
            "location": "/lec08/index.html#stream-operations",
            "text": "A few things to note before I show you how to use streams.  First, the operations on streams can be classified as either  intermediate  or  terminal .  An  intermediate  operation returns another stream.  For instance,  map ,  filter ,  peek  are examples of intermediate operations.  An intermediate operation does not cause the stream to be evaluated.  A terminal operation, on the other hand, forces the streams to be evaluated.  It does not return a stream.   reduce ,  findFirst ,  forEach  are examples of terminal operation.  A typical way of writing code that operates on streams is to chain a series of intermediate operation together, ending with a terminal operation.    Second, a stream can only be consumed once.  We cannot iterate through a stream multiple times.  We have to create the stream again if we want to do that:  1\n2\n3 Stream < Integer >   s   =   Stream . of ( 1 , 2 , 3 );  s . count ();  s . count ();   // <- error    In the example above, we use the  of  static method with a variable number of arguments to create a stream.  We can also create a stream by:   converting an array to stream using  Arrays.stream  method  converting a collection to stream using  stream  method  reading from a file using  Files.lines  method  using the  generate  method (provide a  Supplier ) or  iterate  method (providing the initial value and incremental operation).    You have seen many of the stream operations before, in Question 5 of Exercise 7, including  map ,  reduce ,  filter , and  forEach .  Even though they are in the context of an eagerly evaluated list, the semantics are the same.  Here are a few more useful ones.   flatMap  is just like  map , but it takes in a function that produces another stream (instead of another element), and it  flattens  the stream by inserting the elements from the stream produced into the stream.   Let see an example.  The lambda below takes a string and return a stream of  Integer  objects:  1 x   ->   x . chars (). boxed ()    We can create a stream of strings using the static  of  method from  Stream :  1 Stream . of ( \"live\" ,   \"long\" ,   \"and\" ,   \"prosper\" )    If we chain the two together, using  map , however, we will produce a stream of stream of  Integer .  1\n2 Steam . of ( \"live\" ,   \"long\" ,   \"and\" ,   \"prosper\" ) \n     . map ( x   ->   x . chars (). boxed ())    To produce a stream of  Integer s, we use  flatMap() :  1\n2 Stream . of ( \"live\" ,   \"long\" ,   \"and\" ,   \"prosper\" ) \n     . flatMap ( x   ->   x . chars (). boxed ())      sorted  is an intermediate operation that returns a stream with the elements in the stream sorted.  Without argument, it sorts according to the natural order.  You can also pass in a  Comparator  to tell  sorted  how to sort.    distinct  is another intermediate operation that returns a stream with only distinct elements in the stream.     distinct  and  sorted  are stateful operations -- it needs to keep track of states in order to perform the operation.   sorted , in particular, needs to know every element in the stream before it can output the result.  They are also known as  bounded  operations, since they should only be called on a finite stream -- calling them on an infinite stream is a very bad idea.  Let's look at an example.  The code below shows how we can print out the unique characters of a given sequence of streams in sorted order 1\n2\n3\n4\n5\n6 Stream . of ( \"live\" ,   \"long\" ,   \"and\" ,   \"prosper\" ) \n     . flatMap ( x   ->   x . chars (). boxed ()) \n     . distinct () \n     . sorted () \n     . map ( Character :: toChars ) \n     . forEach ( System . out :: print );    There are several intermediate operations that convert from infinite stream to finite stream.     limit  takes in an  int   n n  and returns a stream containing the first  n n  elements of the stream;  takeWhile  takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false.  The resulting stream might still be infinite if the predicate never becomes false.   Here are more useful terminal operations:   noneMatch  returns true if none of the elements pass the given predicate.  allMatch  returns true if every element passes the given predicate.  anyMatch  returns true if at least one element passes the given predicate.   To illustrate the use of the  Stream  class and its methods, let's look at an example.",
            "title": "Stream Operations"
        },
        {
            "location": "/lec08/index.html#example-is-this-a-prime",
            "text": "Consider the method below, which checks if a given  int  is a prime:  1\n2\n3\n4\n5\n6\n7\n8 boolean   isPrime ( int   x )   { \n   for   ( i   =   2 ;   i   <=   x - 1 ;   i ++)   { \n     if   ( x   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    The code coudln't be simpler -- or can it?  With streams, we can write it as: 1\n2\n3\n4 boolean   isPrime ( int   x )   { \n   return   IntStream . range ( 2 ,   x ) \n       . noneMatch ( i   ->   x   %   i   ==   0 );  }    IntStream  is a special  Stream  for primitive type  int , the  range(x,y)  method generates a stream of  int  from  x  to  y-1 .  What if we want to print out the first 500 prime numbers, starting from 2?  Normally, we would do the following:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   fiveHundredPrime ()   { \n   int   count   =   0 ; \n   int   i   =   2 ; \n   while   ( count   <   500 )   { \n     if   ( isPrime ( i ))   { \n       System . out . println ( i ); \n       count ++; \n     } \n     i ++; \n   }  }    The code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter, or put the increment in the wrong place).  If you look at the code, there are a couple of components:   Lines 3 and 9 deal with iterating through different numbers for primality testing  Line 4 is the test  Lines 2, 4, and 7, deal with limiting the output to 500 primes  Line 5 is the action to perform on the prime   With streams, we can write it like the following: 1\n2\n3\n4 IntStream . iterate ( 2 ,   x   ->   x + 1 ) \n     . filter ( x   ->   isPrime ( x )) \n     . limit ( 500 ) \n     . forEach ( System . out :: println );    Notice how each of the four components matches neatly with one operation on stream!    With stream, we no longer have to write loops, we have moved the iterations to within each operation in stream.  We no longer need to maintain states and counters, they are done within each operation as needed as well.  This has another powerful implication: our code become more  declarative , we only need to concern about what we want at each step, much less about how to do it.  You should take a look at the methods provided by the  Stream  class, and read through the APIs, a few times, they formed the fundamental building blocks for writing functional-style data processing code in Java.",
            "title": "Example: Is this a prime?"
        },
        {
            "location": "/lec08/index.html#exercise",
            "text": "Write your own  Optional  class with the following skeleton:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35 class   Optional < T >   { \n   T   value ; \n\n   public   static   < T >   Optional < T >   of ( T   v )   { \n     : \n   } \n\n   public   static   < T >   Optional < T >   ofNullable ( T   v )   { \n     : \n   } \n\n   public   static   < T >   Optional < T >   empty ( T   v )   { \n     : \n   } \n\n   public   void   ifPresent ( Consumer <?   super   T >   consumer )   { \n     : \n   } \n\n   public   Optional < T >   filter ( Predicate <?   super   T >   predicate )   { \n     : \n   } \n\n   public   < U >   Optional < U >   map ( Function <?   super   T ,   ?   extends   U >   mapper )   { \n     : \n   } \n\n   public < U >   Optional < U >   flatMap ( Function <?   super   T ,   Optional < U >>   mapper )   { \n     : \n   } \n\n   public   T   orElseGet ( Supplier <?   extends   T >   other )   { \n     : \n   }  }      Solve each of the following with Java 9  Stream .    Write a method  factors  with signature  LongStream factors(long x)  that takes in  long x  and return a  LongStream  consisting of the factors of  x .  For instance, factors(6) should return the stream 1, 2, 3, 6.    Write a method  primeFactors  with signature  LongStream primeFactors(long x)  that takes in  long x  and return a  LongStream  consisting of the prime factors of  x  (a prime factor is a factor that is a prime number, excluding 1).  For instance, prime factors of 6 are 2 and 3.    Write a method  omega  with signature  LongStream omega(int n)  that takes in an  int n  and return a  LongStream  containing the first  n n   omega numbers .  The  i i -th omega number is the number of distinct prime factors for the number  i i .  The first 10 omega numbers are 0, 1, 1, 1, 1, 2, 1, 1, 1, 2.      Write a method  product  that takes in two  List  objects  list1  and  list2 , and produce a  Stream  containing elements combining each element from  list1  with every element from  list2  using a given  BiFunction .  This operation is similar to a Cartesian product.  For instance,  1\n2\n3\n4\n5\n6 ArrayList < Integer >   list1   =   new   ArrayList <>();  ArrayList < Integer >   list2   =   new   ArrayList <>();  Collections . addAll ( list1 ,   1 ,   2 ,   3 ,   4 );  Collections . addAll ( list2 ,   10 ,   20 );  product ( list1 ,   list2 ,   ( str1 ,   str2 )   ->   str1   +   str2 ) \n     . forEach ( System . out :: println );    gives the output: 1\n2\n3\n4\n5\n6\n7\n8 11\n21\n12\n22\n13\n23\n14\n24   The signature for  product  is 1\n2    public   static   < T , U , R >   Stream < R >   product ( List < T >   list1 ,   List < U >   list2 ,  \n       BiFunction <?   super   T ,   ?   super   U ,   R >   f )      Write a method that returns the first  n n  Fibonacci numbers as a  Stream<BigInteger> .  For instance, the first 10 Fibonacci numbers are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55.  It would be useful to write a new  Pair<T, U>  class that keeps two items around in the stream.  We use the  BigInteger  class to avoid overflow.",
            "title": "Exercise"
        },
        {
            "location": "/lec09/index.html",
            "text": "Lecture 9: Functional-Style Programming Patterns\n\n\nLearning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nUnderstand what is a SAM and how to write own's functional interface that can be represented by a lambda expression\n\n\nUnderstand what are functors and monads in the context of Java's \nStream\n, \nOptional\n\n\nUnderstand the laws that a functor and monad must obey and be able to verify them\n\n\nAware of different programming patterns using lambda, including functor, monad, polymorphism, and observer.\n\n\n\n\nFunctional Interface\n\n\nWe have seen how we can write lambda expressions of types \nFunction\n, \nPredicate\n, \nSupplier\n, \nConsumer\n, and \nBiFunction\n.  We, however, are not limited the types defined in \njava.util.function\n.  We can use a lambda expression as a short hand to an anonymous class that implements any interface with \na single abstract method\n.   The reason there has to be only one abstract method is so that the compiler can infer which method body the lambda expression implements.  Such an interface is more commonly known as a \nSAM interface\n.  \n\n\nA SAM interface can contain multiple methods, but only one needs to be abstract, others can contain \ndefault\n implementations.\n\n\nFor instance, Java has the following interface:\n\n1\n2\n3\ninterface\n \nRunnable\n \n{\n\n  \nvoid\n \nrun\n();\n\n\n}\n\n\n\n\n\n\nThere is only one method, and it is abstract (no default implementation).  So it is a valid SAM interface.\n\n\nWe can write:\n\n\n1\nRunnable\n \nr\n \n=\n \n()\n \n->\n \n{\n \nSystem\n.\nout\n.\nprintln\n(\n\"hello world\"\n);\n \n}\n\n\n\n\n\n\n\nWe can annotate a class with \n@FunctionalInterface\n to hint our intention to the compiler and to let the compiler helps us catch any unintended error, such as when we add a second abstract method to the interface.\n\n\nWe can define our own functional interfaces as well.  For instance, we can define:\n\n1\n2\n3\n4\n5\n6\n7\n@FunctionalInterface\n\n\ninterface\n \nFindServerStrategy\n \n{\n\n  \nServer\n \nfindQueue\n(\nShop\n \nshop\n);\n\n\n}\n\n\n\nFindServerStrategy\n \ngreedy\n \n=\n \nshop\n \n->\n \nshop\n.\ngetShortestQueue\n();\n\n\nFindServerStrategy\n \ntypical\n \n=\n \nshop\n \n->\n \nshop\n.\ngetFirstAvailableQueue\n();\n\n\n\n\n\n\nWhile the interface above can be represented with a \nFunction<Shop,Server>\n, one might find it easier to read \n\n1\ngreedy.findQueue(shop)\n\n\n\n\n\nas opposed to:\n\n1\ngreedy.apply(shop)\n\n\n\n\n\nFunctor\n\n\nIn this lecture, we are going to abstract out some useful patterns that we have seen so far in functional-style programming in Java, and relates it to concepts in functional programming.\n\nOnce you see and understand the patterns, hopefully you can reapply the patterns in other context.\n\n\nLet's start with a simple one, called \nfunctor\n.  This funny name originated from a branch of mathematics, called category theory.  We can think of a functor as something that takes in a function and returns another functor.  We can think of it the interface below:\n\n\n1\n2\n3\ninterface\n \nFunctor\n<\nT\n>\n \n{\n\n  \npublic\n \n<\nR\n>\n \nFunctor\n<\nR\n>\n \nf\n(\nFunction\n<\nT\n,\nR\n>\n \nfunc\n);\n\n\n}\n\n\n\n\n\n\n\nA functor can be any class that implements the interface above, or matches the pattern above.\n\n\nLet's took at the example below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nA\n \n{\n\n  \nprivate\n \nint\n \nx\n;\n\n\n  \npublic\n \nA\n(\nint\n \ni\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \ni\n;\n\n  \n}\n\n\n  \npublic\n \nA\n \nf\n(\nFunction\n<\nInteger\n,\nInteger\n>\n \nfunc\n)\n \n{\n\n    \nif\n \n(\nthis\n.\nx\n \n>\n \n0\n)\n \n{\n\n      \nreturn\n \nnew\n \nA\n(\nfunc\n.\napply\n(\nx\n));\n\n    \n}\n \nelse\n \n{\n\n      \nreturn\n \nnew\n \nA\n(\n0\n);\n\n    \n}\n\n  \n}\n\n\n  \npublic\n \nboolean\n \nisSameAs\n(\nA\n \na\n)\n \n{\n\n    \nreturn\n \nthis\n.\nx\n \n==\n \na\n.\nx\n;\n \n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe class \nA\n above takes in a function and returns another \nA\n with \nfunc\n applied on the content \nx\n, if \nx\n is positive.  Otherwise, it returns another \nA\n with 0.  \n\n\nDespite that it does not implement the interface \nFunctor\n1\n, it does match the pattern of having a method that takes in a function and returns itself, it is a special case since both \nR\n and \nT\n are \nInteger\n.\n\n\nFunctor Laws\n\n\nMatching the patterns syntactically, however, is not enough to be a functor.  A functor has to semantically obey the functor laws, which are:\n\n\n\n\nif \nfunc\n is an identity function \nx -> x\n, then it should not change the functor.\n\n\nif \nfunc\n is a composition of two functions \ng \\cdot h\ng \\cdot h\n, then the resulting functor should be the same as calling \nf\n with \nh\nh\n and then with \ng\ng\n.\n\n\n\n\nLet's check: \n\n1\n2\n3\nA a = new A(-1);\na.isSameAs(a.f(x -> x));\na.f(x -> x + 1).f(x -> x * 2).isSameAs(a.f(x -> (x + 1) * 2));\n\n\n\n\n\nThe second line above failed to return true.  As such, class \nA\n violates the first functor law and therefore is not a functor.  Class \nB\n below, however, is a functor:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nB\n \n{\n\n  \nprivate\n \nint\n \nx\n;\n\n\n  \npublic\n \nB\n(\nint\n \ni\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \ni\n;\n\n  \n}\n\n\n  \npublic\n \nB\n \nf\n(\nFunction\n<\nInteger\n,\nInteger\n>\n \nfunc\n)\n \n{\n\n    \nreturn\n \nnew\n \nB\n(\nfunc\n.\napply\n(\nx\n));\n\n  \n}\n\n\n  \npublic\n \nboolean\n \nisSameAs\n(\nB\n \na\n)\n \n{\n\n    \nreturn\n \nthis\n.\nx\n \n==\n \na\n.\nx\n;\n \n  \n}\n\n\n}\n\n\n\n\n\n\n\nIt is easy to see that if \nfunc\n is \nx -> x\n, then \nB(func.apply(x))\n is just \nB(x)\n.  Further, if \nfunc\n is \ng.compose(h)\n, then calling \nfunc.apply(x)\n is the same as \ng.apply(h.apply(x))\n.\n\n\nAnother way to think of a functor, in the OO-way, is that that it is \na variable wrapped within a class in some context\n.  Instead of manipulating the variable directly, we pass in a function to the class to manipulate the variable.  The variable must then interact with the function as if it is not be wrapped, and the class should not interfere with the function (as in the class \nA\n).  In other words, we use lambda expression for \ncross-abstraction barrier manipulation\n.\n\n\nYou have actually seen several functors before.  You might recognize by now that \nf\n is just our old friend \nmap\n.  \nLambdaList\n (from Lecture 7), \nInfiniteList\n (from Lab 4), and \nStream\n (from \njava.util.stream\n) are functors wrap around a (possibly infinite) list of items.\n\n\n\n\nFunctors in other languages\n\n\nHaskell, Scala, Python, Javascript, and other functional languages have functors as well.  C++, unfortunately, uses the term functors to mean function object -- a function object is not a functor in the sense of the word in category theory.  So, do not get confused between the two.\n\n\n\n\nOnce you understand the laws of functor and recognize this pattern, it is easy to learn about new classes -- one just have to tell you that it is a functor, and you will know how the class should behave.  For instance, I can tell you that \nOptional\n is a functor.  Do you know what method \nOptional\n supports and how it behave?\n\n\nRecall that you can wrapped a possibly \nnull\n object in an \nOptional\n class.  We can manipulate the value[^2] wrapped in an \nOptional\n with the \nmap\n function.  The \nmap\n method applies the given method only if the value is present, preventing us from writing a if-not-null check and the danger of \nNullPointerException\n if we forget to check.\n\n\n\n\nIssues with Java \nOptional\n\n\nJava's \nOptional\n is not very well-designed.  It is unfortunate that Java 8 provides a \nget()\n method to allow retrieval of the object inside the functor, with the possibility of causing a run-time exception if \nOptional\n is empty.  The whole point of using \nOptional\n is to be safe from run-time exception!  Not to mentioned that Java Collections Framework does not support \nOptional\n.  \n\n\n\n\nMonad\n\n\nA monad also takes in a function and returns a monad.  But, unlike functor, it takes in a function that returns a monad.\n\n\n1\n2\n3\ninterface\n \nMonad\n<\nT\n>\n \n{\n\n  \npublic\n \n<\nR\n>\n \nMonad\n<\nR\n>\n \nf\n(\nFunction\n<\nT\n,\nMonad\n<\nR\n>>\n \nfunc\n);\n\n\n}\n\n\n\n\n\n\n\nThe pattern above might look complicated, but you have actually seen it before:\n\n\n1\n2\n3\ninterface\n \nStream\n<\nT\n>\n \n{\n\n  \npublic\n \n<\nR\n>\n \nStream\n<\nR\n>\n \nflatMap\n(\nFunction\n<\nT\n,\nStream\n<\nR\n>>\n \nmapper\n);\n\n\n}\n\n\n\n\n\n\n\nThis interface should look familiar to you\n2\n.  We have seen monads before -- \nStream\n is a monad.  In contrast, unless you implemented \nflatMap\n for \nInfiniteList\n or \nLambdaList\n, they are not monads.\n\n\nMonad Laws\n\n\nJust like functors, there are some laws that a monad have to follow:\n\n\n\n\n\n\nthere should be an \nof\n operation that takes an object (or multiple objects) and wrap it/them into a monad.  Further, \n\n\n\n\nMonad.of(x).flatMap(f)\n should be equal to \nf(x)\n  (called the \nleft identity\n law)\n\n\nmonad.flatMap(x -> Monad.of(x))\n should be equal to \nmonad\n (called the \nright identity\n law)\n\n\n\n\n\n\n\n\nthe \nflatMap\n operation should be associative (associative law):\n\nmonad.flatMap(f).flatMap(g)\n should be equal to \nmonad.flatMap(x -> f(x).flatMap(g))\n\n\n\n\n\n\n\n\nIn other languages\n\n\nThe \nflatMap\n and \nof\n operations are sometimes known as the \nbind\n and \nunit\n operations respectively (e.g., in Haskell).\n\n\n\n\nKnowing what is a monad is useful, since if I tell you something is a monad, you should recognize that it supports a given interface.  For instance, I tell you that \nOptional\n is a monad.  You should know that \nOptional\n supports the \nof\n and \nflatMap\n operation.   The name of the operations may be different, but they must exists in a monad and follows the monad laws.\n\n\nWe won't proof formally that \nOptional\n follows the laws of monad in this class, but let's explore a bit more to convince ourselves that it does.  Let's write the \nflatMap\n method for \nOptional\n, which is not that difficult:\n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n<\nU\n>\n \nOptional\n<\nU\n>\n \nflatMap\n(\nFunction\n<?\n \nsuper\n \nT\n,\n \nOptional\n<\nU\n>>\n \nmapper\n)\n \n{\n\n  \nif\n \n(!\nisPresent\n())\n \n{\n\n    \nreturn\n \nempty\n();\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nmapper\n.\napply\n(\nvalue\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nLet check:\n\n\n\n\nLeft identity law: \nOptional.of(x).flatMap(f)\n will return \nf.apply(x)\n (i.e., \nf(1)\nf(1)\n).\n\n\nRight identity law: \nopt.flatMap(x -> Optional.of(x)\n will apply \nx -> Optional.of(x)\n on the value of \nopt\n, if it exists, resulting in \nOptional.of(value)\n, which is \nopt\n. If the value does not exist (\nOptional\n is empty), then \nflatMap\n will not apply the lambda, instead it will return \nempty()\n right away.  So it obeys the law.\n\n\nAssociative law: \nopt.flatMap(f).flatMap(g)\n is the same as \nf.apply(value).flatMap(g)\n; \nopt.flatMap(x -> f(x).flatMap(g))\n will apply the lambda to \nvalue\n, so we get \nf.apply(value).flatMap(g)\n.  They are the same.  If \nopt\n is empty, then \nflatMap\n returns \nempty\n for both cases.\n\n\n\n\nSo, despite the complicated-sounding laws, they are actually easy to verify.\n\n\nImplementing Strategy or Policy\n\n\nPolymorphism is one of the pillars of OO programming.  We have seen how, through inheritance and polymorphism, we can extend the behavior of a class.  In some cases, polymorphism is useful for implementing different behaviors for different subclasses.  For instance, \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass\n \nServer\n \n{\n\n  \nServer\n()\n \n{\n \n}\n\n  \nabstract\n \nboolean\n \nneedRest\n();\n\n  \nabstract\n \nvoid\n \navailable\n();\n\n\n}\n\n\n\nclass\n \nHumanServer\n \nextends\n \nServer\n \n{\n\n  \nboolean\n \nneedRest\n()\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nvoid\n \navailable\n()\n \n{\n\n    \nsay\n(\n\"Next, please!\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nMachineServer\n \nextends\n \nServer\n \n{\n\n  \nboolean\n \nneedRest\n()\n \n{\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n  \nvoid\n \navailable\n()\n \n{\n\n    \nturnLightGreen\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWe override the method \nneedRest\n to indicate if a particular server needs to rest, and \navailable\n to perform an action when the server becomes available.  This is sometimes known as the \nstrategy\n pattern or the \npolicy\n pattern, where each class encapsulates a different way of achiving the same thing.  \n\n\nYou may see that, since \nneedRest\n only returns a constant, one could easily store that in a field.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass\n \nServer\n \n{\n\n  \nboolean\n \nneedRest\n;\n\n\n  \nServer\n(\nboolean\n \nneedRest\n)\n \n{\n\n    \nthis\n.\nneedRest\n \n=\n \nneedRest\n;\n\n  \n}\n\n\n  \nboolean\n \nneedRest\n()\n \n{\n\n    \nreturn\n \nneedRest\n;\n\n  \n}\n\n\n  \nabstract\n \nvoid\n \navailable\n();\n\n\n}\n\n\n\nclass\n \nHumanServer\n \nextends\n \nServer\n \n{\n\n  \nvoid\n \navailable\n()\n \n{\n\n    \nsay\n(\n\"Next, please!\"\n);\n\n  \n}\n\n\n}\n\n\n\nclass\n \nMachineServer\n \nextends\n \nServer\n \n{\n\n  \nvoid\n \navailable\n()\n \n{\n\n    \nturnLightGreen\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWhat about the strategy?  With lambda expressions, it turns out that we can store the body of the method in a field as well.  The \navailable\n method takes in no argument and returns nothing, so the functional interface \nRunnable\n is perfect for this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nServer\n \n{\n\n  \nboolean\n \nneedRest\n;\n\n  \nRunnable\n \navailableAction\n;\n\n\n  \nServer\n(\nboolean\n \nneedRest\n,\n \nRunnable\n \naction\n)\n \n{\n\n    \nthis\n.\nneedRest\n \n=\n \nneedRest\n;\n\n    \nthis\n.\navailableAction\n \n=\n \naction\n;\n\n  \n}\n\n\n  \nboolean\n \nneedRest\n()\n \n{\n\n    \nreturn\n \nneedRest\n;\n\n  \n}\n\n\n  \nvoid\n \navailable\n()\n \n{\n\n    \navailableAction\n.\nrun\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWe have removed two subclasses.  Instead of:\n\n\n1\n2\nh\n \n=\n \nnew\n \nHumanServer\n();\n\n\nm\n \n=\n \nnew\n \nMachineServer\n();\n\n\n\n\n\n\n\nwe can do\n\n\n1\n2\nh\n \n=\n \nnew\n \nServer\n(\ntrue\n,\n  \n()\n \n->\n \nsay\n(\n\"Next, please!\"\n));\n \n\nm\n \n=\n \nnew\n \nServer\n(\nfalse\n,\n \n()\n \n->\n \nturnLightGreen\n());\n\n\n\n\n\n\n\nSuch style of code makes the intention more explicit (no need to trace through different class files to understand the behavior), but exposes some implementation details.  In terms of extensibility, it is easier, since we no longer need to create subclasses to add a new type of behavior.  For example, we can say:\n\n\n1\nnew\n \nServer\n(\ntrue\n,\n \n()\n \n->\n \nannounceNextQueueNumber\n());\n\n\n\n\n\n\n\nEither of these style (OOP or FP) is better than having to write switch statements or if-then-else statements if we code in imperative style.\n\n\nObserver Pattern\n\n\nOften, in our code, an event can trigger a series of actions.  For instance, pressing a button on the GUI could trigger an update to the user interface, a sound to be played, an action to be performed, etc.  While one could hardcode these responses to a trigger, it would be nicer if one could add a customer action in response to a trigger.  For instance, we might want to say, log an entry into a file when the button is pressed.\n\n\nIn OO design, this is known as the Observer pattern.  With lambda, we can implement something like this with a list of lambda expressions:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nEvent\n \n{\n\n  \nList\n<\nRunnable\n>\n \nactions\n;\n\n\n    \nEvent() {\n\n        \nactions\n \n=\n \nnew\n \nArrayList\n<>\n();\n\n    \n}\n\n\n  \nvoid\n \nregister\n(\nRunnable\n \nr\n)\n \n{\n\n    \nactions\n.\nadd\n(\nr\n);\n\n  \n}\n\n\n  \nvoid\n \ntrigger() {\n\n    \nfor\n \n(\nRunnable\n \nr\n: \nactions\n)\n \n{\n\n      \nr\n.\nrun\n();\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThis allows us to cleanly separate the different \nconcerns\n.  In the button example, which is a GUI component, we no longer need to mixed code dealing with sounds, logging, nor application-specific actions.  Each of these can be implemented in a different packages, and only need to register their code to the list of actions to perform when the button is pressed.\n\n\nExercise\n\n\n\n\n\n\nThe interface \nSummaryStrategy\n has a single abstract method \nsummarize\n, allowing any implementing class to define its own strategy of summarizing a long \nString\n to within the length of a given \nlengthLimit\n.  The declaration of the interface is as follows: \n\n\n1\n2\n3\n4\n@FunctionalInterface\n\n\ninterface\n \nSummaryStrategy\n \n{\n\n  \nString\n \nsummarize\n(\nString\n \ntext\n,\n \nint\n \nlengthLimit\n);\n\n\n}\n\n\n\n\n\n\n\nThere is another method \ncreateSnippet\n that takes in a \nSummaryStrategy\n object as an argument.  \n\n\n1\n2\n3\nvoid\n \ncreateSnippet\n(\nSummaryStrategy\n \nstrategy\n)\n \n{\n \n    \n:\n\n\n}\n\n\n\n\n\n\n\nSuppose that there is a class \nTextShortener\n with a static method \nString shorten(String s, int n)\n that shortens the String \ns\n to within the length of \nn\n.  This method can serve as a summary strategy, and you want to use \nshorten\n as a \nSummaryStrategy\n in the method \ncreateSnippet\n.  \n\n\nShow how you would call \ncreateSnippet\n with the static method \nshorten\n from the class \nTextShortener\n as the strategy.\n\n\n\n\n\n\nSuppose we have a snippet of code as follows, \n\n\n1\n2\nDouble d = foo(i);\nString s = bar(d);\n\n\n\n\n\n\nWe can write it either as:\n\n\n1\nstream.map(i -> foo(i)).map(d -> bar(d));\n\n\n\n\n\n\nor \n\n\n1\nstream.map(i -> bar(foo(i)))\n\n\n\n\n\n\nWe can be assured that the expressions above are the same because a stream is a functor.  Why?  Explain by indicating which law ensures the behavior above is true.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn fact, no functors in Java 8 does, since this is the interface I created just to explain the pattern of a functor.\u00a0\n\u21a9\n\n\n\n\n\n\nJust a reminder again that these are not real interfaces in Java but just something to show you the types of input/output to a monad in a language that you are familiar with.\u00a0\n\u21a9",
            "title": "9. FP Patterns"
        },
        {
            "location": "/lec09/index.html#lecture-9-functional-style-programming-patterns",
            "text": "",
            "title": "Lecture 9: Functional-Style Programming Patterns"
        },
        {
            "location": "/lec09/index.html#learning-objectives",
            "text": "After this lecture, students should:   Understand what is a SAM and how to write own's functional interface that can be represented by a lambda expression  Understand what are functors and monads in the context of Java's  Stream ,  Optional  Understand the laws that a functor and monad must obey and be able to verify them  Aware of different programming patterns using lambda, including functor, monad, polymorphism, and observer.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec09/index.html#functional-interface",
            "text": "We have seen how we can write lambda expressions of types  Function ,  Predicate ,  Supplier ,  Consumer , and  BiFunction .  We, however, are not limited the types defined in  java.util.function .  We can use a lambda expression as a short hand to an anonymous class that implements any interface with  a single abstract method .   The reason there has to be only one abstract method is so that the compiler can infer which method body the lambda expression implements.  Such an interface is more commonly known as a  SAM interface .    A SAM interface can contain multiple methods, but only one needs to be abstract, others can contain  default  implementations.  For instance, Java has the following interface: 1\n2\n3 interface   Runnable   { \n   void   run ();  }    There is only one method, and it is abstract (no default implementation).  So it is a valid SAM interface.  We can write:  1 Runnable   r   =   ()   ->   {   System . out . println ( \"hello world\" );   }    We can annotate a class with  @FunctionalInterface  to hint our intention to the compiler and to let the compiler helps us catch any unintended error, such as when we add a second abstract method to the interface.  We can define our own functional interfaces as well.  For instance, we can define: 1\n2\n3\n4\n5\n6\n7 @FunctionalInterface  interface   FindServerStrategy   { \n   Server   findQueue ( Shop   shop );  }  FindServerStrategy   greedy   =   shop   ->   shop . getShortestQueue ();  FindServerStrategy   typical   =   shop   ->   shop . getFirstAvailableQueue ();    While the interface above can be represented with a  Function<Shop,Server> , one might find it easier to read  1 greedy.findQueue(shop)   as opposed to: 1 greedy.apply(shop)",
            "title": "Functional Interface"
        },
        {
            "location": "/lec09/index.html#functor",
            "text": "In this lecture, we are going to abstract out some useful patterns that we have seen so far in functional-style programming in Java, and relates it to concepts in functional programming. \nOnce you see and understand the patterns, hopefully you can reapply the patterns in other context.  Let's start with a simple one, called  functor .  This funny name originated from a branch of mathematics, called category theory.  We can think of a functor as something that takes in a function and returns another functor.  We can think of it the interface below:  1\n2\n3 interface   Functor < T >   { \n   public   < R >   Functor < R >   f ( Function < T , R >   func );  }    A functor can be any class that implements the interface above, or matches the pattern above.  Let's took at the example below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   A   { \n   private   int   x ; \n\n   public   A ( int   i )   { \n     this . x   =   i ; \n   } \n\n   public   A   f ( Function < Integer , Integer >   func )   { \n     if   ( this . x   >   0 )   { \n       return   new   A ( func . apply ( x )); \n     }   else   { \n       return   new   A ( 0 ); \n     } \n   } \n\n   public   boolean   isSameAs ( A   a )   { \n     return   this . x   ==   a . x ;  \n   }  }    The class  A  above takes in a function and returns another  A  with  func  applied on the content  x , if  x  is positive.  Otherwise, it returns another  A  with 0.    Despite that it does not implement the interface  Functor 1 , it does match the pattern of having a method that takes in a function and returns itself, it is a special case since both  R  and  T  are  Integer .",
            "title": "Functor"
        },
        {
            "location": "/lec09/index.html#functor-laws",
            "text": "Matching the patterns syntactically, however, is not enough to be a functor.  A functor has to semantically obey the functor laws, which are:   if  func  is an identity function  x -> x , then it should not change the functor.  if  func  is a composition of two functions  g \\cdot h g \\cdot h , then the resulting functor should be the same as calling  f  with  h h  and then with  g g .   Let's check:  1\n2\n3 A a = new A(-1);\na.isSameAs(a.f(x -> x));\na.f(x -> x + 1).f(x -> x * 2).isSameAs(a.f(x -> (x + 1) * 2));   The second line above failed to return true.  As such, class  A  violates the first functor law and therefore is not a functor.  Class  B  below, however, is a functor:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   B   { \n   private   int   x ; \n\n   public   B ( int   i )   { \n     this . x   =   i ; \n   } \n\n   public   B   f ( Function < Integer , Integer >   func )   { \n     return   new   B ( func . apply ( x )); \n   } \n\n   public   boolean   isSameAs ( B   a )   { \n     return   this . x   ==   a . x ;  \n   }  }    It is easy to see that if  func  is  x -> x , then  B(func.apply(x))  is just  B(x) .  Further, if  func  is  g.compose(h) , then calling  func.apply(x)  is the same as  g.apply(h.apply(x)) .  Another way to think of a functor, in the OO-way, is that that it is  a variable wrapped within a class in some context .  Instead of manipulating the variable directly, we pass in a function to the class to manipulate the variable.  The variable must then interact with the function as if it is not be wrapped, and the class should not interfere with the function (as in the class  A ).  In other words, we use lambda expression for  cross-abstraction barrier manipulation .  You have actually seen several functors before.  You might recognize by now that  f  is just our old friend  map .   LambdaList  (from Lecture 7),  InfiniteList  (from Lab 4), and  Stream  (from  java.util.stream ) are functors wrap around a (possibly infinite) list of items.   Functors in other languages  Haskell, Scala, Python, Javascript, and other functional languages have functors as well.  C++, unfortunately, uses the term functors to mean function object -- a function object is not a functor in the sense of the word in category theory.  So, do not get confused between the two.   Once you understand the laws of functor and recognize this pattern, it is easy to learn about new classes -- one just have to tell you that it is a functor, and you will know how the class should behave.  For instance, I can tell you that  Optional  is a functor.  Do you know what method  Optional  supports and how it behave?  Recall that you can wrapped a possibly  null  object in an  Optional  class.  We can manipulate the value[^2] wrapped in an  Optional  with the  map  function.  The  map  method applies the given method only if the value is present, preventing us from writing a if-not-null check and the danger of  NullPointerException  if we forget to check.   Issues with Java  Optional  Java's  Optional  is not very well-designed.  It is unfortunate that Java 8 provides a  get()  method to allow retrieval of the object inside the functor, with the possibility of causing a run-time exception if  Optional  is empty.  The whole point of using  Optional  is to be safe from run-time exception!  Not to mentioned that Java Collections Framework does not support  Optional .",
            "title": "Functor Laws"
        },
        {
            "location": "/lec09/index.html#monad",
            "text": "A monad also takes in a function and returns a monad.  But, unlike functor, it takes in a function that returns a monad.  1\n2\n3 interface   Monad < T >   { \n   public   < R >   Monad < R >   f ( Function < T , Monad < R >>   func );  }    The pattern above might look complicated, but you have actually seen it before:  1\n2\n3 interface   Stream < T >   { \n   public   < R >   Stream < R >   flatMap ( Function < T , Stream < R >>   mapper );  }    This interface should look familiar to you 2 .  We have seen monads before --  Stream  is a monad.  In contrast, unless you implemented  flatMap  for  InfiniteList  or  LambdaList , they are not monads.",
            "title": "Monad"
        },
        {
            "location": "/lec09/index.html#monad-laws",
            "text": "Just like functors, there are some laws that a monad have to follow:    there should be an  of  operation that takes an object (or multiple objects) and wrap it/them into a monad.  Further,    Monad.of(x).flatMap(f)  should be equal to  f(x)   (called the  left identity  law)  monad.flatMap(x -> Monad.of(x))  should be equal to  monad  (called the  right identity  law)     the  flatMap  operation should be associative (associative law): monad.flatMap(f).flatMap(g)  should be equal to  monad.flatMap(x -> f(x).flatMap(g))     In other languages  The  flatMap  and  of  operations are sometimes known as the  bind  and  unit  operations respectively (e.g., in Haskell).   Knowing what is a monad is useful, since if I tell you something is a monad, you should recognize that it supports a given interface.  For instance, I tell you that  Optional  is a monad.  You should know that  Optional  supports the  of  and  flatMap  operation.   The name of the operations may be different, but they must exists in a monad and follows the monad laws.  We won't proof formally that  Optional  follows the laws of monad in this class, but let's explore a bit more to convince ourselves that it does.  Let's write the  flatMap  method for  Optional , which is not that difficult:  1\n2\n3\n4\n5\n6\n7 public < U >   Optional < U >   flatMap ( Function <?   super   T ,   Optional < U >>   mapper )   { \n   if   (! isPresent ())   { \n     return   empty (); \n   }   else   { \n     return   mapper . apply ( value ); \n   }  }    Let check:   Left identity law:  Optional.of(x).flatMap(f)  will return  f.apply(x)  (i.e.,  f(1) f(1) ).  Right identity law:  opt.flatMap(x -> Optional.of(x)  will apply  x -> Optional.of(x)  on the value of  opt , if it exists, resulting in  Optional.of(value) , which is  opt . If the value does not exist ( Optional  is empty), then  flatMap  will not apply the lambda, instead it will return  empty()  right away.  So it obeys the law.  Associative law:  opt.flatMap(f).flatMap(g)  is the same as  f.apply(value).flatMap(g) ;  opt.flatMap(x -> f(x).flatMap(g))  will apply the lambda to  value , so we get  f.apply(value).flatMap(g) .  They are the same.  If  opt  is empty, then  flatMap  returns  empty  for both cases.   So, despite the complicated-sounding laws, they are actually easy to verify.",
            "title": "Monad Laws"
        },
        {
            "location": "/lec09/index.html#implementing-strategy-or-policy",
            "text": "Polymorphism is one of the pillars of OO programming.  We have seen how, through inheritance and polymorphism, we can extend the behavior of a class.  In some cases, polymorphism is useful for implementing different behaviors for different subclasses.  For instance,    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 class   Server   { \n   Server ()   {   } \n   abstract   boolean   needRest (); \n   abstract   void   available ();  }  class   HumanServer   extends   Server   { \n   boolean   needRest ()   { \n     return   true ; \n   } \n   void   available ()   { \n     say ( \"Next, please!\" ); \n   }  }  class   MachineServer   extends   Server   { \n   boolean   needRest ()   { \n     return   false ; \n   } \n   void   available ()   { \n     turnLightGreen (); \n   }  }    We override the method  needRest  to indicate if a particular server needs to rest, and  available  to perform an action when the server becomes available.  This is sometimes known as the  strategy  pattern or the  policy  pattern, where each class encapsulates a different way of achiving the same thing.    You may see that, since  needRest  only returns a constant, one could easily store that in a field.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 class   Server   { \n   boolean   needRest ; \n\n   Server ( boolean   needRest )   { \n     this . needRest   =   needRest ; \n   } \n\n   boolean   needRest ()   { \n     return   needRest ; \n   } \n\n   abstract   void   available ();  }  class   HumanServer   extends   Server   { \n   void   available ()   { \n     say ( \"Next, please!\" ); \n   }  }  class   MachineServer   extends   Server   { \n   void   available ()   { \n     turnLightGreen (); \n   }  }    What about the strategy?  With lambda expressions, it turns out that we can store the body of the method in a field as well.  The  available  method takes in no argument and returns nothing, so the functional interface  Runnable  is perfect for this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   Server   { \n   boolean   needRest ; \n   Runnable   availableAction ; \n\n   Server ( boolean   needRest ,   Runnable   action )   { \n     this . needRest   =   needRest ; \n     this . availableAction   =   action ; \n   } \n\n   boolean   needRest ()   { \n     return   needRest ; \n   } \n\n   void   available ()   { \n     availableAction . run (); \n   }  }    We have removed two subclasses.  Instead of:  1\n2 h   =   new   HumanServer ();  m   =   new   MachineServer ();    we can do  1\n2 h   =   new   Server ( true ,    ()   ->   say ( \"Next, please!\" ));   m   =   new   Server ( false ,   ()   ->   turnLightGreen ());    Such style of code makes the intention more explicit (no need to trace through different class files to understand the behavior), but exposes some implementation details.  In terms of extensibility, it is easier, since we no longer need to create subclasses to add a new type of behavior.  For example, we can say:  1 new   Server ( true ,   ()   ->   announceNextQueueNumber ());    Either of these style (OOP or FP) is better than having to write switch statements or if-then-else statements if we code in imperative style.",
            "title": "Implementing Strategy or Policy"
        },
        {
            "location": "/lec09/index.html#observer-pattern",
            "text": "Often, in our code, an event can trigger a series of actions.  For instance, pressing a button on the GUI could trigger an update to the user interface, a sound to be played, an action to be performed, etc.  While one could hardcode these responses to a trigger, it would be nicer if one could add a customer action in response to a trigger.  For instance, we might want to say, log an entry into a file when the button is pressed.  In OO design, this is known as the Observer pattern.  With lambda, we can implement something like this with a list of lambda expressions:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   Event   { \n   List < Runnable >   actions ; \n\n     Event() { \n         actions   =   new   ArrayList <> (); \n     } \n\n   void   register ( Runnable   r )   { \n     actions . add ( r ); \n   } \n\n   void   trigger() { \n     for   ( Runnable   r :  actions )   { \n       r . run (); \n     } \n   }  }    This allows us to cleanly separate the different  concerns .  In the button example, which is a GUI component, we no longer need to mixed code dealing with sounds, logging, nor application-specific actions.  Each of these can be implemented in a different packages, and only need to register their code to the list of actions to perform when the button is pressed.",
            "title": "Observer Pattern"
        },
        {
            "location": "/lec09/index.html#exercise",
            "text": "The interface  SummaryStrategy  has a single abstract method  summarize , allowing any implementing class to define its own strategy of summarizing a long  String  to within the length of a given  lengthLimit .  The declaration of the interface is as follows:   1\n2\n3\n4 @FunctionalInterface  interface   SummaryStrategy   { \n   String   summarize ( String   text ,   int   lengthLimit );  }    There is another method  createSnippet  that takes in a  SummaryStrategy  object as an argument.    1\n2\n3 void   createSnippet ( SummaryStrategy   strategy )   {  \n     :  }    Suppose that there is a class  TextShortener  with a static method  String shorten(String s, int n)  that shortens the String  s  to within the length of  n .  This method can serve as a summary strategy, and you want to use  shorten  as a  SummaryStrategy  in the method  createSnippet .    Show how you would call  createSnippet  with the static method  shorten  from the class  TextShortener  as the strategy.    Suppose we have a snippet of code as follows,   1\n2 Double d = foo(i);\nString s = bar(d);   We can write it either as:  1 stream.map(i -> foo(i)).map(d -> bar(d));   or   1 stream.map(i -> bar(foo(i)))   We can be assured that the expressions above are the same because a stream is a functor.  Why?  Explain by indicating which law ensures the behavior above is true.        In fact, no functors in Java 8 does, since this is the interface I created just to explain the pattern of a functor.\u00a0 \u21a9    Just a reminder again that these are not real interfaces in Java but just something to show you the types of input/output to a monad in a language that you are familiar with.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec10/index.html",
            "text": "Lecture 10: Parallel Streams\n\n\nLearning Objectives\n\n\nAfter attending this lecture, students should:\n\n\n\n\nbe aware that a program can be broken into subtasks to run parallelly and/or concurrently \n\n\nbe aware of the issues caused by running the subtasks parallelly and concurrently.\n\n\nbe aware of that there exist tradeoffs in the number of subtasks and the processing overhead.\n\n\nbe familiar with how to process a stream parallelly and correctly.\n\n\nbe familiar with the Java's fork/join framework. \n\n\n\n\nParallel and Concurrent Programming\n\n\nSo far, the programs that we have written in CS2030 run \nsequentially\n.  What this means is that at any one time, there is only one instruction of the program running on a processor.  \n\n\nWhat is concurrency?\n\n\nA single core processor can only execute one instruction at one time -- this means that only one \nprocess\n  (or less precisely speaking, one application) can run at any one time.  Yet, when we use the computer, it \nfeels\n as if we are running multiple processes at the same time.  The operating system, behind the scene, is actually switching between the different processes, to give the user an illusion that they are running at the same time.\n\n\nWe can write a program so that it runs concurrently -- by dividing the computation into subtasks called \nthreads\n.  The operating system, behind the scene, can switch between the different threads, to give the user an illusion that the threads are running at the same time.  Such multi-threads programs are useful in two ways: (i) it allows us, the programmers, to separate the unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor.  For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI.\n\n\nWhat is parallelism?\n\n\nWhile concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time -- either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores / processors and dispatch the instructions to the cores / processors so that they are executed at the same time.\n\n\nAll parallel programs are concurrent, but not all concurrent programs are parallel.\n\n\nModern computers have more than one core/processor\n1\n.  As such, the line between parallelism and concurrency is blurred.\n\n\nParallel computing\n\n\nParallel computing is one of the major topics in computer science.  One can teach a whole module (or a focus area) on this topic alone.  The goal of this lecture is not to cover it in depth, but is to expose students in CS2030 to the concept of parallel computing in relation to the stream abstraction in Java 8.\n\n\nParallel Stream\n\n\nWe have seen that Java \nStream\n class is a powerful and useful class for processing data in declarative style.  But, we have not fully unleashed the power of \nStream\n.  The neatest thing about \nStream\n is that it allows parallel operations on the elements of the stream in one single line of code.  \n\n\nLet's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000.\n\n\n1\n2\n3\n    \nIntStream\n.\nrange\n(\n2_030_000\n,\n \n2_040_000\n)\n\n        \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n        \n.\nforEach\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nWe can parallelize the code by adding the call \nparallel()\n into the stream.\n\n\n1\n2\n3\n4\n    \nIntStream\n.\nrange\n(\n2_030_000\n,\n \n2_040_000\n)\n\n        \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n        \n.\nparallel\n()\n\n        \n.\nforEach\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nYou may observe that the output has been reordered, although the same set of numbers are still being produced.  This is because \nStream\n has broken down the numbers into subsequences, and run \nfilter\n and \nforEach\n for each subsequence in parallel.  Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered.\n\n\nIf you want to produce the output in the order of input, use \nforEachOrdered\n instead of \nforEach\n, we will lose some benefits of parallelization because of this.\n\n\nSuppose now that we want to compute the number of primes between 2,030,000 and 2,040,000.  We can run:\n\n\n1\n2\n3\n4\n    \nIntStream\n.\nrange\n(\n2_030_000\n,\n \n2_040_000\n)\n\n        \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n        \n.\nparallel\n()\n\n        \n.\ncount\n()\n\n\n\n\n\n\n\nThe code above produces the same output regardless of it is being parallelized or not.  \n\n\nNote that the task above is stateless and does not produce any side effect.  Furthermore, each element is processed individually without depending on other elements.  Such computation is sometimes known as \nembarrassingly parallel\n.  The only communication needed for each of the parallel subtasks is to combine the result of \ncount()\n from the subtasks into the final count (which has been implemented in \nStream\n for us.\n\n\nHow to parallelize a stream\n\n\nYou have seen that adding \nparallel()\n to the chain of calls in a stream enables parallel processing of the stream.  Note that \nparallel()\n is a lazy operation -- it merely marks the stream to be processed in parallel.  As such, you can insert the call to \nparallel()\n anywhere in the chain.\n\n\n\n\nsequential()\n\n\nThere is a method \nsequential()\n which marks the stream to be process sequentially.  If you call both \nparallel()\n and \nsequential()\n in a stream,\nthe last call \"wins\".  The example below processes the stream \nsequentially:\n\n1\ns.parallel().filter(x -> x < 0).sequential().forEach(..); \n\n\n\n\n\n\n\nAnother way to create a parallel stream is to call the method \nparallelStream()\n instead of \nstream()\n of the \nCollector\n class.  Doing so would create a stream that will be processed in parallel from the collection.\n\n\nWhat can be parallelized?\n\n\nTo ensure that the output of the parallel execution is correct, the stream operations must not \ninterfere\n with the stream data, and most of time must be \nstateless\n.  Side-effects should be kept to a minimum.\n\n\nInterference\n\n\nInterference means that one of the stream operation modifies the source of the stream during the execution of the terminal operation.  For instance:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nList\n<\nString\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<>(\nList\n.\nof\n(\n\"Luke\"\n,\n \n\"Leia\"\n,\n \n\"Han\"\n));\n\n\nlist\n.\nstream\n()\n\n    \n.\npeek\n(\nname\n \n->\n \n{\n\n         \nif\n \n(\nname\n.\nequals\n(\n\"Han\"\n))\n \n{\n\n           \nlist\n.\nadd\n(\n\"Chewie\"\n);\n \n// they belong together\n\n         \n}\n\n      \n})\n\n    \n.\nforEach\n(\ni\n \n->\n \n{});\n\n\n\n\n\n\n\nWould cause \nConcurrentModificationException\n to be thrown.  Note that this non-interference rule applies even if we are using \nstream()\n instead of \nparallelStream()\n.\n\n\nStateless\n\n\nA stateful lambda is one where the result depends on any state that might change during the execution of stream.\n\n\nFor instance, the \ngenerate\n and \nmap\n operations below are stateful, since they depend on the events in the queue and the states of the shops.  Parallelizing this may lead to incorrect output.  To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks.\n\n\n1\n2\n3\n4\n5\n6\nStream\n.\ngenerate\n(\nthis\n.\nevents\n::\npoll\n)\n\n    \n.\ntakeWhile\n(\nevent\n \n->\n \nevent\n \n!=\n \nnull\n)\n\n    \n.\nfilter\n(\nevent\n \n->\n \nevent\n.\nhappensBefore\n(\nsim\n.\nexpireTime\n()))\n \n    \n.\npeek\n(\nevent\n \n->\n \nevent\n.\nlog\n())\n\n    \n.\nmap\n(\nevent\n \n->\n \nsim\n.\nhandle\n(\nevent\n))\n\n    \n.\nforEach\n(\neventStream\n \n->\n \nthis\n.\nschedule\n(\neventStream\n));\n\n\n\n\n\n\n\nSide Effects\n\n\nSide-effects can lead to incorrect results in parallel execution.  Consider the following code:\n\n\n1\n2\n3\n4\n5\n6\nList\n<\nInteger\n>\n \nlist\n \n=\n \nnew\n \nArrayList\n<>(\n\n    \nArrays\n.\nasList\n(\n1\n,\n3\n,\n5\n,\n7\n,\n9\n,\n11\n,\n13\n,\n15\n,\n17\n,\n19\n));\n\n\nList\n<\nInteger\n>\n \nresult\n \n=\n \nnew\n \nArrayList\n<>();\n\n\nlist\n.\nparallelStream\n()\n\n    \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n    \n.\nforEach\n(\nx\n \n->\n \nresult\n.\nadd\n(\nx\n));\n\n\n\n\n\n\n\nThe \nforEach\n lambda generates a side effect -- it modifies \nresult\n.  \nArrayList\n is what we call a non-thread-safe data structure.  If two threads manipulate it at the same time, an incorrect result may result.\n\n\nThere are two ways to resolve this.  One, we can use the \n.collect\n method \n\n1\n2\n3\nlist\n.\nparallelStream\n()\n\n    \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n    \n.\ncollect\n(\nCollectors\n.\ntoList\n())\n\n\n\n\n\nSecond, we can use a thread-safe data structure.  Java provides several in \njava.util.concurrent\n package, including \nCopyOnWriteArrayList\n.\n\n\n1\n2\n3\n4\nList\n<\nInteger\n>\n \nresult\n \n=\n \nnew\n \nCopyOnWriteArrayList\n<>();\n\n\nlist\n.\nparallelStream\n()\n\n    \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n    \n.\nforEach\n(\nx\n \n->\n \nresult\n.\nadd\n(\nx\n));\n\n\n\n\n\n\n\nAssociativity\n\n\nThe \nreduce\n operation is inherently parallelizable, as we can easily reduce each sub-streams and then use the \ncombiner\n to combine the results together.  Consider this example:\n\n\n1\nStream\n.\nof\n(\n1\n,\n2\n,\n3\n,\n4\n).\nreduce\n(\n1\n,\n \n(\nx\n,\ny\n)->\nx\n*\ny\n,\n \n(\nx\n,\ny\n)->\nx\n*\ny\n);\n\n\n\n\n\n\n\nIn order to allow us to run \nreduce\n in parallel, however, there are several rules that the \nidentity\n, the \naccumulator\n and the \ncombiner\n must follow:\n\n\n\n\ncombiner.apply(identity, i)\n must be equal to \ni\n.\n\n\nThe \ncombiner\n and the \naccumulator\n must be associative -- the order of applying must not matter.\n\n\nThe \ncombiner\n and the \naccumulator\n must be compatible -- \ncombiner.apply(u, accumulator.apply(identity, t))\n must equal to \naccumulator.apply(u, t)\n\n\n\n\nThe multiplication example above meetings the three rules:\n\n\n\n\ni * 1\n equals \ni\n\n\n(x * y) * z\n equals \nx * (y * z)\n\n\nu * (1 * t)\n equals \nu * t\n\n\n\n\nPerformance of Parallel Stream\n\n\nLet's go back to:\n\n\n1\n2\n3\n4\nIntStream\n.\nrange\n(\n2_030_000\n,\n \n2_040_000\n)\n\n    \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n    \n.\nparallel\n()\n\n    \n.\ncount\n()\n\n\n\n\n\n\n\nHow much time can we save by parallelizing the code above?\n\n\nLet's use the \nInstant\n and \nDuration\n class from Java to help us:\n\n\n1\n2\n3\n4\n5\n6\n7\n    \nInstant\n \nstart\n \n=\n \nInstant\n.\nnow\n();\n\n    \nlong\n \nhowMany\n \n=\n \nIntStream\n.\nrange\n(\n2_000_000\n,\n \n3_000_000\n)\n\n        \n.\nfilter\n(\nx\n \n->\n \nisPrime\n(\nx\n))\n\n        \n.\nparallel\n()\n\n        \n.\ncount\n();\n\n    \nInstant\n \nstop\n \n=\n \nInstant\n.\nnow\n();\n\n    \nSystem\n.\nout\n.\nprintln\n(\nhowMany\n \n+\n \n\" \"\n \n+\n \nDuration\n.\nbetween\n(\nstart\n,\nstop\n).\ntoMillis\n()\n \n+\n \n\" ms\"\n);\n\n\n\n\n\n\n\nThe code above measures roughly the time it takes to count the number of primes between 2 million and 3 million.  On my iMac, it takes slightly more than 1 seconds.  If I remove \nparallel()\n, it takes about 450-550 ms.  So we gain about 50% performance.\n\n\nCan we parallelize some more?  Remember how we implement \nisPrime\n2\n\n\n1\n2\n3\n4\n  \nboolean\n \nisPrime\n(\nint\n \nn\n)\n \n{\n\n    \nreturn\n \nIntStream\n.\nrange\n(\n2\n,\n \n(\nint\n)\nMath\n.\nsqrt\n(\nn\n)\n \n+\n \n1\n)\n\n        \n.\nnoneMatch\n(\nx\n \n->\n \nn\n \n%\n \nx\n \n==\n \n0\n);\n\n  \n}\n\n\n\n\n\n\n\nLet's parallelize this to make this even faster!\n\n\n1\n2\n3\n4\n5\n  \nboolean\n \nisPrime\n(\nint\n \nn\n)\n \n{\n\n    \nreturn\n \nIntStream\n.\nrange\n(\n2\n,\n \n(\nint\n)\nMath\n.\nsqrt\n(\nn\n)\n \n+\n \n1\n)\n\n        \n.\nparallel\n()\n\n        \n.\nnoneMatch\n(\nx\n \n->\n \nn\n \n%\n \nx\n \n==\n \n0\n);\n\n  \n}\n\n\n\n\n\n\n\nIf you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower!\n\n\nParallelizing a stream does not always improve the performance\n.\n\n\nTo understand why, we have to delve a bit deeper into how Java implements the parallel streams.  We are going to take a detour to see some parallel programming concepts and important Java classes related to parallel programming first.\n\n\nFork and Join\n\n\nSuppose we have the following code:\n\n\n1\n2\n3\n4\nb\n \n=\n \nf\n(\na\n);\n\n\nc\n \n=\n \ng\n(\nb\n);\n\n\nd\n \n=\n \nh\n(\nb\n);\n\n\ne\n \n=\n \ni\n(\nc\n,\nd\n);\n\n\n\n\n\n\n\nwhich we could visualize as a \ncomputation graph\n, which looks like the following:\n\n\n\n\nIt should be clear that \nf(a)\n has to be invoked before \ng(b)\n and \nh(b)\n, and \ni(c,d)\n has to be invoked after both \ng(b)\n and \nh(b)\n complete.  What about the order of \ng(b)\n and \nh(b)\n? \n\n\nSuppose that \ng()\n and \nh()\n are pure functions, i.e., the outputs \nc\n and \nd\n only depend on \nb\n and nothing else, and \ng()\n and \nh()\n does not produce any side effects, then we can safely conclude that \ng(b)\n and \nh(b)\n can be invoked in any order.  Not only that, they can be invoked in parallel, independently from each other.\n\n\nTo express that we wish to run \ng()\n in parallel to \nh()\n , we can \nfork\n the task \ng()\n -- this means that we tell JVM that it \ncould\n3\n execute \ng()\n at the same time as \nh()\n.  \n\n\nWe can then \njoin\n back the task \ng()\n.  The join operation causes our code to wait for \ng()\n to complete, ensuring that the updated value of \nc\n is available when \ni(c,d)\n is called.\n\n\nThis pattern of invoking tasks in parallel is called the fork/join framework.  It typically involves some recursive forking and joining to break down a huge task to many smaller ones (but don't have to).  We will see a more concrete example below.\n\n\nThe \nForkJoinTask<V>\n Abstract Class\n\n\nJava provides an abstraction for a task that can be forked and joined, aptly called \nForkJoinTask\n.  This is an abstract class, which we will not use directly.  The class has many methods, but the two most important ones, which we will use, are \nfork()\n and \njoin()\n.  The method \nfork()\n submits this task to JVM for execution, possibly parallely.  The method \njoin()\n waits for the computation to complete and returns the value of type \nV\n.\n\n\nThe \nRecursiveTask<V>\n Abstract Class\n\n\nA \nForkJoinTask<V>\n has a subclass called \nRecursiveTask<V>\n, which is also abstract.  It has a method \nV compute()\n, which we can customize with the task we want for compute.\n\n\nHere is an example task of how we can use \nRecursiveTask<V>\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n  \nstatic\n \nclass\n \nSummer\n \nextends\n \nRecursiveTask\n<\nInteger\n>\n \n{\n\n    \nfinal\n \nint\n \nFORK_THRESHOLD\n \n=\n \n2\n;\n\n    \nint\n \nlow\n;\n\n    \nint\n \nhigh\n;\n\n    \nint\n[]\n \narray\n;\n\n\n    \nSummer\n(\nint\n \nlow\n,\n \nint\n \nhigh\n,\n \nint\n[]\n \narray\n)\n \n{\n\n      \nthis\n.\nlow\n \n=\n \nlow\n;\n\n      \nthis\n.\nhigh\n \n=\n \nhigh\n;\n\n      \nthis\n.\narray\n \n=\n \narray\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nInteger\n \ncompute\n()\n \n{\n\n      \n// stop splitting into subtask if array is already small.\n\n      \nif\n \n(\nhigh\n \n-\n \nlow\n \n<\n \nFORK_THRESHOLD\n)\n \n{\n\n        \nint\n \nsum\n \n=\n \n0\n;\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \nlow\n;\n \ni\n \n<\n \nhigh\n;\n \ni\n++)\n \n{\n\n          \nsum\n \n+=\n \narray\n[\ni\n];\n\n        \n}\n\n        \nreturn\n \nsum\n;\n\n      \n}\n \n\n      \nint\n \nmiddle\n \n=\n \n(\nlow\n \n+\n \nhigh\n)\n \n/\n \n2\n;\n\n      \nSummer\n \nleft\n \n=\n \nnew\n \nSummer\n(\nlow\n,\n \nmiddle\n,\n \narray\n);\n\n      \nSummer\n \nright\n \n=\n \nnew\n \nSummer\n(\nmiddle\n,\n \nhigh\n,\n \narray\n);\n\n      \nleft\n.\nfork\n();\n\n      \nreturn\n \nright\n.\ncompute\n()\n \n+\n \nleft\n.\njoin\n();\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nTo run the task, we call \ncompute()\n \n\n\n1\n2\n    \nSummer\n \ntask\n \n=\n \nnew\n \nSummer\n(\n0\n,\n \narray\n.\nlength\n,\n \narray\n);\n\n    \nint\n \nsum\n \n=\n \ntask\n.\ncompute\n();\n\n\n\n\n\n\n\n\n\nRecursiveAction\n\n\nAnother subclass of \nForkJoinTask\n is called \nRecursiveAction\n, which is very similar to \nRecursiveTask\n, except that \nRecursiveAction\n does not return a value.\n\n\n\n\nThread Pools and Fork/Join\n\n\nInternally, Java maintains a pool of \nworker threads\n.  A worker thread is an abstraction for running a task.  We can submit a task to the pool for execution, the task will join a queue.  There is a global queue for a newly submitted task.  There is also a queue for each worker.   A task spawn from another task executed by a worker will join the queue belonging to that worker.  \n\n\nThe worker thread can pick a task from the queue to execute.  When it is done, it picks another task, if one exists in the queue, and so on -- not unlike our \nServer\n (worker thread) and \nCustomer\n (task).  A \nForkJoinPool\n is a class the implements a thread pool for \nForkJoinTask\n.  An alternative way of executing the \nsumTask\n above is to submit the task to the \nForkJoinPool\n instead of calling it directly.\n\n\n1\nint\n \nsum\n \n=\n \nForkJoinPool\n.\ncommonPool\n().\ninvoke\n(\ntask\n);\n\n\n\n\n\n\n\nThe difference between calling \ninvoke(task)\n versus \ntask.compute()\n is huge, even though both returns us the correct result above.  Calling \ntask.compute()\n means that we are invoking the task immediately and directly (just like any method call); Calling \ninvoke(task)\n, however, means that we are asking the task to join a queue, waiting to be carried out by a worker, and return us the result.  You can see this effect if we have too many recursive tasks, in which case if we call \ntask.compute\n we will end out with a stack overflow.\n\n\nOverhead of Fork/Join\n\n\nYou can see from the description above that forking and joining actually creates additional overhead -- we first need to wrap the computation in an object, submit the object to a queue of tasks.  There are workers that go through the queue to execute the tasks.  You can try different values of \nFORK_TRESHOLD\n to look at the effect.  Here is what the result looks like on my iMac: \n\n\n\n\nThe smaller the fork threshold, the more tasks we create, and the smaller each task becomes.  As the figure shows, if the task to parallelize is too simple, it is not worth to parallelize it due to the overhead cost. \n\n\nParallel Stream using Fork/Join\n\n\nParallel streams are implemented using fork/join in Java.  Here, \nfork\n creates subtasks running the same chain of operations on sub-streams, and when done, run \njoin\n to combine the results (e.g., \ncombiner\n for \nreduce\n is run in \njoin\n).  \nfork\n and \njoin\n can be recursive -- for instance, a \nfork\n operation can split the stream into two subtasks.  The subtasks can further split the sub-streams into four smaller sub-streams, and so on, until the size of the sub-stream is small enough that the task is actually invoked.\n\n\nIn the \nisPrime\n example earlier, the task is trivial (checking \nn % x == 0\n), and so, by parallelizing it, we are actually creating more work for Java to do.  It is much more efficient if we simply check for \nn % x == 0\n sequentially.\n\n\nThe moral of the story is, parallelization is worthwhile if the task is complex enough that the benefit of parallelization outweighs the overhead.  While we discuss this in the context of parallel streams, this principle holds for all parallel and concurrent programs.\n\n\nOrdered vs. Unordered Source\n\n\nWhether or not the stream elements are \nordered\n or \nunordered\n also plays a role in the performance of parallel stream operations.  A stream may define an \nencounter order\n.  Streams created from \niterate\n, ordered collections (e.g., \nList\n or arrays), from \nof\n, are ordered.  Stream created from \ngenerate\n or unordered collections (e.g., \nSet\n) are unordered.\n\n\nSome stream operations respect the encounter order.  For instance, both \ndistinct\n and \nsorted\n preserve the original order of elements (if ordering is preserved, we say that an operation is \nstable\n).\n\n\nThe parallel version of \nfindFirst\n, \nlimit\n, and \nskip\n can be expensive on ordered stream, since it needs to coordinate between the streams to maintain the order.  \n\n\nIf we have an ordered stream and respecting the original order is not important, we can call \nunordered()\n as part of the chain command to make the parallel operations much more efficient.\n\n\nThe following, for example, takes about 700 ms on my iMac:\n\n\n1\n2\n3\n4\n5\n    \nStream\n.\niterate\n(\n0\n,\n \ni\n \n->\n \ni\n \n+\n \n7\n)\n\n        \n.\nparallel\n()\n\n        \n.\nlimit\n(\n10_000_000\n)\n\n        \n.\nfilter\n(\ni\n \n->\n \ni\n \n%\n \n64\n \n==\n \n0\n)\n\n        \n.\nforEachOrdered\n(\ni\n \n->\n \n{\n \n});\n\n\n\n\n\n\n\nBut, with \nunordered()\n inserted, it takes about 350ms, a 2x speed up!\n\n\n1\n2\n3\n4\n5\n6\n    \nStream\n.\niterate\n(\n0\n,\n \ni\n \n->\n \ni\n \n+\n \n7\n)\n\n        \n.\nparallel\n()\n\n        \n.\nunordered\n()\n\n        \n.\nlimit\n(\n10_000_000\n)\n\n        \n.\nfilter\n(\ni\n \n->\n \ni\n \n%\n \n64\n \n==\n \n0\n)\n\n        \n.\nforEachOrdered\n(\ni\n \n->\n \n{\n \n});\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\nThe last two lines of \ncompute\n of \nSummer\n class, which says:\n\n\n1\n2\n    \nleft\n.\nfork\n();\n\n    \nreturn\n \nright\n.\ncompute\n()\n \n+\n \nleft\n.\njoin\n();\n\n\n\n\n\n\n\nWhat would happen if we change these two lines to the following:\n\n\n(a). \n\n1\n    \nreturn\n \nright\n.\ncompute\n()\n \n+\n \nleft\n.\ncompute\n();\n\n\n\n\n\n\n(b). \n\n1\n2\n3\n    \nright\n.\nfork\n();\n\n    \nleft\n.\nfork\n();\n\n    \nreturn\n \nright\n.\njoin\n()\n \n+\n \nleft\n.\njoin\n();\n\n\n\n\n\n\n(c ) \n\n1\n2\n    \nright\n.\nfork\n();\n\n    \nreturn\n \nright\n.\njoin\n()\n \n+\n \nleft\n.\ncompute\n();\n\n\n\n\n\n\n\n\n\n\nWhat is the value of the variable \nx\n after executing the following statement? \n    \n1\nStream\n.\nof\n(\n1\n,\n2\n,\n3\n,\n4\n).\nreduce\n(\n0\n,\n \n(\nresult\n,\n \nx\n)\n \n->\n \nresult\n \n*\n \n2\n \n+\n \nx\n);\n\n\n\n\n\n\nAfter we parallelized the above code into the following, we found the output is different.  Why?\n\n\n1\nStream\n.\nof\n(\n1\n,\n2\n,\n3\n,\n4\n).\nparallel\n().\nreduce\n(\n0\n,\n \n(\nresult\n,\n \nx\n)\n \n->\n \nresult\n \n*\n \n2\n \n+\n \nx\n);\n\n\n\n\n\n\n\n\n\n\nTake the standard implementation of merge sort (e.g., from CS2040) and parallelize it with fork and join.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niPhone X comes with A11 Bionic chip with six cores.  The fastest supercomputer in the world as of this writing, the Sunway TaihuLight (\u795e\u5a01 \u592a\u6e56\u4e4b\u5149), has 40,960 processors, each with 256 cores, giving a total of 10,485,760 cores.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is a more efficient version of the code you have seen, since it stops testing after the square root of the \nn\nn\n.\u00a0\n\u21a9\n\n\n\n\n\n\nThe operating systems and JVM can decide this depends on how many cores or processors are available and how many tasks are pending.  But these details are hidden from us so we do not need to worry about them unless we want to squeeze some performance out of this -- in which case you should to take CS2106 and CS3210.\u00a0\n\u21a9",
            "title": "10. Parallel streams"
        },
        {
            "location": "/lec10/index.html#lecture-10-parallel-streams",
            "text": "",
            "title": "Lecture 10: Parallel Streams"
        },
        {
            "location": "/lec10/index.html#learning-objectives",
            "text": "After attending this lecture, students should:   be aware that a program can be broken into subtasks to run parallelly and/or concurrently   be aware of the issues caused by running the subtasks parallelly and concurrently.  be aware of that there exist tradeoffs in the number of subtasks and the processing overhead.  be familiar with how to process a stream parallelly and correctly.  be familiar with the Java's fork/join framework.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec10/index.html#parallel-and-concurrent-programming",
            "text": "So far, the programs that we have written in CS2030 run  sequentially .  What this means is that at any one time, there is only one instruction of the program running on a processor.",
            "title": "Parallel and Concurrent Programming"
        },
        {
            "location": "/lec10/index.html#what-is-concurrency",
            "text": "A single core processor can only execute one instruction at one time -- this means that only one  process   (or less precisely speaking, one application) can run at any one time.  Yet, when we use the computer, it  feels  as if we are running multiple processes at the same time.  The operating system, behind the scene, is actually switching between the different processes, to give the user an illusion that they are running at the same time.  We can write a program so that it runs concurrently -- by dividing the computation into subtasks called  threads .  The operating system, behind the scene, can switch between the different threads, to give the user an illusion that the threads are running at the same time.  Such multi-threads programs are useful in two ways: (i) it allows us, the programmers, to separate the unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor.  For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI.",
            "title": "What is concurrency?"
        },
        {
            "location": "/lec10/index.html#what-is-parallelism",
            "text": "While concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time -- either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores / processors and dispatch the instructions to the cores / processors so that they are executed at the same time.  All parallel programs are concurrent, but not all concurrent programs are parallel.  Modern computers have more than one core/processor 1 .  As such, the line between parallelism and concurrency is blurred.",
            "title": "What is parallelism?"
        },
        {
            "location": "/lec10/index.html#parallel-computing",
            "text": "Parallel computing is one of the major topics in computer science.  One can teach a whole module (or a focus area) on this topic alone.  The goal of this lecture is not to cover it in depth, but is to expose students in CS2030 to the concept of parallel computing in relation to the stream abstraction in Java 8.",
            "title": "Parallel computing"
        },
        {
            "location": "/lec10/index.html#parallel-stream",
            "text": "We have seen that Java  Stream  class is a powerful and useful class for processing data in declarative style.  But, we have not fully unleashed the power of  Stream .  The neatest thing about  Stream  is that it allows parallel operations on the elements of the stream in one single line of code.    Let's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000.  1\n2\n3      IntStream . range ( 2_030_000 ,   2_040_000 ) \n         . filter ( x   ->   isPrime ( x )) \n         . forEach ( System . out :: println );    We can parallelize the code by adding the call  parallel()  into the stream.  1\n2\n3\n4      IntStream . range ( 2_030_000 ,   2_040_000 ) \n         . filter ( x   ->   isPrime ( x )) \n         . parallel () \n         . forEach ( System . out :: println );    You may observe that the output has been reordered, although the same set of numbers are still being produced.  This is because  Stream  has broken down the numbers into subsequences, and run  filter  and  forEach  for each subsequence in parallel.  Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered.  If you want to produce the output in the order of input, use  forEachOrdered  instead of  forEach , we will lose some benefits of parallelization because of this.  Suppose now that we want to compute the number of primes between 2,030,000 and 2,040,000.  We can run:  1\n2\n3\n4      IntStream . range ( 2_030_000 ,   2_040_000 ) \n         . filter ( x   ->   isPrime ( x )) \n         . parallel () \n         . count ()    The code above produces the same output regardless of it is being parallelized or not.    Note that the task above is stateless and does not produce any side effect.  Furthermore, each element is processed individually without depending on other elements.  Such computation is sometimes known as  embarrassingly parallel .  The only communication needed for each of the parallel subtasks is to combine the result of  count()  from the subtasks into the final count (which has been implemented in  Stream  for us.",
            "title": "Parallel Stream"
        },
        {
            "location": "/lec10/index.html#how-to-parallelize-a-stream",
            "text": "You have seen that adding  parallel()  to the chain of calls in a stream enables parallel processing of the stream.  Note that  parallel()  is a lazy operation -- it merely marks the stream to be processed in parallel.  As such, you can insert the call to  parallel()  anywhere in the chain.   sequential()  There is a method  sequential()  which marks the stream to be process sequentially.  If you call both  parallel()  and  sequential()  in a stream,\nthe last call \"wins\".  The example below processes the stream \nsequentially: 1 s.parallel().filter(x -> x < 0).sequential().forEach(..);     Another way to create a parallel stream is to call the method  parallelStream()  instead of  stream()  of the  Collector  class.  Doing so would create a stream that will be processed in parallel from the collection.",
            "title": "How to parallelize a stream"
        },
        {
            "location": "/lec10/index.html#what-can-be-parallelized",
            "text": "To ensure that the output of the parallel execution is correct, the stream operations must not  interfere  with the stream data, and most of time must be  stateless .  Side-effects should be kept to a minimum.",
            "title": "What can be parallelized?"
        },
        {
            "location": "/lec10/index.html#interference",
            "text": "Interference means that one of the stream operation modifies the source of the stream during the execution of the terminal operation.  For instance:  1\n2\n3\n4\n5\n6\n7\n8 List < String >   list   =   new   ArrayList <>( List . of ( \"Luke\" ,   \"Leia\" ,   \"Han\" ));  list . stream () \n     . peek ( name   ->   { \n          if   ( name . equals ( \"Han\" ))   { \n            list . add ( \"Chewie\" );   // they belong together \n          } \n       }) \n     . forEach ( i   ->   {});    Would cause  ConcurrentModificationException  to be thrown.  Note that this non-interference rule applies even if we are using  stream()  instead of  parallelStream() .",
            "title": "Interference"
        },
        {
            "location": "/lec10/index.html#stateless",
            "text": "A stateful lambda is one where the result depends on any state that might change during the execution of stream.  For instance, the  generate  and  map  operations below are stateful, since they depend on the events in the queue and the states of the shops.  Parallelizing this may lead to incorrect output.  To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks.  1\n2\n3\n4\n5\n6 Stream . generate ( this . events :: poll ) \n     . takeWhile ( event   ->   event   !=   null ) \n     . filter ( event   ->   event . happensBefore ( sim . expireTime ()))  \n     . peek ( event   ->   event . log ()) \n     . map ( event   ->   sim . handle ( event )) \n     . forEach ( eventStream   ->   this . schedule ( eventStream ));",
            "title": "Stateless"
        },
        {
            "location": "/lec10/index.html#side-effects",
            "text": "Side-effects can lead to incorrect results in parallel execution.  Consider the following code:  1\n2\n3\n4\n5\n6 List < Integer >   list   =   new   ArrayList <>( \n     Arrays . asList ( 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ));  List < Integer >   result   =   new   ArrayList <>();  list . parallelStream () \n     . filter ( x   ->   isPrime ( x )) \n     . forEach ( x   ->   result . add ( x ));    The  forEach  lambda generates a side effect -- it modifies  result .   ArrayList  is what we call a non-thread-safe data structure.  If two threads manipulate it at the same time, an incorrect result may result.  There are two ways to resolve this.  One, we can use the  .collect  method  1\n2\n3 list . parallelStream () \n     . filter ( x   ->   isPrime ( x )) \n     . collect ( Collectors . toList ())   \nSecond, we can use a thread-safe data structure.  Java provides several in  java.util.concurrent  package, including  CopyOnWriteArrayList .  1\n2\n3\n4 List < Integer >   result   =   new   CopyOnWriteArrayList <>();  list . parallelStream () \n     . filter ( x   ->   isPrime ( x )) \n     . forEach ( x   ->   result . add ( x ));",
            "title": "Side Effects"
        },
        {
            "location": "/lec10/index.html#associativity",
            "text": "The  reduce  operation is inherently parallelizable, as we can easily reduce each sub-streams and then use the  combiner  to combine the results together.  Consider this example:  1 Stream . of ( 1 , 2 , 3 , 4 ). reduce ( 1 ,   ( x , y )-> x * y ,   ( x , y )-> x * y );    In order to allow us to run  reduce  in parallel, however, there are several rules that the  identity , the  accumulator  and the  combiner  must follow:   combiner.apply(identity, i)  must be equal to  i .  The  combiner  and the  accumulator  must be associative -- the order of applying must not matter.  The  combiner  and the  accumulator  must be compatible --  combiner.apply(u, accumulator.apply(identity, t))  must equal to  accumulator.apply(u, t)   The multiplication example above meetings the three rules:   i * 1  equals  i  (x * y) * z  equals  x * (y * z)  u * (1 * t)  equals  u * t",
            "title": "Associativity"
        },
        {
            "location": "/lec10/index.html#performance-of-parallel-stream",
            "text": "Let's go back to:  1\n2\n3\n4 IntStream . range ( 2_030_000 ,   2_040_000 ) \n     . filter ( x   ->   isPrime ( x )) \n     . parallel () \n     . count ()    How much time can we save by parallelizing the code above?  Let's use the  Instant  and  Duration  class from Java to help us:  1\n2\n3\n4\n5\n6\n7      Instant   start   =   Instant . now (); \n     long   howMany   =   IntStream . range ( 2_000_000 ,   3_000_000 ) \n         . filter ( x   ->   isPrime ( x )) \n         . parallel () \n         . count (); \n     Instant   stop   =   Instant . now (); \n     System . out . println ( howMany   +   \" \"   +   Duration . between ( start , stop ). toMillis ()   +   \" ms\" );    The code above measures roughly the time it takes to count the number of primes between 2 million and 3 million.  On my iMac, it takes slightly more than 1 seconds.  If I remove  parallel() , it takes about 450-550 ms.  So we gain about 50% performance.  Can we parallelize some more?  Remember how we implement  isPrime 2  1\n2\n3\n4    boolean   isPrime ( int   n )   { \n     return   IntStream . range ( 2 ,   ( int ) Math . sqrt ( n )   +   1 ) \n         . noneMatch ( x   ->   n   %   x   ==   0 ); \n   }    Let's parallelize this to make this even faster!  1\n2\n3\n4\n5    boolean   isPrime ( int   n )   { \n     return   IntStream . range ( 2 ,   ( int ) Math . sqrt ( n )   +   1 ) \n         . parallel () \n         . noneMatch ( x   ->   n   %   x   ==   0 ); \n   }    If you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower!  Parallelizing a stream does not always improve the performance .  To understand why, we have to delve a bit deeper into how Java implements the parallel streams.  We are going to take a detour to see some parallel programming concepts and important Java classes related to parallel programming first.",
            "title": "Performance of Parallel Stream"
        },
        {
            "location": "/lec10/index.html#fork-and-join",
            "text": "Suppose we have the following code:  1\n2\n3\n4 b   =   f ( a );  c   =   g ( b );  d   =   h ( b );  e   =   i ( c , d );    which we could visualize as a  computation graph , which looks like the following:   It should be clear that  f(a)  has to be invoked before  g(b)  and  h(b) , and  i(c,d)  has to be invoked after both  g(b)  and  h(b)  complete.  What about the order of  g(b)  and  h(b) ?   Suppose that  g()  and  h()  are pure functions, i.e., the outputs  c  and  d  only depend on  b  and nothing else, and  g()  and  h()  does not produce any side effects, then we can safely conclude that  g(b)  and  h(b)  can be invoked in any order.  Not only that, they can be invoked in parallel, independently from each other.  To express that we wish to run  g()  in parallel to  h()  , we can  fork  the task  g()  -- this means that we tell JVM that it  could 3  execute  g()  at the same time as  h() .    We can then  join  back the task  g() .  The join operation causes our code to wait for  g()  to complete, ensuring that the updated value of  c  is available when  i(c,d)  is called.  This pattern of invoking tasks in parallel is called the fork/join framework.  It typically involves some recursive forking and joining to break down a huge task to many smaller ones (but don't have to).  We will see a more concrete example below.",
            "title": "Fork and Join"
        },
        {
            "location": "/lec10/index.html#the-forkjointaskv-abstract-class",
            "text": "Java provides an abstraction for a task that can be forked and joined, aptly called  ForkJoinTask .  This is an abstract class, which we will not use directly.  The class has many methods, but the two most important ones, which we will use, are  fork()  and  join() .  The method  fork()  submits this task to JVM for execution, possibly parallely.  The method  join()  waits for the computation to complete and returns the value of type  V .",
            "title": "The ForkJoinTask&lt;V&gt; Abstract Class"
        },
        {
            "location": "/lec10/index.html#the-recursivetaskv-abstract-class",
            "text": "A  ForkJoinTask<V>  has a subclass called  RecursiveTask<V> , which is also abstract.  It has a method  V compute() , which we can customize with the task we want for compute.  Here is an example task of how we can use  RecursiveTask<V>   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30    static   class   Summer   extends   RecursiveTask < Integer >   { \n     final   int   FORK_THRESHOLD   =   2 ; \n     int   low ; \n     int   high ; \n     int []   array ; \n\n     Summer ( int   low ,   int   high ,   int []   array )   { \n       this . low   =   low ; \n       this . high   =   high ; \n       this . array   =   array ; \n     } \n\n     @Override \n     protected   Integer   compute ()   { \n       // stop splitting into subtask if array is already small. \n       if   ( high   -   low   <   FORK_THRESHOLD )   { \n         int   sum   =   0 ; \n         for   ( int   i   =   low ;   i   <   high ;   i ++)   { \n           sum   +=   array [ i ]; \n         } \n         return   sum ; \n       }  \n\n       int   middle   =   ( low   +   high )   /   2 ; \n       Summer   left   =   new   Summer ( low ,   middle ,   array ); \n       Summer   right   =   new   Summer ( middle ,   high ,   array ); \n       left . fork (); \n       return   right . compute ()   +   left . join (); \n     } \n   }    To run the task, we call  compute()    1\n2      Summer   task   =   new   Summer ( 0 ,   array . length ,   array ); \n     int   sum   =   task . compute ();     RecursiveAction  Another subclass of  ForkJoinTask  is called  RecursiveAction , which is very similar to  RecursiveTask , except that  RecursiveAction  does not return a value.",
            "title": "The RecursiveTask&lt;V&gt; Abstract Class"
        },
        {
            "location": "/lec10/index.html#thread-pools-and-forkjoin",
            "text": "Internally, Java maintains a pool of  worker threads .  A worker thread is an abstraction for running a task.  We can submit a task to the pool for execution, the task will join a queue.  There is a global queue for a newly submitted task.  There is also a queue for each worker.   A task spawn from another task executed by a worker will join the queue belonging to that worker.    The worker thread can pick a task from the queue to execute.  When it is done, it picks another task, if one exists in the queue, and so on -- not unlike our  Server  (worker thread) and  Customer  (task).  A  ForkJoinPool  is a class the implements a thread pool for  ForkJoinTask .  An alternative way of executing the  sumTask  above is to submit the task to the  ForkJoinPool  instead of calling it directly.  1 int   sum   =   ForkJoinPool . commonPool (). invoke ( task );    The difference between calling  invoke(task)  versus  task.compute()  is huge, even though both returns us the correct result above.  Calling  task.compute()  means that we are invoking the task immediately and directly (just like any method call); Calling  invoke(task) , however, means that we are asking the task to join a queue, waiting to be carried out by a worker, and return us the result.  You can see this effect if we have too many recursive tasks, in which case if we call  task.compute  we will end out with a stack overflow.",
            "title": "Thread Pools and Fork/Join"
        },
        {
            "location": "/lec10/index.html#overhead-of-forkjoin",
            "text": "You can see from the description above that forking and joining actually creates additional overhead -- we first need to wrap the computation in an object, submit the object to a queue of tasks.  There are workers that go through the queue to execute the tasks.  You can try different values of  FORK_TRESHOLD  to look at the effect.  Here is what the result looks like on my iMac:    The smaller the fork threshold, the more tasks we create, and the smaller each task becomes.  As the figure shows, if the task to parallelize is too simple, it is not worth to parallelize it due to the overhead cost.",
            "title": "Overhead of Fork/Join"
        },
        {
            "location": "/lec10/index.html#parallel-stream-using-forkjoin",
            "text": "Parallel streams are implemented using fork/join in Java.  Here,  fork  creates subtasks running the same chain of operations on sub-streams, and when done, run  join  to combine the results (e.g.,  combiner  for  reduce  is run in  join ).   fork  and  join  can be recursive -- for instance, a  fork  operation can split the stream into two subtasks.  The subtasks can further split the sub-streams into four smaller sub-streams, and so on, until the size of the sub-stream is small enough that the task is actually invoked.  In the  isPrime  example earlier, the task is trivial (checking  n % x == 0 ), and so, by parallelizing it, we are actually creating more work for Java to do.  It is much more efficient if we simply check for  n % x == 0  sequentially.  The moral of the story is, parallelization is worthwhile if the task is complex enough that the benefit of parallelization outweighs the overhead.  While we discuss this in the context of parallel streams, this principle holds for all parallel and concurrent programs.",
            "title": "Parallel Stream using Fork/Join"
        },
        {
            "location": "/lec10/index.html#ordered-vs-unordered-source",
            "text": "Whether or not the stream elements are  ordered  or  unordered  also plays a role in the performance of parallel stream operations.  A stream may define an  encounter order .  Streams created from  iterate , ordered collections (e.g.,  List  or arrays), from  of , are ordered.  Stream created from  generate  or unordered collections (e.g.,  Set ) are unordered.  Some stream operations respect the encounter order.  For instance, both  distinct  and  sorted  preserve the original order of elements (if ordering is preserved, we say that an operation is  stable ).  The parallel version of  findFirst ,  limit , and  skip  can be expensive on ordered stream, since it needs to coordinate between the streams to maintain the order.    If we have an ordered stream and respecting the original order is not important, we can call  unordered()  as part of the chain command to make the parallel operations much more efficient.  The following, for example, takes about 700 ms on my iMac:  1\n2\n3\n4\n5      Stream . iterate ( 0 ,   i   ->   i   +   7 ) \n         . parallel () \n         . limit ( 10_000_000 ) \n         . filter ( i   ->   i   %   64   ==   0 ) \n         . forEachOrdered ( i   ->   {   });    But, with  unordered()  inserted, it takes about 350ms, a 2x speed up!  1\n2\n3\n4\n5\n6      Stream . iterate ( 0 ,   i   ->   i   +   7 ) \n         . parallel () \n         . unordered () \n         . limit ( 10_000_000 ) \n         . filter ( i   ->   i   %   64   ==   0 ) \n         . forEachOrdered ( i   ->   {   });",
            "title": "Ordered vs. Unordered Source"
        },
        {
            "location": "/lec10/index.html#exercise",
            "text": "The last two lines of  compute  of  Summer  class, which says:  1\n2      left . fork (); \n     return   right . compute ()   +   left . join ();    What would happen if we change these two lines to the following:  (a).  1      return   right . compute ()   +   left . compute ();    (b).  1\n2\n3      right . fork (); \n     left . fork (); \n     return   right . join ()   +   left . join ();    (c )  1\n2      right . fork (); \n     return   right . join ()   +   left . compute ();      What is the value of the variable  x  after executing the following statement? \n     1 Stream . of ( 1 , 2 , 3 , 4 ). reduce ( 0 ,   ( result ,   x )   ->   result   *   2   +   x );    After we parallelized the above code into the following, we found the output is different.  Why?  1 Stream . of ( 1 , 2 , 3 , 4 ). parallel (). reduce ( 0 ,   ( result ,   x )   ->   result   *   2   +   x );      Take the standard implementation of merge sort (e.g., from CS2040) and parallelize it with fork and join.        iPhone X comes with A11 Bionic chip with six cores.  The fastest supercomputer in the world as of this writing, the Sunway TaihuLight (\u795e\u5a01 \u592a\u6e56\u4e4b\u5149), has 40,960 processors, each with 256 cores, giving a total of 10,485,760 cores.\u00a0 \u21a9    This is a more efficient version of the code you have seen, since it stops testing after the square root of the  n n .\u00a0 \u21a9    The operating systems and JVM can decide this depends on how many cores or processors are available and how many tasks are pending.  But these details are hidden from us so we do not need to worry about them unless we want to squeeze some performance out of this -- in which case you should to take CS2106 and CS3210.\u00a0 \u21a9",
            "title": "Exercise"
        },
        {
            "location": "/lec11/index.html",
            "text": "Learning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nfamiliar with the concept of asynchronous method calls and be able to use it effectively\n\n\nfamiliar with the concept of promise through Java 8 \nCompletableFuture\n class\n\n\n\n\nSynchronous vs. Asynchronous\n\n\nIn synchronous programming, when we call a method, we expect the method to be executed, and when the method returns, the result of the method is available.\n\n\n1\n2\n3\n4\n5\nint\n \nmultiply\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n    \nreturn\n \nx\n \n*\n \ny\n;\n\n\n}\n\n\n\nint\n \nz\n \n=\n \nmultiply\n(\n3\n,\n \n4\n);\n\n\n\n\n\n\n\nIn the simple example above, our code continues executing after, and only after \nmultiply()\n completes.\n\n\nIf a method takes a long time to run, however, the execution will delay the execution of subsequent methods, and maybe undesirable.\n\n\nAsynchronous call to a method allows execution to continue immediately after calling the method, so that we can continue executing the rest of our code, while the long-running method is off doing its job.\n\n\nYou have seen examples of asynchronous calls: \n\n\n1\n2\n    \ntask\n \n=\n \nnew\n \nMatrixMultiplyerTask\n(\nm1\n,\n \nm2\n);\n\n    \ntask\n.\nfork\n();\n\n\n\n\n\n\n\nThe call above returns immediately even before the matrix multiplication is complete.  We can later return to this task, and call \ntask.join()\n to get the result (waiting for it if necessary).  \n\n\nA \nRecursiveTask\n also has a \nisDone()\n method that it implements as part of the \nFuture\n interface.  Now, we can do something like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n    \ntask\n \n=\n \nnew\n \nMatrixMultiplyerTask\n(\nm1\n,\n \nm2\n);\n\n    \ntask\n.\nfork\n();\n\n    \nwhile\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n        \nSystem\n.\nout\n.\nprint\n(\n\".\"\n);\n\n        \nThread\n.\nsleep\n(\n1000\n);\n\n    \n}\n\n    \nSystem\n.\nout\n.\nprint\n(\n\"done\"\n);\n\n\n\n\n\n\n\nSo, while the task is running, we can print out a series of \".\"s to feedback to the users to indicate that it is running.\n\n\nThread.sleep(1000)\n cause the current running thread to sleep for 1s.  It might throw an \nInterruptedException\n, if the user interrupts the program (by Control-C).  To complete the snippet, we should catch the exception and cancel the task. \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n    \ntask\n \n=\n \nnew\n \nMatrixMultiplyerTask\n(\nm1\n,\n \nm2\n);\n\n    \ntask\n.\nfork\n();\n\n    \ntry\n \n{\n\n        \nwhile\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n            \nSystem\n.\nout\n.\nprint\n(\n\".\"\n);\n\n            \nThread\n.\nsleep\n(\n1000\n);\n\n        \n}\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\"done\"\n);\n\n    \n}\n \ncatch\n \n(\nInterruptedException\n \ne\n)\n \n{\n\n        \ntask\n.\ncancel\n();\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\"cancelled\"\n);\n\n    \n}\n\n\n\n\n\n\n\nFuture\n\n\nLet's look at the \nFuture\n interface a bit more.  \nFuture<T>\n represents the result (of type \nT\n) of an asynchronous task that may not be available yet.  It has five simple operations:\n\n\n\n\nget()\n returns the result of the computation (waiting for it if needed).\n\n\nget(timeout, unit)\n returns the result of the computation (waiting for up to the timeout period if needed).\n\n\ncancel(interrupt)\n tries to cancel the task -- if \ninterrupt\n is true, cancel even if the task has started.  Otherwise, cancel only if the task is still waiting to get started.\n\n\nisCancelled()\n returns \ntrue\n of the task has been cancelled.\n\n\nisDone()\n returns \ntrue\n if the task has been completed.\n\n\n\n\nBoth \nRecursiveTask\n and \nRecursiveAction\n implements the \nFuture\n interface, so you can use the above methods on your tasks.\n\n\n\n\nIn Other Languages\n\n\nScala's \nFuture\n is more powerful -- it allows us to specify what to do when the task completes, and it hands abnormal completions (e.g., exceptions). \n    Python 3.2 supports \nFuture\n through \nconcurrent.futures\n module.  C++11 supports \nstd::future\n](\nhttp://en.cppreference.com/w/cpp/thread/future\n) as well.\n\n\n\n\nCompletableFuture\n\n\nThe example code above tries every second to see if task is done.  For some applications, the response time is critical, and we would like to know as soon as a task is done.  For instance, response time is important in stock trading applications and web services.  \n\n\nOne way to do so, is to sleep for a shorter duration.  Or even not sleeping all together:\n\n\n1\n2\n3\n4\n5\n    \ntask\n.\nfork\n();\n\n    \nwhile\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n        \nSystem\n.\nout\n.\nprint\n(\n\".\"\n);\n\n    \n}\n\n    \nSystem\n.\nout\n.\nprint\n(\n\"done\"\n);\n\n\n\n\n\n\n\nThis is problematic in many ways, besides printing out too many dots:\n\n\n\n\nthis is known as \nbusy waiting\n -- and it occupies the CPU while doing nothing.  Such code should be avoided at all cost. \n\n\nwe may want to continue doing other things besides printing out \".\"s, so the code won't be a simple for loop anymore.  We can do something like this instead:\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n    \ntask\n.\nfork\n();\n\n    \nif\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n        \n// do something\n\n    \n}\n \nelse\n \n{\n\n        \ntask\n.\njoin\n();\n\n    \n}\n\n    \nif\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n        \n// do something else\n\n    \n}\n \nelse\n \n{\n\n        \ntask\n.\njoin\n();\n\n    \n}\n\n    \nif\n \n(!\ntask\n.\nisDone\n())\n \n{\n\n        \n// do yet something else\n\n    \n}\n \nelse\n \n{\n\n        \ntask\n.\njoin\n();\n\n    \n}\n\n\n\n\n\n\n\nYou can see that the code gets out of hand quickly, and this is only if we have one asynchronous call!\n\n\nWhat we need is have a way to specify a \ncallback\n.  A callback is basically a method that will be executed when a certain event happens.  In this case, we need to specify a callback when an asynchronous task is complete.  This way, we can just call an asynchronous task, specify what to do when the task is completed, and forget about it.  We do not need to check again and again if the task is done.\n\n\nTo do exactly this, Java 8 introduces the class \nCompletableFuture<V>\n, which implements the \nFuture<V>\n interface.  Thus, just like \nFuture<V>\n, a \nCompletableFuture<V>\n object returns a value of type \nV\n when it completes.  But \nCompletableFuture<V>\n is more powerful, it allows us to specify an asynchronous task, and an action to perform when the task completes.\n\n\nThe notion of \"complete\" is important for \nCompletableFuture\n.  If the \nCompletableFuture\n is complete, then the value to return is available.  We can create an already-completed \nCompletableFuture\n, passing in a value, or a yet-to-be-completed \nCompletableFuture\n, by passing in a function to be executed asynchronously.  When this function returns, the \nCompletableFuture\n completes.\n\n\nTo create a \nCompletableFuture\n object, we can call one of its static method.  For instance, \nsupplyAsync\n takes in a \nSupplier\n:\n\n\n1\nCompletableFuture\n<\nMatrix\n>\n \nfuture\n \n=\n \nCompletableFuture\n.\nsupplyAsync\n(()\n \n->\n \nm1\n.\nmultiply\n(\nm2\n));\n\n\n\n\n\n\n\nAs explained above, \nfuture\n completes when \nm1.multiply(m2)\n returns.\n\nLet's say that we want to print out the result with a \nConsumer\n when \nfuture\n completes, we can use the \nthenAccept\n method:\n\n\n1\nfuture\n.\nthenAccept\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nOr, you can use the oneliner:\n\n\n1\n2\n3\nCompletableFuture\n\n    \n.\nsupplyAsync\n(()\n \n->\n \nm1\n.\nmultiply\n(\nm2\n))\n\n    \n.\nthenAccept\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nWaiting for Completion\n\n\nIf you want your code to block until a \nCompletableFuture\n completes, you can call \njoin()\n.  \n\n\n1\nm\n \n=\n \nfuture\n.\njoin\n();\n\n\n\n\n\n\n\nSuppose you have several \nCompletableFuture\n objects, say \ncf1\n, \ncf2\n, and \ncf3\n, and you want to block until all of these \nCompletableFuture\n completes.  You can create a composite \nCompletableFuture\n objects, using \nallOf()\n:\n\n\n1\nCompletableFuture\n.\nallOf\n(\ncf1\n,\n \ncf2\n,\n \ncf3\n).\njoin\n();\n\n\n\n\n\n\n\nThe object created by \nCompletableFuture.allOf(cf1, cf2, cf3)\n completes, only after all of \ncf1\n, \ncf2\n, \ncf3\n completes.\n\n\nThere is also a \nanyOf\n, for cases where it is sufficient for any one of the \nCompletableFuture\n to complete:\n\n1\nCompletableFuture\n.\nanyOf\n(\ncf1\n,\n \ncf2\n,\n \ncf3\n).\njoin\n();\n\n\n\n\n\n\nCompletableFuture is a Functor / Monad\n\n\nCompletableFuture\n is a functor.  Recall that a functor, in OO-speak, is a class that implements a (hypothetical) interface that looks like the following:\n\n\n1\n2\n3\ninterface\n \nFunctor\n<\nT\n>\n \n{\n\n  \npublic\n \n<\nR\n>\n \nFunctor\n<\nR\n>\n \nf\n(\nFunction\n<\nT\n,\nR\n>\n \nfunc\n);\n\n\n}\n\n\n\n\n\n\n\nIn \nCompletableFuture\n, the method that makes \nCompletableFuture\n a functor is the \nthenApply\n method:\n\n\n1\n<\nU\n>\n \nCompletableFuture\n<\nU\n>\n \nthenApply\n(\nFunction\n<?\n \nsuper\n \nT\n,\n?\n \nextends\n \nU\n>\n \nfunc\n)\n\n\n\n\n\n\n\nThe method \nthenApply\n is similar to \nthenAccept\n, except that instead of a \nConsumer\n, the callback that gets invoked when the asynchronous task completes is a `Function.  \n\n\nThere are other variations: \n\n\n\n\nthenRun\n, which takes a \nRunnable\n, \n\n\nthenAcceptBoth\n, which takes a \nBiConsumer\n and another \nCompletableFuture\n\n\nthenCombine\n, which takes a \nBiFunction\n and another \nCompletableFuture\n \n\n\nthenCompose\n, which takes in a \nFunction\n \nfn\n, which instead of returning a \"plain\" type, \nfn\n returns a \nCompletableFuture\n. \n\n\n\n\nAll the methods above return a \nCompletableFuture\n.\n\n\nBTW, \nCompletableFuture\n is a monad too!  The \nthenCompose\n method is analougous to the \nflatMap\n method of \nStream\n and \nOptional\n. \n\n\nThis also means that \nCompletableFuture\n satisfies the monad laws, one of which is that there is a method to wrap a value around with a \nCompletableFuture\n.  We call this the \nof\n method in the context of \nStream\n and \nOptional\n, but in \nCompletableFuture\n, it is called \ncompletedFuture\n.  This method creates a \nCompletableFuture\n that is completed.\nThe \ncompletedFuture\n method is useful, for instance, if we want to convert a method below to asynchronous.\n\n1\n2\n3\n4\n5\n6\nInteger\n \nfoo\n(\nint\n \nx\n)\n \n{\n\n  \nif\n \n(\nx\n \n<\n \n0\n)\n \n    \nreturn\n \n0\n;\n\n  \nelse\n\n    \nreturn\n \ndoSomething\n(\nx\n);\n\n\n}\n\n\n\n\n\n\nWith \nCompletableFuture\n, it becomes:\n\n1\n2\n3\n4\n5\nCompletableFuture\n<\nInteger\n>\n \nfooAsync\n(\nint\n \nx\n)\n \n{\n\n  \nif\n \n(\nx\n \n<\n \n0\n)\n \n    \nreturn\n \nCompletableFuture\n.\ncompletedFuture\n(\n0\n);\n\n  \nelse\n \n    \nreturn\n \nCompletableFuture\n.\nsupplyAsync\n(()\n \n->\n \ndoSomething\n(\nx\n));\n\n\n\n\n\n\n\n\nExtra Example\n\n\nIn the class, I got carried away with the question about \ncompletedFuture\n and added the following example for \nflatMap\n \nthenCompose\n as well:\n\n\nOriginal non-async version:\n\n1\n2\nint\n \nx\n \n=\n \nbar\n(\nz\n)\n\n\nint\n \ny\n \n=\n \nfoo\n(\nx\n)\n\n\n\n\n\n\nAsync version:\n\n1\n2\n3\ny\n \n=\n \nbarAsync\n(\nz\n)\n\n       \n.\nthenCompose\n(\ni\n \n->\n \nfooAsync\n(\ni\n))\n\n       \n.\nget\n();\n\n\n\n\n\n\n\n\nWhen we discussed about monad, we say that one way to think of a monad as a wrapper of a value in some context.  In the case of \nOptional\n, the context is that the value may or may not be there.  In the context of \nCompletableFuture\n, the context is that the value not be available yet.\n\n\nBeing a functor and a monad, \nCompletableFuture\n objects can be chained together, just like \nStream\n and \nOptional\n.  We can write code like this:\n\n\n1\n2\n3\n4\n5\n6\nCompletableFuture\n\n    \n.\ncompletedFuture\n(\nMatrix\n.\ngenerate\n(\nnRows\n,\n \nnCols\n,\n \nrng\n::\nnextDouble\n))\n\n    \n.\nthenApply\n(\nm\n \n->\n \nm\n.\nmultiply\n(\nm1\n))\n\n    \n.\nthenApply\n(\nm\n \n->\n \nm\n.\nadd\n(\nm2\n))\n\n    \n.\nthenApply\n(\nm\n \n->\n \nm\n.\ntranspose\n)\n\n    \n.\nthenAccept\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nAnother example:\n\n\n1\n2\n3\n4\n5\n6\nCompletableFuture\n \nleft\n \n=\n \nCompletableFuture\n\n    \n.\nsupplyAsync\n(()\n \n->\n \na1\n.\nmultiply\n(\nb1\n));\n\n\nCompletableFuture\n \nright\n \n=\n \nCompletableFuture\n\n    \n.\nsupplyAsync\n(()\n \n->\n \na2\n.\nmultiply\n(\nb2\n))\n\n    \n.\nthenCombine\n(\nleft\n,\n \n(\nm1\n,\n \nm2\n)\n \n->\n \nm1\n.\nadd\n(\nm2\n));\n\n    \n.\nthenAccept\n(\nSystem\n.\nout\n::\nprintln\n);\n\n\n\n\n\n\n\nSimilar to \nStream\n, some of the methods are terminal (e.g., \nthenRun\n, \nthenAccept\n), and some are intermediate (\nthenApply\n).\n\n\nVariations\n\n\n\n\n\n\nThere are variations of methods with name containing the word \nEither\n or \nBoth\n, taking in another \nCompletableFuture\n.  These methods invoke the given \nFunction\n/\nRunnable\n/\nConsumer\n when either one (for \nEither\n) or both (for \nBoth\n) of the \nCompletableFuture\n completes.\n\n\n\n\n\n\nThere are variations of methods with name ending with the word \nAsync\n.  These methods are called asynchronously in another thread\n\n\n\n\n\n\nFor example, \nrunAfterBothAsync(future, task)\n would run \ntask\n only after \nthis\n and given \nfuture\n is completed.\n\n\nOther features of \nCompletableFuture\n include:\n\n\n\n\n\n\nSome methods take in additional \nExecutor\n parameter, for cases where running in the default \nForkJoinPool\n is not good enough.\n\n\n\n\n\n\nSome methods takes in additional \nThrowable\n parameter, for cases where earlier calls might throw an exception.\n\n\n\n\n\n\nHandling Exceptions\n\n\nHandling exceptions is non-trivial for asynchronous methods.  Remember that, in synchronous method calls, the exceptions are repeatedly thrown to the caller up the call stack, until someone catches the exception.  For asynchronous calls, it is not so obvious.  For instance, should we put a catch around \nfork()\n or around \njoin()\n?  A \nForkJoinTask\n doesn't handle exception with catch, but instead requires us to check for \nisCompletedAbnormally\n and then call \ngetException\n to get the exception thrown.\n\n\nAs \nCompletableFuture\n allows chaining, it provides a cleaner way to pass exceptions from one call to the next.  The terminal operation \nwhenComplete\n takes in a \nBiConsumer\n as parameter -- the first argument to the \nBiConsumer\n is the result from previous chain (or \nnull\n if exception thrown); the second argument is an exception (null if completes normally).\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nCompletableFuture\n\n    \n.\ncompletedFuture\n(\nMatrix\n.\ngenerate\n(\nnRows\n,\n \nnCols\n,\n \nrng\n::\nnextDouble\n))\n\n    \n.\nthenApply\n(\nm\n \n->\n \nm\n.\nmultiply\n(\nm\n))\n\n    \n.\nwhenComplete\n((\nresult\n,\n \nexception\n)\n \n->\n \n{\n\n        \nif\n \n(\nexception\n)\n \n{\n \n            \nSystem\n.\nerr\n.\nprintln\n(\nexception\n);\n\n        \n}\n \nelse\n \n{\n\n            \nSystem\n.\nout\n.\nprint\n(\nresult\n);\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nwhenComplete\n returns a CompletableFuture, surprisingly, despite it taking in a \nBiConsumer\n -- in a sense, \nwhenComplete\n is more similar to \npeek\n rather than \nforEach\n.\n\n\nhandle\n is similar to \nwhenComplete\n, but takes in a \nBiFunction\n instead of a \nBiConsumer\n, thus allowing the result or exception to be transformed. \n\n\nFinally, \nexceptionally\n handles exception by replacing a thrown exception with a value, similar to \norElse\n in \nOptional\n.\n\n\n1\n2\n3\n4\nCompletableFuture\n\n    \n.\ncompletedFuture\n(\nMatrix\n.\ngenerate\n(\nnRows\n,\n \nnCols\n,\n \nrng\n::\nnextDouble\n))\n\n    \n.\nthenApply\n(\nm\n \n->\n \nm\n.\nmultiply\n(\nm\n))\n\n    \n.\nexceptionally\n(\nex\n \n->\n \nMatrix\n.\ngenerate\n(\nnRows\n,\n \nnCols\n,\n \n()\n \n->\n \n0\n));\n\n\n\n\n\n\n\n\n\nPromise\n\n\nCompletableFuture\n is similar to \nPromise\n in other languages, notably JavaScript and C++ (\nstd::promise\n).\n\n\n\n\n\n\nCompletionStage\n\n\nIn Java, \nCompletableFuture\n also implements a \nCompletionStage\n interface.  Thus, you will find references to this interface in many places in the Java documentation.  I find this name unintuitive and makes an already-confusing java documentation even harder to read.\n\n\n\n\nExercise\n\n\n\n\n\n\nChange the following sequence of code so that \nf()\n, \ng()\n and \nh()\n are invoked asynchronously, using \nCompletableFuture\n.\n\n\n(i)\n\n1\n2\n3\nB\n \nb\n \n=\n \nf\n(\na\n);\n\n\nC\n \nc\n \n=\n \ng\n(\nb\n);\n\n\nD\n \nd\n \n=\n \nh\n(\nc\n);\n\n\n\n\n\n\n(ii)\n\n1\n2\n3\nB\n \nb\n \n=\n \nf\n();\n\n\nC\n \nc\n \n=\n \ng\n(\nb\n);\n\n\nh\n(\nc\n);\n \n// no return value\n\n\n\n\n\n\n(iii)\n\n1\n2\n3\n4\nB\n \nb\n \n=\n \nf\n(\na\n);\n\n\nC\n \nc\n \n=\n \ng\n(\nb\n);\n\n\nD\n \nd\n \n=\n \nh\n(\nb\n);\n\n\nE\n \ne\n \n=\n \ni\n(\nc\n,\n \nd\n);",
            "title": "11. Asynchronous"
        },
        {
            "location": "/lec11/index.html#learning-objectives",
            "text": "After this lecture, students should:   familiar with the concept of asynchronous method calls and be able to use it effectively  familiar with the concept of promise through Java 8  CompletableFuture  class",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec11/index.html#synchronous-vs-asynchronous",
            "text": "In synchronous programming, when we call a method, we expect the method to be executed, and when the method returns, the result of the method is available.  1\n2\n3\n4\n5 int   multiply ( int   x ,   int   y )   { \n     return   x   *   y ;  }  int   z   =   multiply ( 3 ,   4 );    In the simple example above, our code continues executing after, and only after  multiply()  completes.  If a method takes a long time to run, however, the execution will delay the execution of subsequent methods, and maybe undesirable.  Asynchronous call to a method allows execution to continue immediately after calling the method, so that we can continue executing the rest of our code, while the long-running method is off doing its job.  You have seen examples of asynchronous calls:   1\n2      task   =   new   MatrixMultiplyerTask ( m1 ,   m2 ); \n     task . fork ();    The call above returns immediately even before the matrix multiplication is complete.  We can later return to this task, and call  task.join()  to get the result (waiting for it if necessary).    A  RecursiveTask  also has a  isDone()  method that it implements as part of the  Future  interface.  Now, we can do something like this:  1\n2\n3\n4\n5\n6\n7      task   =   new   MatrixMultiplyerTask ( m1 ,   m2 ); \n     task . fork (); \n     while   (! task . isDone ())   { \n         System . out . print ( \".\" ); \n         Thread . sleep ( 1000 ); \n     } \n     System . out . print ( \"done\" );    So, while the task is running, we can print out a series of \".\"s to feedback to the users to indicate that it is running.  Thread.sleep(1000)  cause the current running thread to sleep for 1s.  It might throw an  InterruptedException , if the user interrupts the program (by Control-C).  To complete the snippet, we should catch the exception and cancel the task.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12      task   =   new   MatrixMultiplyerTask ( m1 ,   m2 ); \n     task . fork (); \n     try   { \n         while   (! task . isDone ())   { \n             System . out . print ( \".\" ); \n             Thread . sleep ( 1000 ); \n         } \n         System . out . println ( \"done\" ); \n     }   catch   ( InterruptedException   e )   { \n         task . cancel (); \n         System . out . println ( \"cancelled\" ); \n     }",
            "title": "Synchronous vs. Asynchronous"
        },
        {
            "location": "/lec11/index.html#future",
            "text": "Let's look at the  Future  interface a bit more.   Future<T>  represents the result (of type  T ) of an asynchronous task that may not be available yet.  It has five simple operations:   get()  returns the result of the computation (waiting for it if needed).  get(timeout, unit)  returns the result of the computation (waiting for up to the timeout period if needed).  cancel(interrupt)  tries to cancel the task -- if  interrupt  is true, cancel even if the task has started.  Otherwise, cancel only if the task is still waiting to get started.  isCancelled()  returns  true  of the task has been cancelled.  isDone()  returns  true  if the task has been completed.   Both  RecursiveTask  and  RecursiveAction  implements the  Future  interface, so you can use the above methods on your tasks.   In Other Languages  Scala's  Future  is more powerful -- it allows us to specify what to do when the task completes, and it hands abnormal completions (e.g., exceptions). \n    Python 3.2 supports  Future  through  concurrent.futures  module.  C++11 supports  std::future ]( http://en.cppreference.com/w/cpp/thread/future ) as well.",
            "title": "Future"
        },
        {
            "location": "/lec11/index.html#completablefuture",
            "text": "The example code above tries every second to see if task is done.  For some applications, the response time is critical, and we would like to know as soon as a task is done.  For instance, response time is important in stock trading applications and web services.    One way to do so, is to sleep for a shorter duration.  Or even not sleeping all together:  1\n2\n3\n4\n5      task . fork (); \n     while   (! task . isDone ())   { \n         System . out . print ( \".\" ); \n     } \n     System . out . print ( \"done\" );    This is problematic in many ways, besides printing out too many dots:   this is known as  busy waiting  -- and it occupies the CPU while doing nothing.  Such code should be avoided at all cost.   we may want to continue doing other things besides printing out \".\"s, so the code won't be a simple for loop anymore.  We can do something like this instead:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16      task . fork (); \n     if   (! task . isDone ())   { \n         // do something \n     }   else   { \n         task . join (); \n     } \n     if   (! task . isDone ())   { \n         // do something else \n     }   else   { \n         task . join (); \n     } \n     if   (! task . isDone ())   { \n         // do yet something else \n     }   else   { \n         task . join (); \n     }    You can see that the code gets out of hand quickly, and this is only if we have one asynchronous call!  What we need is have a way to specify a  callback .  A callback is basically a method that will be executed when a certain event happens.  In this case, we need to specify a callback when an asynchronous task is complete.  This way, we can just call an asynchronous task, specify what to do when the task is completed, and forget about it.  We do not need to check again and again if the task is done.  To do exactly this, Java 8 introduces the class  CompletableFuture<V> , which implements the  Future<V>  interface.  Thus, just like  Future<V> , a  CompletableFuture<V>  object returns a value of type  V  when it completes.  But  CompletableFuture<V>  is more powerful, it allows us to specify an asynchronous task, and an action to perform when the task completes.  The notion of \"complete\" is important for  CompletableFuture .  If the  CompletableFuture  is complete, then the value to return is available.  We can create an already-completed  CompletableFuture , passing in a value, or a yet-to-be-completed  CompletableFuture , by passing in a function to be executed asynchronously.  When this function returns, the  CompletableFuture  completes.  To create a  CompletableFuture  object, we can call one of its static method.  For instance,  supplyAsync  takes in a  Supplier :  1 CompletableFuture < Matrix >   future   =   CompletableFuture . supplyAsync (()   ->   m1 . multiply ( m2 ));    As explained above,  future  completes when  m1.multiply(m2)  returns. \nLet's say that we want to print out the result with a  Consumer  when  future  completes, we can use the  thenAccept  method:  1 future . thenAccept ( System . out :: println );    Or, you can use the oneliner:  1\n2\n3 CompletableFuture \n     . supplyAsync (()   ->   m1 . multiply ( m2 )) \n     . thenAccept ( System . out :: println );",
            "title": "CompletableFuture"
        },
        {
            "location": "/lec11/index.html#waiting-for-completion",
            "text": "If you want your code to block until a  CompletableFuture  completes, you can call  join() .    1 m   =   future . join ();    Suppose you have several  CompletableFuture  objects, say  cf1 ,  cf2 , and  cf3 , and you want to block until all of these  CompletableFuture  completes.  You can create a composite  CompletableFuture  objects, using  allOf() :  1 CompletableFuture . allOf ( cf1 ,   cf2 ,   cf3 ). join ();    The object created by  CompletableFuture.allOf(cf1, cf2, cf3)  completes, only after all of  cf1 ,  cf2 ,  cf3  completes.  There is also a  anyOf , for cases where it is sufficient for any one of the  CompletableFuture  to complete: 1 CompletableFuture . anyOf ( cf1 ,   cf2 ,   cf3 ). join ();",
            "title": "Waiting for Completion"
        },
        {
            "location": "/lec11/index.html#completablefuture-is-a-functor-monad",
            "text": "CompletableFuture  is a functor.  Recall that a functor, in OO-speak, is a class that implements a (hypothetical) interface that looks like the following:  1\n2\n3 interface   Functor < T >   { \n   public   < R >   Functor < R >   f ( Function < T , R >   func );  }    In  CompletableFuture , the method that makes  CompletableFuture  a functor is the  thenApply  method:  1 < U >   CompletableFuture < U >   thenApply ( Function <?   super   T , ?   extends   U >   func )    The method  thenApply  is similar to  thenAccept , except that instead of a  Consumer , the callback that gets invoked when the asynchronous task completes is a `Function.    There are other variations:    thenRun , which takes a  Runnable ,   thenAcceptBoth , which takes a  BiConsumer  and another  CompletableFuture  thenCombine , which takes a  BiFunction  and another  CompletableFuture    thenCompose , which takes in a  Function   fn , which instead of returning a \"plain\" type,  fn  returns a  CompletableFuture .    All the methods above return a  CompletableFuture .  BTW,  CompletableFuture  is a monad too!  The  thenCompose  method is analougous to the  flatMap  method of  Stream  and  Optional .   This also means that  CompletableFuture  satisfies the monad laws, one of which is that there is a method to wrap a value around with a  CompletableFuture .  We call this the  of  method in the context of  Stream  and  Optional , but in  CompletableFuture , it is called  completedFuture .  This method creates a  CompletableFuture  that is completed.\nThe  completedFuture  method is useful, for instance, if we want to convert a method below to asynchronous. 1\n2\n3\n4\n5\n6 Integer   foo ( int   x )   { \n   if   ( x   <   0 )  \n     return   0 ; \n   else \n     return   doSomething ( x );  }    With  CompletableFuture , it becomes: 1\n2\n3\n4\n5 CompletableFuture < Integer >   fooAsync ( int   x )   { \n   if   ( x   <   0 )  \n     return   CompletableFuture . completedFuture ( 0 ); \n   else  \n     return   CompletableFuture . supplyAsync (()   ->   doSomething ( x ));     Extra Example  In the class, I got carried away with the question about  completedFuture  and added the following example for  flatMap   thenCompose  as well:  Original non-async version: 1\n2 int   x   =   bar ( z )  int   y   =   foo ( x )    Async version: 1\n2\n3 y   =   barAsync ( z ) \n        . thenCompose ( i   ->   fooAsync ( i )) \n        . get ();     When we discussed about monad, we say that one way to think of a monad as a wrapper of a value in some context.  In the case of  Optional , the context is that the value may or may not be there.  In the context of  CompletableFuture , the context is that the value not be available yet.  Being a functor and a monad,  CompletableFuture  objects can be chained together, just like  Stream  and  Optional .  We can write code like this:  1\n2\n3\n4\n5\n6 CompletableFuture \n     . completedFuture ( Matrix . generate ( nRows ,   nCols ,   rng :: nextDouble )) \n     . thenApply ( m   ->   m . multiply ( m1 )) \n     . thenApply ( m   ->   m . add ( m2 )) \n     . thenApply ( m   ->   m . transpose ) \n     . thenAccept ( System . out :: println );    Another example:  1\n2\n3\n4\n5\n6 CompletableFuture   left   =   CompletableFuture \n     . supplyAsync (()   ->   a1 . multiply ( b1 ));  CompletableFuture   right   =   CompletableFuture \n     . supplyAsync (()   ->   a2 . multiply ( b2 )) \n     . thenCombine ( left ,   ( m1 ,   m2 )   ->   m1 . add ( m2 )); \n     . thenAccept ( System . out :: println );    Similar to  Stream , some of the methods are terminal (e.g.,  thenRun ,  thenAccept ), and some are intermediate ( thenApply ).",
            "title": "CompletableFuture is a Functor / Monad"
        },
        {
            "location": "/lec11/index.html#variations",
            "text": "There are variations of methods with name containing the word  Either  or  Both , taking in another  CompletableFuture .  These methods invoke the given  Function / Runnable / Consumer  when either one (for  Either ) or both (for  Both ) of the  CompletableFuture  completes.    There are variations of methods with name ending with the word  Async .  These methods are called asynchronously in another thread    For example,  runAfterBothAsync(future, task)  would run  task  only after  this  and given  future  is completed.  Other features of  CompletableFuture  include:    Some methods take in additional  Executor  parameter, for cases where running in the default  ForkJoinPool  is not good enough.    Some methods takes in additional  Throwable  parameter, for cases where earlier calls might throw an exception.",
            "title": "Variations"
        },
        {
            "location": "/lec11/index.html#handling-exceptions",
            "text": "Handling exceptions is non-trivial for asynchronous methods.  Remember that, in synchronous method calls, the exceptions are repeatedly thrown to the caller up the call stack, until someone catches the exception.  For asynchronous calls, it is not so obvious.  For instance, should we put a catch around  fork()  or around  join() ?  A  ForkJoinTask  doesn't handle exception with catch, but instead requires us to check for  isCompletedAbnormally  and then call  getException  to get the exception thrown.  As  CompletableFuture  allows chaining, it provides a cleaner way to pass exceptions from one call to the next.  The terminal operation  whenComplete  takes in a  BiConsumer  as parameter -- the first argument to the  BiConsumer  is the result from previous chain (or  null  if exception thrown); the second argument is an exception (null if completes normally).   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 CompletableFuture \n     . completedFuture ( Matrix . generate ( nRows ,   nCols ,   rng :: nextDouble )) \n     . thenApply ( m   ->   m . multiply ( m )) \n     . whenComplete (( result ,   exception )   ->   { \n         if   ( exception )   {  \n             System . err . println ( exception ); \n         }   else   { \n             System . out . print ( result ); \n         } \n     }    whenComplete  returns a CompletableFuture, surprisingly, despite it taking in a  BiConsumer  -- in a sense,  whenComplete  is more similar to  peek  rather than  forEach .  handle  is similar to  whenComplete , but takes in a  BiFunction  instead of a  BiConsumer , thus allowing the result or exception to be transformed.   Finally,  exceptionally  handles exception by replacing a thrown exception with a value, similar to  orElse  in  Optional .  1\n2\n3\n4 CompletableFuture \n     . completedFuture ( Matrix . generate ( nRows ,   nCols ,   rng :: nextDouble )) \n     . thenApply ( m   ->   m . multiply ( m )) \n     . exceptionally ( ex   ->   Matrix . generate ( nRows ,   nCols ,   ()   ->   0 ));     Promise  CompletableFuture  is similar to  Promise  in other languages, notably JavaScript and C++ ( std::promise ).    CompletionStage  In Java,  CompletableFuture  also implements a  CompletionStage  interface.  Thus, you will find references to this interface in many places in the Java documentation.  I find this name unintuitive and makes an already-confusing java documentation even harder to read.",
            "title": "Handling Exceptions"
        },
        {
            "location": "/lec11/index.html#exercise",
            "text": "Change the following sequence of code so that  f() ,  g()  and  h()  are invoked asynchronously, using  CompletableFuture .  (i) 1\n2\n3 B   b   =   f ( a );  C   c   =   g ( b );  D   d   =   h ( c );    (ii) 1\n2\n3 B   b   =   f ();  C   c   =   g ( b );  h ( c );   // no return value    (iii) 1\n2\n3\n4 B   b   =   f ( a );  C   c   =   g ( b );  D   d   =   h ( b );  E   e   =   i ( c ,   d );",
            "title": "Exercise"
        },
        {
            "location": "/monad/index.html",
            "text": "Extra: Do You Want to Build a Monad?\n\n\nThis article is inspired by (The Best Introduction to Monad)[\nhttps://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/#\n], but is adapted to the OO-context with Java.\n\n\nLet's say we have:\n\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n \nsin\n(\ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \nMath\n.\nsin\n(\nx\n);\n\n\n}\n\n\n\ndouble\n \ncube\n(\ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \nx\n*\nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nWe can easily chain the methods together:\n\n\n1\n2\nsin\n(\ncube\n(\n5.0\n));\n\n\ncube\n(\nsin\n(\n5.0\n));\n\n\n\n\n\n\n\nBut, what if we need to print something while doing this operation?\n\n\nWe can easily do:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ndouble\n \nsin\n(\ndouble\n \nx\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\n\"called sin\"\n);\n\n  \nreturn\n \nMath\n.\nsin\n(\nx\n);\n\n\n}\n\n\n\ndouble\n \ncube\n(\ndouble\n \nx\n)\n \n{\n\n  \nSystem\n.\nout\n.\nprintln\n(\n\"called cubed\"\n);\n\n  \nreturn\n \nx\n*\nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nBut that has side effects, so it violates the spirit of functional programming.\nWe should concat the logs into a string (just like what you did in Lab 4).  So we need a class that encapsulates the variable with its log.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nDoubleString\n \n{\n\n  \nDouble\n \nx\n;\n\n  \nString\n \nlog\n;\n\n\n  \nDoubleString\n(\ndouble\n \nx\n,\n \nString\n \nlog\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\nlog\n \n=\n \nlog\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNow, we can write the methods as:\n\n\n1\n2\n3\n4\n5\n6\n7\nDoubleString\n \nsinAndLog\n(\ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \nnew\n \nDoubleString\n(\nsin\n(\nx\n),\n \n\"called sin\"\n);\n\n\n}\n\n\n\nDoubleString\n \ncubeAndLog\n(\ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \nnew\n \nDoubleString\n(\ncube\n(\nx\n),\n \n\"called cube\"\n);\n\n\n}\n\n\n\n\n\n\n\nIn a way, we are writing methods that take in a value (\ndouble x\n) and add some context to it (the log).  We wrap both the value and its context in a box (the \nDoubleString\n).\n\n\nBut these new functions do not compose anymore.  We cannot do \nsinAndLog(cubeAndLog(x))\n \n\n\nWe need methods that takes in a \nDoubleString\n and return a \nDoubleString\n\n\n1\n2\n3\n4\n5\n6\n7\nDoubleString\n \nsinAndLog\n(\nDoubleString\n \nds\n)\n \n{\n\n  \nreturn\n \nnew\n \nDoubleString\n(\nsin\n(\nds\n.\nx\n),\n \nds\n.\nlog\n \n+\n \n\"called sin\"\n);\n\n\n}\n\n\n\nDoubleString\n \ncubeAndLog\n(\nDoubleString\n \nds\n)\n \n{\n\n  \nreturn\n \nnew\n \nDoubleString\n(\ncube\n(\nds\n.\nx\n),\n \nds\n.\nlog\n \n+\n \n\"called cube\"\n);\n\n\n}\n\n\n\n\n\n\n\nGreat, now we can write the methods to compose them:\n\n\n1\nsinAndLog\n(\ncubeAndLog\n(\nnew\n \nDoubleString\n(\n5.0\n,\n\"\"\n)));\n\n\n\n\n\n\n\nor in the OO-way\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nDoubleString\n \n{\n\n  \nDouble\n \nx\n;\n\n  \nString\n \nlog\n;\n\n\n  \nDoubleString\n(\ndouble\n \nx\n,\n \nString\n \nlog\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\nlog\n \n=\n \nlog\n;\n\n  \n}\n\n\n  \nDoubleString\n \nsinAndLog\n()\n \n{\n\n    \nreturn\n \nnew\n \nDoubleString\n(\nsin\n(\nthis\n.\nx\n),\n \nlog\n \n+\n \n\"called sin\"\n);\n\n  \n}\n\n\n  \nDoubleString\n \ncubeAndLog\n()\n \n{\n\n    \nreturn\n \nnew\n \nDoubleString\n(\ncube\n(\nthis\n.\nx\n),\n \nlog\n \n+\n \n\"called cube\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nIn the OO-way, we chain the methods together.\n\n\n1\nnew\n \nDoubleString\n(\n5.0\n,\n \n\"\"\n).\nsinAndLog\n().\ncubeAndLog\n();\n\n\n\n\n\n\n\nMaking It A Monad\n\n\nNow, here is where I \njump to creating a monad\n.  I do not want to convert all my methods that takes in \ndouble\n and returns \nDoubleString\n into something that takes in \nDoubleString\n and returns \nDoubleString\n.  Yet, I want to be able to compose them and chain them together.  So I write a general method that allows that, and that is our \nflatMap\n method:\n\n\n1\n2\n3\n4\n  \nDoubleString\n \nflatMap\n(\nFunction\n<\nDouble\n,\n \nDoubleString\n>\n \nmapper\n)\n \n{\n\n    \nDoubleString\n \nds\n \n=\n \nmapper\n.\napply\n(\nx\n);\n\n    \nreturn\n \nnew\n \nDoubleString\n(\nds\n.\nx\n,\n \nthis\n.\nlog\n \n+\n \n\"\\n\"\n \n+\n \nds\n.\nlog\n);\n\n  \n}\n\n\n\n\n\n\n\nWe can now use \nflatMap\n to chain different operations together.\n\n\n1\n2\n3\nDoubleString ds = new DoubleString(5.0, \"\")\n    .flatMap(x -> sinAndLog(x))\n    .flatMap(x -> cubeAndLog(x));\n\n\n\n\n\n\nNow \nDoubleString\n is a monad!\n\n\nGoing back to our \"wrap a value in a box with context\" explanation.  If we have two such wrappers, how do we wrap twice?  We have to (i) wrap it one time, (ii) unwrap to get the new value and \nnew context\n, and wrap it again.  \n\n\nThe two lines in \nflatMap\n corresponds to (i) and (ii) respectively.\n\n\nLine \nds = mapper.apply(x);\n wraps it once; The next line unwraps the value and the context (\nds.x\n and \ndx.log\n) and wraps it again (\n\nnew DoubleString(..)\n) with the next context (\nthis.log + \"\\n\" + ds.log\n).\n\n\nHere is our monad:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nDoubleString\n \n{\n\n  \nDouble\n \nx\n;\n\n  \nString\n \nlog\n;\n\n\n  \nDoubleString\n(\ndouble\n \nx\n,\n \nString\n \nlog\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\nlog\n \n=\n \nlog\n;\n\n  \n}\n\n\n  \nDoubleString\n \nflatMap\n(\nFunction\n<\nDouble\n,\n \nDoubleString\n>\n \nmapper\n)\n \n{\n\n    \nDoubleString\n \nds\n \n=\n \nmapper\n.\napply\n(\nx\n);\n\n    \nreturn\n \nnew\n \nDoubleString\n(\nds\n.\nx\n,\n \nthis\n.\nlog\n \n+\n \n\"\\n\"\n \n+\n \nds\n.\nlog\n);\n\n  \n}\n\n\n  \npublic\n \nString\n \ntoString\n()\n \n{\n\n    \nreturn\n \nx\n \n+\n \n\"\\n\"\n \n+\n \nlog\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nMaking a Generic Monad that Logs\n\n\nWe can make \nDoubleString\n a generic class that logs what happen to a variable.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nLogger\n<\nT\n>\n \n{\n\n  \nT\n \nx\n;\n\n  \nString\n \nlog\n;\n\n\n  \nLogger\n(\nT\n \nx\n,\n \nString\n \nlog\n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\nlog\n \n=\n \nlog\n;\n\n  \n}\n\n\n  \n<\nR\n>\n \nLogger\n<\nR\n>\n \nflatMap\n(\nFunction\n<?\n \nsuper\n \nT\n,\n \n?\n \nextends\n \nLogger\n<?\n \nextends\n \nR\n>>\n \nmapper\n)\n \n{\n\n    \nLogger\n<\nR\n>\n \nds\n \n=\n \nmapper\n.\napply\n(\nx\n);\n\n    \nreturn\n \nnew\n \nLogger\n<>(\nds\n.\nx\n,\n \nthis\n.\nlog\n \n+\n \n\"\\n\"\n \n+\n \nds\n.\nlog\n);\n\n  \n}\n\n\n  \npublic\n \nString\n \ntoString\n()\n \n{\n\n    \nreturn\n \nx\n \n+\n \n\"\\n\"\n \n+\n \nlog\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nFunctor\n\n\nCan we do this with a functor?  Note that a functor has a \nmap\n method with type \nFunction<T,R>\n.  A \nmap\n method for \nDoubleString\n would looks like \nFunction<Double,Double>\n.  So it cannot do what the monad does.  A functor can only change the value inside the box, but it cannot rewrap it with an updated context.\n\n\nWait, What is a Monad Again?\n\n\nI hope the example above helps explain what is a monad -- it is a value wrapped in a box with context, and it allows us to compose wrappers (wrap multuple times), operate on its value and update the context if needed.",
            "title": "Extra. Build a Monad"
        },
        {
            "location": "/monad/index.html#extra-do-you-want-to-build-a-monad",
            "text": "This article is inspired by (The Best Introduction to Monad)[ https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/# ], but is adapted to the OO-context with Java.  Let's say we have:  1\n2\n3\n4\n5\n6\n7 double   sin ( double   x )   { \n   return   Math . sin ( x );  }  double   cube ( double   x )   { \n   return   x * x * x ;  }    We can easily chain the methods together:  1\n2 sin ( cube ( 5.0 ));  cube ( sin ( 5.0 ));    But, what if we need to print something while doing this operation?  We can easily do:  1\n2\n3\n4\n5\n6\n7\n8\n9 double   sin ( double   x )   { \n   System . out . println ( \"called sin\" ); \n   return   Math . sin ( x );  }  double   cube ( double   x )   { \n   System . out . println ( \"called cubed\" ); \n   return   x * x * x ;  }    But that has side effects, so it violates the spirit of functional programming.\nWe should concat the logs into a string (just like what you did in Lab 4).  So we need a class that encapsulates the variable with its log.  1\n2\n3\n4\n5\n6\n7\n8\n9 class   DoubleString   { \n   Double   x ; \n   String   log ; \n\n   DoubleString ( double   x ,   String   log )   { \n     this . x   =   x ; \n     this . log   =   log ; \n   }  }    Now, we can write the methods as:  1\n2\n3\n4\n5\n6\n7 DoubleString   sinAndLog ( double   x )   { \n   return   new   DoubleString ( sin ( x ),   \"called sin\" );  }  DoubleString   cubeAndLog ( double   x )   { \n   return   new   DoubleString ( cube ( x ),   \"called cube\" );  }    In a way, we are writing methods that take in a value ( double x ) and add some context to it (the log).  We wrap both the value and its context in a box (the  DoubleString ).  But these new functions do not compose anymore.  We cannot do  sinAndLog(cubeAndLog(x))    We need methods that takes in a  DoubleString  and return a  DoubleString  1\n2\n3\n4\n5\n6\n7 DoubleString   sinAndLog ( DoubleString   ds )   { \n   return   new   DoubleString ( sin ( ds . x ),   ds . log   +   \"called sin\" );  }  DoubleString   cubeAndLog ( DoubleString   ds )   { \n   return   new   DoubleString ( cube ( ds . x ),   ds . log   +   \"called cube\" );  }    Great, now we can write the methods to compose them:  1 sinAndLog ( cubeAndLog ( new   DoubleString ( 5.0 , \"\" )));    or in the OO-way   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   DoubleString   { \n   Double   x ; \n   String   log ; \n\n   DoubleString ( double   x ,   String   log )   { \n     this . x   =   x ; \n     this . log   =   log ; \n   } \n\n   DoubleString   sinAndLog ()   { \n     return   new   DoubleString ( sin ( this . x ),   log   +   \"called sin\" ); \n   } \n\n   DoubleString   cubeAndLog ()   { \n     return   new   DoubleString ( cube ( this . x ),   log   +   \"called cube\" ); \n   }  }    In the OO-way, we chain the methods together.  1 new   DoubleString ( 5.0 ,   \"\" ). sinAndLog (). cubeAndLog ();",
            "title": "Extra: Do You Want to Build a Monad?"
        },
        {
            "location": "/monad/index.html#making-it-a-monad",
            "text": "Now, here is where I  jump to creating a monad .  I do not want to convert all my methods that takes in  double  and returns  DoubleString  into something that takes in  DoubleString  and returns  DoubleString .  Yet, I want to be able to compose them and chain them together.  So I write a general method that allows that, and that is our  flatMap  method:  1\n2\n3\n4    DoubleString   flatMap ( Function < Double ,   DoubleString >   mapper )   { \n     DoubleString   ds   =   mapper . apply ( x ); \n     return   new   DoubleString ( ds . x ,   this . log   +   \"\\n\"   +   ds . log ); \n   }    We can now use  flatMap  to chain different operations together.  1\n2\n3 DoubleString ds = new DoubleString(5.0, \"\")\n    .flatMap(x -> sinAndLog(x))\n    .flatMap(x -> cubeAndLog(x));   Now  DoubleString  is a monad!  Going back to our \"wrap a value in a box with context\" explanation.  If we have two such wrappers, how do we wrap twice?  We have to (i) wrap it one time, (ii) unwrap to get the new value and  new context , and wrap it again.    The two lines in  flatMap  corresponds to (i) and (ii) respectively.  Line  ds = mapper.apply(x);  wraps it once; The next line unwraps the value and the context ( ds.x  and  dx.log ) and wraps it again ( new DoubleString(..) ) with the next context ( this.log + \"\\n\" + ds.log ).  Here is our monad:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   DoubleString   { \n   Double   x ; \n   String   log ; \n\n   DoubleString ( double   x ,   String   log )   { \n     this . x   =   x ; \n     this . log   =   log ; \n   } \n\n   DoubleString   flatMap ( Function < Double ,   DoubleString >   mapper )   { \n     DoubleString   ds   =   mapper . apply ( x ); \n     return   new   DoubleString ( ds . x ,   this . log   +   \"\\n\"   +   ds . log ); \n   } \n\n   public   String   toString ()   { \n     return   x   +   \"\\n\"   +   log ; \n   }  }",
            "title": "Making It A Monad"
        },
        {
            "location": "/monad/index.html#making-a-generic-monad-that-logs",
            "text": "We can make  DoubleString  a generic class that logs what happen to a variable.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   Logger < T >   { \n   T   x ; \n   String   log ; \n\n   Logger ( T   x ,   String   log )   { \n     this . x   =   x ; \n     this . log   =   log ; \n   } \n\n   < R >   Logger < R >   flatMap ( Function <?   super   T ,   ?   extends   Logger <?   extends   R >>   mapper )   { \n     Logger < R >   ds   =   mapper . apply ( x ); \n     return   new   Logger <>( ds . x ,   this . log   +   \"\\n\"   +   ds . log ); \n   } \n\n   public   String   toString ()   { \n     return   x   +   \"\\n\"   +   log ; \n   }  }",
            "title": "Making a Generic Monad that Logs"
        },
        {
            "location": "/monad/index.html#functor",
            "text": "Can we do this with a functor?  Note that a functor has a  map  method with type  Function<T,R> .  A  map  method for  DoubleString  would looks like  Function<Double,Double> .  So it cannot do what the monad does.  A functor can only change the value inside the box, but it cannot rewrap it with an updated context.",
            "title": "Functor"
        },
        {
            "location": "/monad/index.html#wait-what-is-a-monad-again",
            "text": "I hope the example above helps explain what is a monad -- it is a value wrapped in a box with context, and it allows us to compose wrappers (wrap multuple times), operate on its value and update the context if needed.",
            "title": "Wait, What is a Monad Again?"
        },
        {
            "location": "/review-questions/index.html",
            "text": "Review Questions\n\n\nHere are some exercises to get ready for the final exam.  They are rejected ideas for final exam questions from last semester and this semester. :)\n\n\nQuestion 1: Infinite lists\n\n\nImplement a method called \ninterleave\n that takes in two \nInfiniteList<T>\n objects, and produce another \nInfiniteList<T>\n with elements in the two lists interleave.\n\n\nFor instance,\n\n\n1\n2\n3\nlist1 = InfiniteList.generate(() -> 1);\nlist2 = InfiniteList.generate(() -> 2);\ninterleave(list1, list2).limit(6).toArray(); // returns [1, 2, 1, 2, 1, 2]\n\n\n\n\n\n\nThe method \ninterleave\n must be lazily evaluated.  You can assume that the constructor\n\n\n1\nInfiniteList<T>(Supplier<T> headSupplier, Supplier<InfiniteList<T>> tailSupplier)\n\n\n\n\n\n\nis available.\n\n\nQuestion 2: Completable future\n\n\na()\n, \nb()\n, and \nc()\n are three methods that takes in no arguments and returns nothing (void).  We want to run them asynchronously, such that \na()\n and \nb()\n run first, in any order, concurrently.  But \nc()\n can only run after either one of \na()\n or \nb()\n completes.\n\n\nUsing the class \nCompletableFuture\n, write snippets of code to show how this can be done.  The \nAPIs for \nCompletableFuture\n is provided\n\n\nQuestion 3: Lambdas\n\n\nJava implements lambda expressions as anonymous classes.  Suppose we have the following lambda expression \nFunction<String,Integer>\n:\n\n\n1\nstr -> str.indexOf(' ')\n\n\n\n\n\n\nWrite the equivalent anonymous class for the expression above.\n\n\nQuestion 4: Stream of Functions\n\n\nIn mathematics, an \niterated function\n is a function that is composed with itself some number of times.  We denote \nf^n\nf^n\n = \nf \\cdot f \\cdot ... f\nf \\cdot f \\cdot ... f\n as function \nf\nf\n composed with itself \nn\nn\n times.  For instance, if \nf\nf\n is \n\\frac{1}{1 + x}\n\\frac{1}{1 + x}\n, then \nf^3\nf^3\n is \n\\frac{1}{1 + \\frac{1}{1 + \\frac{1}{1 + x}}}\n\\frac{1}{1 + \\frac{1}{1 + \\frac{1}{1 + x}}}\n.  \n\n\n(a) Write a method that, given a \nFunction<T,T> f\n, generate a stream of iterated functions of \nf\nf\n.  The i-th element in the stream is \nf^i\nf^i\n.\n\n\n(b) Write a method that, given a stream of iterated functions \nf\nf\n, \nf^2\nf^2\n, ..., and a value \nt\n of type \nT\n, return a stream of values where each element is the result of applying the corresponding iterated function on \nt\n.\n\n\nQuestion 5: OO\n\n\n(a)\nThe following code is not written using inheritance nor polymorphism.  Rewrite it so that it properly uses inheritance / polymorphism, eliminating the need for \nStoneType\n and the field \ntype\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nenum\n \nStoneType\n \n{\n\n  \nTIME\n,\n \nSPACE\n,\n \nPOWER\n,\n \nMIND\n\n\n};\n\n\n\nclass\n \nInfinityStone\n \n{\n\n  \nStoneType\n \ntype\n;\n\n  \nColor\n \nc\n;\n\n\n  \nInifinityStone\n(\nStoneType\n \ntype\n)\n \n{\n\n    \nthis\n.\ntype\n \n=\n \ntype\n;\n\n    \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nTIME\n)\n \n{\n\n      \nc\n \n=\n \nColor\n.\nGREEN\n;\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nSPACE\n)\n \n{\n\n      \nc\n \n=\n \nColor\n.\nBLUE\n;\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nPOWER\n)\n \n{\n\n      \nc\n \n=\n \nColor\n.\nPURPLE\n;\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nMIND\n)\n \n{\n\n      \nc\n \n=\n \nColor\n.\nYELLOW\n;\n\n    \n}\n\n  \n}\n\n\n  \nvoid\n \nactivate\n()\n \n{\n\n    \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nTIME\n)\n \n{\n\n      \nwarpTime\n();\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nSPACE\n)\n \n{\n\n      \ncontrolSpace\n();\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nPOWER\n)\n \n{\n\n      \nmanipulateEnergy\n();\n\n    \n}\n \nelse\n \nif\n \n(\ntype\n \n==\n \nStoneType\n.\nMIND\n)\n \n{\n\n      \ncontrolMind\n();\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n// example of how the class will be used:\n\n\nInfinityStone\n \ntesseract\n \n=\n \nnew\n \nInifinityStone\n(\nStoneType\n.\nSPACE\n);\n\n\ntesseract\n.\nactivate\n();\n\n\n\n\n\n\n\n(b)\nSuppose we want to add two new stone types REALITY and SOUL.  Explain how you would do it with the original version and the OO version -- contrast how much existing code you need to modify vs. how much code you would need to add.  \n\n\np/s: Adding new code is preferable over modifying existing code, since the latter is more bug prone.\n\n\nQuestion 6: Bad Practices\n\n\nEach of the following code illusrates a very bad programming practice.  For each, comments on why it is bad.\n\n\n(a) \"Pokemon Catch\" \n\n\n1\n2\n3\n4\n5\n    \ntry\n \n{\n\n      \ndoSomething\n();\n\n    \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n\n    \n}\n\n\n\n\n\n\n\n(b) Switching between strings\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n   \nswitch\n(\ncustomer\n.\ngetType\n())\n \n{\n\n     \ncase\n \n\"Normal\"\n:\n \n       \njoinQueueNormal\n();\n\n     \ncase\n \n\"Greedy\"\n:\n \n       \njoinQueueGreedy\n();\n\n     \ndefault\n:\n\n       \njoinQueueRandom\n();\n\n   \n}\n \n\n\n\n\n\n\n(c ) \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvoid\n \ngetCustomerType\n()\n \n{\n\n  \nif\n \n(\ncustomer\n.\nisNormal\n())\n \n{\n\n    \nthrow\n \nnew\n \nNormalCustomerException\n();\n\n  \n}\n \nelse\n \nif\n \n(\ncustomer\n.\nisGreedy\n())\n \n{\n\n    \nthrow\n \nnew\n \nGreedyCustomerException\n();\n\n  \n}\n\n\n}\n\n\n  \n:\n\n  \n:\n\n\n\ntry\n \n{\n\n  \ngetCustomerType\n();\n\n  \njoinQueueRandom\n();\n\n\n}\n \ncatch\n \n(\nNormalCustomerException\n \ne\n)\n \n{\n\n  \njoinQueueNormal\n();\n\n\n}\n \ncatch\n \n(\nGreedyCustomerException\n \ne\n)\n \n{\n\n  \njoinQueueGreedy\n();\n\n\n}\n\n\n\n\n\n\n\n(d)\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n// customers, servers, queues are arrays of Customer, \n\n\n// Server, and Queue respectively.\n\n\nCustomer\n[]\n \ncustomers\n;\n\n\nServer\n[]\n \nservers\n;\n\n\nQueue\n[]\n \nqueues\n;\n\n  \n:\n\n  \n:\n\n\n\nvoid\n \nhandleCustomer\n(\nint\n \nq\n,\n \nint\n \ns\n,\n \nint\n \nc\n)\n \n{\n\n  \n// if servers[s] is busy, add customers[c] into queues[q]\n\n  \n// otherwise servers[s] serves customers[c]\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nQuestion 7: Ask, Don't Tell\n\n\nSuggest how we can improve the design of the classes below.  Only relevant part of the code are shown for brevity.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass\n \nLabSubmission\n \n{\n\n  \nprivate\n \nStudent\n \ns\n;\n\n  \nprivate\n \nint\n \nmarks\n;\n\n\n  \npublic\n \nStudent\n \ngetStudent\n()\n \n{\n\n    \nreturn\n \ns\n;\n\n  \n}\n\n\n  \npublic\n \nint\n \ngetMarks\n()\n \n{\n\n    \nreturn\n \nmarks\n;\n\n  \n}\n\n\n    \n:\n\n    \n:\n\n\n}\n\n\n\nclass\n \nGradebook\n \n{\n\n  \nList\n<\nLabSubmission\n>\n \nsubmissions\n;\n\n\n  \nvoid\n \nprint\n()\n \n{\n\n    \nfor\n \n(\nLabSubmission\n \ns\n \n:\n \nsubmissions\n)\n \n{\n\n      \nif\n \n(\ns\n.\ngetMarks\n()\n \n>\n \n3\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintf\n(\ns\n.\ngetStudent\n()\n \n+\n \n\" A\"\n);\n\n      \n}\n \nelse\n \nif\n \n(\ns\n.\ngetMarks\n()\n \n>\n \n2\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintf\n(\ns\n.\ngetStudent\n()\n \n+\n \n\" B\"\n);\n\n      \n}\n \nelse\n \nif\n \n(\ns\n.\ngetMarks\n()\n \n>\n \n1\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintf\n(\ns\n.\ngetStudent\n()\n \n+\n \n\" C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \nSystem\n.\nout\n.\nprintf\n(\ns\n.\ngetStudent\n()\n \n+\n \n\" D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}",
            "title": "Extra. Review Questions"
        },
        {
            "location": "/review-questions/index.html#review-questions",
            "text": "Here are some exercises to get ready for the final exam.  They are rejected ideas for final exam questions from last semester and this semester. :)",
            "title": "Review Questions"
        },
        {
            "location": "/review-questions/index.html#question-1-infinite-lists",
            "text": "Implement a method called  interleave  that takes in two  InfiniteList<T>  objects, and produce another  InfiniteList<T>  with elements in the two lists interleave.  For instance,  1\n2\n3 list1 = InfiniteList.generate(() -> 1);\nlist2 = InfiniteList.generate(() -> 2);\ninterleave(list1, list2).limit(6).toArray(); // returns [1, 2, 1, 2, 1, 2]   The method  interleave  must be lazily evaluated.  You can assume that the constructor  1 InfiniteList<T>(Supplier<T> headSupplier, Supplier<InfiniteList<T>> tailSupplier)   is available.",
            "title": "Question 1: Infinite lists"
        },
        {
            "location": "/review-questions/index.html#question-2-completable-future",
            "text": "a() ,  b() , and  c()  are three methods that takes in no arguments and returns nothing (void).  We want to run them asynchronously, such that  a()  and  b()  run first, in any order, concurrently.  But  c()  can only run after either one of  a()  or  b()  completes.  Using the class  CompletableFuture , write snippets of code to show how this can be done.  The  APIs for  CompletableFuture  is provided",
            "title": "Question 2: Completable future"
        },
        {
            "location": "/review-questions/index.html#question-3-lambdas",
            "text": "Java implements lambda expressions as anonymous classes.  Suppose we have the following lambda expression  Function<String,Integer> :  1 str -> str.indexOf(' ')   Write the equivalent anonymous class for the expression above.",
            "title": "Question 3: Lambdas"
        },
        {
            "location": "/review-questions/index.html#question-4-stream-of-functions",
            "text": "In mathematics, an  iterated function  is a function that is composed with itself some number of times.  We denote  f^n f^n  =  f \\cdot f \\cdot ... f f \\cdot f \\cdot ... f  as function  f f  composed with itself  n n  times.  For instance, if  f f  is  \\frac{1}{1 + x} \\frac{1}{1 + x} , then  f^3 f^3  is  \\frac{1}{1 + \\frac{1}{1 + \\frac{1}{1 + x}}} \\frac{1}{1 + \\frac{1}{1 + \\frac{1}{1 + x}}} .    (a) Write a method that, given a  Function<T,T> f , generate a stream of iterated functions of  f f .  The i-th element in the stream is  f^i f^i .  (b) Write a method that, given a stream of iterated functions  f f ,  f^2 f^2 , ..., and a value  t  of type  T , return a stream of values where each element is the result of applying the corresponding iterated function on  t .",
            "title": "Question 4: Stream of Functions"
        },
        {
            "location": "/review-questions/index.html#question-5-oo",
            "text": "(a)\nThe following code is not written using inheritance nor polymorphism.  Rewrite it so that it properly uses inheritance / polymorphism, eliminating the need for  StoneType  and the field  type .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37 enum   StoneType   { \n   TIME ,   SPACE ,   POWER ,   MIND  };  class   InfinityStone   { \n   StoneType   type ; \n   Color   c ; \n\n   InifinityStone ( StoneType   type )   { \n     this . type   =   type ; \n     if   ( type   ==   StoneType . TIME )   { \n       c   =   Color . GREEN ; \n     }   else   if   ( type   ==   StoneType . SPACE )   { \n       c   =   Color . BLUE ; \n     }   else   if   ( type   ==   StoneType . POWER )   { \n       c   =   Color . PURPLE ; \n     }   else   if   ( type   ==   StoneType . MIND )   { \n       c   =   Color . YELLOW ; \n     } \n   } \n\n   void   activate ()   { \n     if   ( type   ==   StoneType . TIME )   { \n       warpTime (); \n     }   else   if   ( type   ==   StoneType . SPACE )   { \n       controlSpace (); \n     }   else   if   ( type   ==   StoneType . POWER )   { \n       manipulateEnergy (); \n     }   else   if   ( type   ==   StoneType . MIND )   { \n       controlMind (); \n     } \n   }  }  // example of how the class will be used:  InfinityStone   tesseract   =   new   InifinityStone ( StoneType . SPACE );  tesseract . activate ();    (b)\nSuppose we want to add two new stone types REALITY and SOUL.  Explain how you would do it with the original version and the OO version -- contrast how much existing code you need to modify vs. how much code you would need to add.    p/s: Adding new code is preferable over modifying existing code, since the latter is more bug prone.",
            "title": "Question 5: OO"
        },
        {
            "location": "/review-questions/index.html#question-6-bad-practices",
            "text": "Each of the following code illusrates a very bad programming practice.  For each, comments on why it is bad.  (a) \"Pokemon Catch\"   1\n2\n3\n4\n5      try   { \n       doSomething (); \n     }   catch   ( Exception   e )   { \n\n     }    (b) Switching between strings  1\n2\n3\n4\n5\n6\n7\n8     switch ( customer . getType ())   { \n      case   \"Normal\" :  \n        joinQueueNormal (); \n      case   \"Greedy\" :  \n        joinQueueGreedy (); \n      default : \n        joinQueueRandom (); \n    }     (c )    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 void   getCustomerType ()   { \n   if   ( customer . isNormal ())   { \n     throw   new   NormalCustomerException (); \n   }   else   if   ( customer . isGreedy ())   { \n     throw   new   GreedyCustomerException (); \n   }  } \n\n   : \n   :  try   { \n   getCustomerType (); \n   joinQueueRandom ();  }   catch   ( NormalCustomerException   e )   { \n   joinQueueNormal ();  }   catch   ( GreedyCustomerException   e )   { \n   joinQueueGreedy ();  }    (d)   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 // customers, servers, queues are arrays of Customer,   // Server, and Queue respectively.  Customer []   customers ;  Server []   servers ;  Queue []   queues ; \n   : \n   :  void   handleCustomer ( int   q ,   int   s ,   int   c )   { \n   // if servers[s] is busy, add customers[c] into queues[q] \n   // otherwise servers[s] serves customers[c] \n     :  }",
            "title": "Question 6: Bad Practices"
        },
        {
            "location": "/review-questions/index.html#question-7-ask-dont-tell",
            "text": "Suggest how we can improve the design of the classes below.  Only relevant part of the code are shown for brevity.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 class   LabSubmission   { \n   private   Student   s ; \n   private   int   marks ; \n\n   public   Student   getStudent ()   { \n     return   s ; \n   } \n\n   public   int   getMarks ()   { \n     return   marks ; \n   } \n\n     : \n     :  }  class   Gradebook   { \n   List < LabSubmission >   submissions ; \n\n   void   print ()   { \n     for   ( LabSubmission   s   :   submissions )   { \n       if   ( s . getMarks ()   >   3 )   { \n         System . out . printf ( s . getStudent ()   +   \" A\" ); \n       }   else   if   ( s . getMarks ()   >   2 )   { \n         System . out . printf ( s . getStudent ()   +   \" B\" ); \n       }   else   if   ( s . getMarks ()   >   1 )   { \n         System . out . printf ( s . getStudent ()   +   \" C\" ); \n       }   else   { \n         System . out . printf ( s . getStudent ()   +   \" D\" ); \n       } \n     } \n   }  }",
            "title": "Question 7: Ask, Don't Tell"
        },
        {
            "location": "/style/index.html",
            "text": "CS2030 Java Style Guide\n\n\nWhy Coding Style is Important\n\n\nOne of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style.\n\n\nIf everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the \nApple \ngoto fail\n bug\n).  Empirical studies support this:\n\n\n\n\nQuote\n\n\n\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"\n\n\nElliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.\n\n\n\n\nMany major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on \nGoogle's Java Coding Style\n.  You should bookmark the link because you need to come back to it again and again.\n\n\nCS2030 Coding Style\n\n\n\n\n\n\nNo tab\n    Use only whitespace.  \n\n\nFor \nvim\n users, you can add the following line in your \n~/.vimrc\n file:\n\n1\nset expandtab\n\n\n\n\nSo that when you press \n it is expanded to whitespace.\n\n\nMost other source code editors have similar configuration.  \n\n\n\n\n\n\nExactly one blank line after import statements and exactly one top-level (i.e., non-nested) class.\n\n\n\n\n\n\nEach top-level class resides in a source file of its own.\n\n\n\n\n\n\nWhen a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.\n\n\n\n\n\n\nBraces are always used (even if the body is empty or contains a single statement}\n\n\n\n\n\n\nUse \"Egyptian brackets\": \n\n\n\n\nOpening brace have no line break before; but has line break after\n\n\nClosing brace has a line break before; and has a line break after (except when there is \nelse\n or comma following a closing brace.\n\n\n\n\nExample:\n\n1\n2\n3\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n\n     \nx\n++;\n\n   \n}\n \n\n\n\n\n\nis good.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \nx\n++;\n \n}\n\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n   \n{\n\n     \nx\n++;\n\n   \n}\n\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n   \n{\n\n     \nx\n++;\n \n}\n\n\n\n\n\n\n\nare not good.\n\n\n\n\n\n\nBlock indentation is exactly two spaces.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \n  \nx\n++;\n\n  \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nx\n;\n \ni\n++)\n \n{\n\n    \nx\n \n+=\n \ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nFor \nvim\n users, in \n~/.vimrc\n, add the following:\n\n1\n2\n3\n4\nset tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent\n\n\n\n\n\nTo help you with indentation.\n\n\nMost other source code editors have similar configuration.  \n\n\n\n\n\n\nEach statement is followed by a line break, no matter how short the statement is.\n\n\n1\n  \nx\n++;\n \ni\n++;\n\n\n\n\n\nis bad.\n\n1\n2\n  \nx\n++;\n \n  \ni\n++;\n\n\n\n\n\nis good.\n\n\n\n\n\n\nEach line is limited to 80 characters in length.  You can break a long\nline into multiple lines to enhance readability, this is called \nline wrapping\n.  When you do so, each continuation line is indented at least 4 spaces from the original line.\n\n\n1\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\"\n);\n\n\n\n\n\n\n\nis bad.\n\n\n1\n2\n3\n4\n5\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen, the First of\"\n \n+\n\n\n\" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\"\n \n+\n\n\n\" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\"\n \n+\n\n\n\"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\"\n \n+\n\n\n\"er of Chains and Mother of Dragon\"\n);\n\n\n\n\n\n\n\nis also bad.\n\n\n1\n2\n3\n4\n5\n6\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen,\"\n \n+\n \n    \n\"the First of Her Name, The Unburnt, Queen of the Andals,\"\n \n+\n\n    \n\"the Rhoynar and the First Men, Queen of Meereen,\"\n \n+\n\n    \n\"Khaleesi of the Great Grass Sea, Protector of the Realm,\"\n \n+\n\n    \n\"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\"\n \n+\n\n    \n\"Mother of Dragon\"\n);\n\n\n\n\n\nis ok.\n\n\n\n\n\n\n\n\n80 vs 100\n\n\nWhile we prefer lines to be limited to 80, we are OK if the length is up to 100.  Any longer, however, will be frowned upon.\n\n\n\n\n\n\n\n\nThere should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.\n\n\n\n\n\n\nWhite space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators (\n+\n, \n-\n, \n/\n, etc) as well as \n:\n in enhanced for.  Space should also appears before and after \n//\n comments\n\n\n1\n2\n3\n4\n5\n6\nif\n(\nx\n==\n0\n){\n \n  \nx\n++;\n//to make sure x is at least one.\n\n  \nfor\n(\ni\n=\n0\n;\ni\n<\nx\n;\ni\n++){\n\n    \nx\n+=\ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nis bad.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \n  \nx\n++;\n \n// to make sure x is at least one.\n\n  \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nx\n;\n \ni\n++)\n \n{\n\n    \nx\n \n+=\n \ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nis good.\n\n\n\n\n\n\nOne variable per declaration.  \n\n\n1\nint\n \nx\n,\n \ny\n;\n\n\n\n\n\n\n\nbad.\n\n\n1\n2\nint\n \nx\n;\n\n\nint\n \ny\n;\n\n\n\n\n\n\n\ngood!\n\n\n\n\n\n\nNo C-style array declaration\n\n\n1\nString\n \nargs\n[];\n\n\n\n\n\n\n\nnot good.\n\n\n1\nString\n[]\n \nargs\n;\n\n\n\n\n\n\n\ngood!\n\n\n\n\n\n\nSwitch statement always include a \ndefault\n case.\n\n\n\n\n\n\nOne annotation per line.  Always use \n@Override\n.\n\n\n1\n2\n3\n4\n@Override\n\n\npublic\n \nboolean\n \nequals\n(\nObject\n \no\n)\n \n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nIndent comments at the same level as the surrounding code.  For multiple comments, align \n*\n with the previous line.\n\n\n1\n2\n3\n4\n5\n6\n/*\n\n\n* Not a good style\n\n\n*/\n\n\n/*\n\n\n * Good style\n\n\n */\n\n\n\n\n\n\n\n\n\n\n\nClass modifier appears in the following order:\n\n\n1\npublic\n \nprotected\n \nprivate\n \nabstract\n \ndefault\n \nstatic\n \nfinal\n \ntransient\n \nvolatile\n \nsynchronized\n \nnative\n \nstrictfp\n\n\n\n\n\n\n\nExample:\n\n1\nstatic\n \npublic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n\n\n\n\n\nis bad.\n\n1\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n\n\n\n\n\nis good!\n\n\n\n\n\n\nClass names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE.  Type parameters in single capital letter.\n\n\n\n\n\n\nCaught exceptions should not be ignored.\n\n\n\n\n\n\nStatic fields and methods must be accessed with class name.\n\n\n\n\n\n\nUsing \ncheckstyle\n\n\nTo automatically check for style violation, we use a tool call \ncheckstyle\n.\n\n\nYou can copy the files from the directory \n~cs2030/bin/\n on host \ncs2030-i.comp.nus.edu.sg\n.  There are only two files:\n\n\n\n\ncheckstyle-8.2-all.jar\n: the Java application for \ncheckstyle\n\n\ncs2030_checks.xml\n: the configuration file\n\n\n\n\nTo run, \n\n\n1\njava -jar checkstyle-8.2-all.jar -c cs2030_checks.xml *.java \n\n\n\n\n\n\nYou can of course change the location of the \njar\n and the \nxml\n files to anywhere you like.  The command above assumes they are in the same folder as the java source files.\n\n\nHint: put the command into a \nbash\n script so that you do not need to type such a long string all the time.",
            "title": "Coding Style"
        },
        {
            "location": "/style/index.html#cs2030-java-style-guide",
            "text": "",
            "title": "CS2030 Java Style Guide"
        },
        {
            "location": "/style/index.html#why-coding-style-is-important",
            "text": "One of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style.  If everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the  Apple  goto fail  bug ).  Empirical studies support this:   Quote  \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"  Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.   Many major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on  Google's Java Coding Style .  You should bookmark the link because you need to come back to it again and again.",
            "title": "Why Coding Style is Important"
        },
        {
            "location": "/style/index.html#cs2030-coding-style",
            "text": "No tab\n    Use only whitespace.    For  vim  users, you can add the following line in your  ~/.vimrc  file: 1 set expandtab  \nSo that when you press   it is expanded to whitespace.  Most other source code editors have similar configuration.      Exactly one blank line after import statements and exactly one top-level (i.e., non-nested) class.    Each top-level class resides in a source file of its own.    When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.    Braces are always used (even if the body is empty or contains a single statement}    Use \"Egyptian brackets\":    Opening brace have no line break before; but has line break after  Closing brace has a line break before; and has a line break after (except when there is  else  or comma following a closing brace.   Example: 1\n2\n3     if   ( x   ==   0 )   { \n      x ++; \n    }     is good.  1\n2\n3\n4\n5\n6\n7\n8     if   ( x   ==   0 )   {   x ++;   } \n    if   ( x   ==   0 )  \n    { \n      x ++; \n    } \n    if   ( x   ==   0 )  \n    { \n      x ++;   }    are not good.    Block indentation is exactly two spaces.  1\n2\n3\n4\n5\n6 if   ( x   ==   0 )   {  \n   x ++; \n   for   ( i   =   0 ;   i   <   x ;   i ++)   { \n     x   +=   i ; \n   }  }    For  vim  users, in  ~/.vimrc , add the following: 1\n2\n3\n4 set tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent   To help you with indentation.  Most other source code editors have similar configuration.      Each statement is followed by a line break, no matter how short the statement is.  1    x ++;   i ++;   \nis bad. 1\n2    x ++;  \n   i ++;   \nis good.    Each line is limited to 80 characters in length.  You can break a long\nline into multiple lines to enhance readability, this is called  line wrapping .  When you do so, each continuation line is indented at least 4 spaces from the original line.  1 System . out . println ( \"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\" );    is bad.  1\n2\n3\n4\n5 System . out . println ( \"Daenerys of the House Targaryen, the First of\"   +  \" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\"   +  \" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\"   +  \"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\"   +  \"er of Chains and Mother of Dragon\" );    is also bad.  1\n2\n3\n4\n5\n6 System . out . println ( \"Daenerys of the House Targaryen,\"   +  \n     \"the First of Her Name, The Unburnt, Queen of the Andals,\"   + \n     \"the Rhoynar and the First Men, Queen of Meereen,\"   + \n     \"Khaleesi of the Great Grass Sea, Protector of the Realm,\"   + \n     \"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\"   + \n     \"Mother of Dragon\" );   \nis ok.     80 vs 100  While we prefer lines to be limited to 80, we are OK if the length is up to 100.  Any longer, however, will be frowned upon.     There should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.    White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators ( + ,  - ,  / , etc) as well as  :  in enhanced for.  Space should also appears before and after  //  comments  1\n2\n3\n4\n5\n6 if ( x == 0 ){  \n   x ++; //to make sure x is at least one. \n   for ( i = 0 ; i < x ; i ++){ \n     x += i ; \n   }  }    is bad.  1\n2\n3\n4\n5\n6 if   ( x   ==   0 )   {  \n   x ++;   // to make sure x is at least one. \n   for   ( i   =   0 ;   i   <   x ;   i ++)   { \n     x   +=   i ; \n   }  }    is good.    One variable per declaration.    1 int   x ,   y ;    bad.  1\n2 int   x ;  int   y ;    good!    No C-style array declaration  1 String   args [];    not good.  1 String []   args ;    good!    Switch statement always include a  default  case.    One annotation per line.  Always use  @Override .  1\n2\n3\n4 @Override  public   boolean   equals ( Object   o )   { \n   :  }      Indent comments at the same level as the surrounding code.  For multiple comments, align  *  with the previous line.  1\n2\n3\n4\n5\n6 /*  * Not a good style  */  /*   * Good style   */      Class modifier appears in the following order:  1 public   protected   private   abstract   default   static   final   transient   volatile   synchronized   native   strictfp    Example: 1 static   public   void   main ( String []   args )   \nis bad. 1 public   static   void   main ( String []   args )   \nis good!    Class names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE.  Type parameters in single capital letter.    Caught exceptions should not be ignored.    Static fields and methods must be accessed with class name.",
            "title": "CS2030 Coding Style"
        },
        {
            "location": "/style/index.html#using-checkstyle",
            "text": "To automatically check for style violation, we use a tool call  checkstyle .  You can copy the files from the directory  ~cs2030/bin/  on host  cs2030-i.comp.nus.edu.sg .  There are only two files:   checkstyle-8.2-all.jar : the Java application for  checkstyle  cs2030_checks.xml : the configuration file   To run,   1 java -jar checkstyle-8.2-all.jar -c cs2030_checks.xml *.java    You can of course change the location of the  jar  and the  xml  files to anywhere you like.  The command above assumes they are in the same folder as the java source files.  Hint: put the command into a  bash  script so that you do not need to type such a long string all the time.",
            "title": "Using checkstyle"
        },
        {
            "location": "/jdk/index.html",
            "text": "Java: Install/Compile/Run\n\n\nJava Development Kit (JDK)\n\n\nThe Java Development Kit, or JDK, is a development environment for building Java applications.  The environment provides a virtual machine to execute compiled Java code (JVM), a collection of classes and libraries, and a set of tools to support development (including a compiler (\njavac\n), a debugger (\njdb\n), an interactive shell (\njshell\n)) etc.\n\n\nThere are several variations of JDK available.  For instance, \nOpenJDK\n is a free and open source version of JDK.  \nGNU\n offers a compiler in Java (\ngcj\n) and Java core libraries in Gnu classpath.\nEclipse offers its own version of Java compiler\n1\n.  These variations are mostly the same, but for the purpose of this module, we will use the \nofficial Oracle version\n.\n\n\nThere are different editions of Java.  The main ones are Java SE (standard edition), Java EE (enterprise edition), and Java ME (micro edition).  We will be using \nJava SE\n.\n\n\nThe latest version of Java SE is Java 9.0.1.\nJava 8 is the earliest version of Java that will work with this module, as many concepts we will cover are only introduced in Java 8.\n\nTo use \njshell\n, however, you need Java 9.\n\n\nInstalling JDK or Java SE 9\n\n\nYou can \ndownload the latest version of Java SE 9\n from Oracle and follow its \ninstallation instructions\n.\n\n\nUsing \napt\n\n\nAn alternative to the Oracle's instructions above, if you are using a Ubuntu-based system, is to use \napt\n.  You can do the following:\n\n\n1\n2\n3\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java9-installer\n\n\n\n\n\n\nThe first line asks \napt\n to add Java's PPA (personal package archive) repository to its database.  The second line updates the local \napt\n database with the available \napt\n packages.  Finally, the last line installs Java 9.\n\n\nCompiling\n\n\nNow that you've installed Java on your machine, here's an example of how you can compile and run some Java code.\n\n\nJava source files\n\n\nCreate a new Java source file and put it in a new folder (e.g. \nCS2030\n).\n\n\n1\n2\n3\n4\n5\nclass\n \nHelloWorld\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Hello, world!\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nBy convention, the file should be named \nHelloWorld.java\n, following the \nUpperCamelCase\n name of the class. At this point, our \nCS2030\n folder only contains that one file.\n\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ ls\nHelloWorld.java\n\n\n\n\n\n\nJava class files\n\n\nWe can go ahead and compile our Java program by running the \njavac HelloWorld.java\n command. This creates the corresponding Java class file, \nHelloWorld.class\n.\n\n\n1\n2\n3\nhappytan@cs2030-i:~[xxx]$ javac HelloWorld.java\nhappytan@cs2030-i:~[xxx]$ ls\nHelloWorld.class HelloWorld.java\n\n\n\n\n\n\nWe can now execute it with \njava HelloWorld\n. Remember to omit the \n.class\n extension when doing this!\n\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ java HelloWorld\nHello, world!\n\n\n\n\n\n\nSuccess! \ud83c\udf89\n\n\n\n\nWhat actually happens under the hood? Is Java an interpreted or compiled language?\n\n\nThis can get a little mind-boggling at first, but this \ndiagram\n summarizes it quite well.\n\n\n\n\n\n\n\n\n\n\n\n\nSee: \nWhat is the difference between javac and the Eclipse compiler?\n\u00a0\n\u21a9",
            "title": "Java"
        },
        {
            "location": "/jdk/index.html#java-installcompilerun",
            "text": "",
            "title": "Java: Install/Compile/Run"
        },
        {
            "location": "/jdk/index.html#java-development-kit-jdk",
            "text": "The Java Development Kit, or JDK, is a development environment for building Java applications.  The environment provides a virtual machine to execute compiled Java code (JVM), a collection of classes and libraries, and a set of tools to support development (including a compiler ( javac ), a debugger ( jdb ), an interactive shell ( jshell )) etc.  There are several variations of JDK available.  For instance,  OpenJDK  is a free and open source version of JDK.   GNU  offers a compiler in Java ( gcj ) and Java core libraries in Gnu classpath.\nEclipse offers its own version of Java compiler 1 .  These variations are mostly the same, but for the purpose of this module, we will use the  official Oracle version .  There are different editions of Java.  The main ones are Java SE (standard edition), Java EE (enterprise edition), and Java ME (micro edition).  We will be using  Java SE .  The latest version of Java SE is Java 9.0.1.\nJava 8 is the earliest version of Java that will work with this module, as many concepts we will cover are only introduced in Java 8. \nTo use  jshell , however, you need Java 9.",
            "title": "Java Development Kit (JDK)"
        },
        {
            "location": "/jdk/index.html#installing-jdk-or-java-se-9",
            "text": "You can  download the latest version of Java SE 9  from Oracle and follow its  installation instructions .",
            "title": "Installing JDK or Java SE 9"
        },
        {
            "location": "/jdk/index.html#using-apt",
            "text": "An alternative to the Oracle's instructions above, if you are using a Ubuntu-based system, is to use  apt .  You can do the following:  1\n2\n3 sudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java9-installer   The first line asks  apt  to add Java's PPA (personal package archive) repository to its database.  The second line updates the local  apt  database with the available  apt  packages.  Finally, the last line installs Java 9.",
            "title": "Using apt"
        },
        {
            "location": "/jdk/index.html#compiling",
            "text": "Now that you've installed Java on your machine, here's an example of how you can compile and run some Java code.",
            "title": "Compiling"
        },
        {
            "location": "/jdk/index.html#java-source-files",
            "text": "Create a new Java source file and put it in a new folder (e.g.  CS2030 ).  1\n2\n3\n4\n5 class   HelloWorld   { \n   public   static   void   main ( String []   args )   { \n     System . out . println ( \"Hello, world!\" ); \n   }  }    By convention, the file should be named  HelloWorld.java , following the  UpperCamelCase  name of the class. At this point, our  CS2030  folder only contains that one file.  1\n2 happytan@cs2030-i:~[xxx]$ ls\nHelloWorld.java",
            "title": "Java source files"
        },
        {
            "location": "/jdk/index.html#java-class-files",
            "text": "We can go ahead and compile our Java program by running the  javac HelloWorld.java  command. This creates the corresponding Java class file,  HelloWorld.class .  1\n2\n3 happytan@cs2030-i:~[xxx]$ javac HelloWorld.java\nhappytan@cs2030-i:~[xxx]$ ls\nHelloWorld.class HelloWorld.java   We can now execute it with  java HelloWorld . Remember to omit the  .class  extension when doing this!  1\n2 happytan@cs2030-i:~[xxx]$ java HelloWorld\nHello, world!   Success! \ud83c\udf89   What actually happens under the hood? Is Java an interpreted or compiled language?  This can get a little mind-boggling at first, but this  diagram  summarizes it quite well.       See:  What is the difference between javac and the Eclipse compiler? \u00a0 \u21a9",
            "title": "Java class files"
        },
        {
            "location": "/javadoc/index.html",
            "text": "Javadoc\n\n\nWhy is documentation important\n\n\nOne of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to get you to document your code.\n\n\njavadoc\n is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The \nJava SE 8 API\n that you have seen are generated from \njavadoc\n.\n\n\nHow to comment for javadoc\n\n\njavadoc\n distinguishes between normal comments and comments meant for \njavadoc\n by how we \"fence\" the comments.  A \njavadoc\n comments always starts with \n/**\n (not the double asterisks) and ends with \n*/\n and are always placed \nimmediately\n before a class, an interface, a constructor, a method, or field declaration.\n\n\nExample:\n\n1\n2\n3\n4\n5\n/** \n\n\n * Encapsulates a circle on a 2D plane.  The `Circle` class supports operators \n\n\n * supported includes (i) checking if a point is contained in the circle,\n\n\n * and (ii) moving the circle around to a new position.\n\n\n */\n\n\n\n\n\n\nThe first sentence is the summary sentence.  We should follow some style guideline when writing the summary sentence (see below).\n\n\njavadoc\n comments supports HTML tags.  If you are not familiar with HTML, \nthat is fine.  We will tell you what you need to know below.\n\n\nTags\n\n\njavadoc\n supports tags.  Here are some tags that we would like you to use:\n\n\n\n\n@param <name> <description>\n: describe the parameter \n\n\n@return <description>\n describe the return value\n\n\n@throws <class name> <description>\n describe what the exception \n being thrown and what are the possible reasons\n\n\n\n\nSee Lab 1 and Lab 2 skeleton code for samples.\n\n\nStyle\n\n\n\n\n\n\nIf you want to break your comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag \n<p>\n with no space after, and end your paragraph with HTML tag \n</p>\n.\n\n\n\n\n\n\nYou should use the tags \n@param\n \n@return\n and \n@throws\n in that order, and they should never appear without a description.\n\n\n\n\n\n\nThe summary should be short and succint.  It is not a complete sentence, however, but should still be capitalized and ends with a period.  E.g., \n/** Encapsulates a circle on 2D plane. .. */\n\n\n\n\n\n\nYou don't get to write \njavadoc\n for self-explanatory, simple, obvious, methods.  e.g., \ngetX()\n, unless you want to explain what \nx\n means.  \n\n\n\n\n\n\nHow to generate javadoc\n\n\nIn its simplest form, you can generate \njavadoc\n like this:\n\n\n1\njavadoc *.java\n\n\n\n\n\n\nThis will generate the HTML files in your current directory.  \n\n\nTo avoid clutters, I recommend that you specify the output directory, e.g.,\n\n\n1\njavadoc *.java -d docs\n\n\n\n\n\n\nThis will generate the documentations and put it under the \ndocs\n subdirectory.\n\n\njavadoc\n by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run\n\n1\njavadoc *.java -d docs -private\n\n\n\n\n\nHow to view generate javadoc\n\n\nIf you generate the documentation on your computer, you can view it by opening up the file \nindex.html\n in your browser.\n\n\nIf you generate the documentation on \ncs2030-i.comp.nus.edu.sg\n, then, you can create under your \npublic_html\n directory (your home page, so to say).\n\n\n1\njavadoc -private -d ~/public_html/lab03 *.java\n\n\n\n\n\n\nYou can then view the documents on your computer through the URL\n\n\n1\nhttps://cs2030-i.comp.nus.edu.sg/~<username>/lab03\n\n\n\n\n\n\n(replace \n<username>\n with your username on \ncs2030-i\n.  The content is password protected and is only visible to you.  (If the website said that the certificate is invalid and website is not secure, please ignore the warning for now).\n\n\nSee Also\n\n\n\n\nOracle's \njavadoc\n Manual\n for a detailed \njavadoc\n guide",
            "title": "Javadoc"
        },
        {
            "location": "/javadoc/index.html#javadoc",
            "text": "",
            "title": "Javadoc"
        },
        {
            "location": "/javadoc/index.html#why-is-documentation-important",
            "text": "One of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to get you to document your code.  javadoc  is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The  Java SE 8 API  that you have seen are generated from  javadoc .",
            "title": "Why is documentation important"
        },
        {
            "location": "/javadoc/index.html#how-to-comment-for-javadoc",
            "text": "javadoc  distinguishes between normal comments and comments meant for  javadoc  by how we \"fence\" the comments.  A  javadoc  comments always starts with  /**  (not the double asterisks) and ends with  */  and are always placed  immediately  before a class, an interface, a constructor, a method, or field declaration.  Example: 1\n2\n3\n4\n5 /**    * Encapsulates a circle on a 2D plane.  The `Circle` class supports operators    * supported includes (i) checking if a point is contained in the circle,   * and (ii) moving the circle around to a new position.   */    The first sentence is the summary sentence.  We should follow some style guideline when writing the summary sentence (see below).  javadoc  comments supports HTML tags.  If you are not familiar with HTML, \nthat is fine.  We will tell you what you need to know below.",
            "title": "How to comment for javadoc"
        },
        {
            "location": "/javadoc/index.html#tags",
            "text": "javadoc  supports tags.  Here are some tags that we would like you to use:   @param <name> <description> : describe the parameter   @return <description>  describe the return value  @throws <class name> <description>  describe what the exception   being thrown and what are the possible reasons   See Lab 1 and Lab 2 skeleton code for samples.",
            "title": "Tags"
        },
        {
            "location": "/javadoc/index.html#style",
            "text": "If you want to break your comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag  <p>  with no space after, and end your paragraph with HTML tag  </p> .    You should use the tags  @param   @return  and  @throws  in that order, and they should never appear without a description.    The summary should be short and succint.  It is not a complete sentence, however, but should still be capitalized and ends with a period.  E.g.,  /** Encapsulates a circle on 2D plane. .. */    You don't get to write  javadoc  for self-explanatory, simple, obvious, methods.  e.g.,  getX() , unless you want to explain what  x  means.",
            "title": "Style"
        },
        {
            "location": "/javadoc/index.html#how-to-generate-javadoc",
            "text": "In its simplest form, you can generate  javadoc  like this:  1 javadoc *.java   This will generate the HTML files in your current directory.    To avoid clutters, I recommend that you specify the output directory, e.g.,  1 javadoc *.java -d docs   This will generate the documentations and put it under the  docs  subdirectory.  javadoc  by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run 1 javadoc *.java -d docs -private",
            "title": "How to generate javadoc"
        },
        {
            "location": "/javadoc/index.html#how-to-view-generate-javadoc",
            "text": "If you generate the documentation on your computer, you can view it by opening up the file  index.html  in your browser.  If you generate the documentation on  cs2030-i.comp.nus.edu.sg , then, you can create under your  public_html  directory (your home page, so to say).  1 javadoc -private -d ~/public_html/lab03 *.java   You can then view the documents on your computer through the URL  1 https://cs2030-i.comp.nus.edu.sg/~<username>/lab03   (replace  <username>  with your username on  cs2030-i .  The content is password protected and is only visible to you.  (If the website said that the certificate is invalid and website is not secure, please ignore the warning for now).",
            "title": "How to view generate javadoc"
        },
        {
            "location": "/javadoc/index.html#see-also",
            "text": "Oracle's  javadoc  Manual  for a detailed  javadoc  guide",
            "title": "See Also"
        },
        {
            "location": "/unix/index.html",
            "text": "Accessing CS2030 Lab Programming Environment\n\n\nThe Environment\n\n\nThe school has created a VM (virtual machine) for CS2030, with hostname \ncs2030-i.comp.nus.edu.sg\n.  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.\n\n\nI have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.\n\n\nSSH\n\n\nFor UNIX-based OS\n\n\nIf you use either macOS, Windows 10 (requires \nLinux Subsystem on Windows\n), or Linux, you should have the command line \nssh\n installed.  \n\n\nRun:\n\n1\nssh <username>@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on screen.  The first time you ever connect to \ncs2030-i.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nFor Windows 7 or 8 (or Windows 10 without Linux Subsystem)\n\n\nThe desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use programs like \nPuTTY\n to access the VM.\n\n\nAccessing \ncs2030-i\n from Outside SoC\n\n\nTHe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways\n\n\nUsing SoC VPN\n\n\nOne way is to setup a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the CS2030 VM that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favourite SSH client.  After logging in, run the command \nssh cs2030-i\n to connect to the CS2030 VM.  This effectively starts an SSH session to the VM from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to commect to the CS2030 VM.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (\ncs2030-i\n).  This method causes the CS2030 VM to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n2030\n, allowing you to use your favourite SCP program (e.g. \nFileZilla\n) to access the VM.\n\n\nTo use local port forwarding (from local port \n2030\n), connect to \nsunfire\n using \n\n1\nssh -L 2030:cs2030-i.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n2030\n of your machine to port \n22\n (the default SSH port) of \ncs2030-i.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n:\n2030\n to access the VM.\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nBasic UNIX Commands\n\n\nOnce you logged into the VM, you will be prompted to enter a command with a prompt that looks like this:\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\nThis interface is provided by a UNIX shell -- not unlike \njshell\n, this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is \nbash\n1\n.\n\n\nThe following is adapted for CS2030 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.\n\n\nIn the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or \nsunfire\n or \ncs2030-i\n) prompt of the form\n\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory, \nxxx\n is a number indicating the number of commands that have been entered.  The following examples assumes that user \nhappytan\n is logged into cs2030-i; however you can do it on your local UNIX platform too.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nhappytan\n resides in the directory tree. The user \nhappytan\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\nDirectory commands\n\n\n\n\n\n\npwd\n: Print current Working Directory to show you which directory you are currently in\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan\n\n\n\n\n\n\n\n\n\nls\n: LiSt files in your current directory\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.  \n\n\n\n\n\n\n\n\nRule of Silence\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\n\n\n\n\n\n\nmkdir\n: MaKe a subDIRectory in current directory\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\nHere, you create a directory called \nlab01\n.  Now, when you \nls\n, you can see the directory listed.\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\n\n\n\n\nCommand history\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\n\n\n\n\ncd\n: Change Directory from current directory to another\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\nNote that the prompt changes to \n~/lab01\n to indicate that you are now in the \nlab01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e.,. the directory in which you started with when you first logged into the system.\n\n1\n2\nhappytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n\n\n\nrmdir\n:  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\n\n\n\n\n\nFile commands\n\n\n\n\ncp\n:  CoPy files\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java\n\n\n\n\nThe command above copy the files Circle.java from the HOME of user \ncs2030\n, under directory \nlab01\n, to the current directory.\n\n\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .\n\n\n\n\n\n\nThe directory \nlab01\n and everything under it will be copied.\n\n\n\n\nmv\n: MoVe files from one directory to another; can also be used to rename files.\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java\n\n\n\n\n\n\n\n\n\nFilename completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ mv C\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\n\n\n\n\n\n\nrm\n: ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle).\n\n1\n2\n3\n4\nhappytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\n\n\n\nCommand to display text files\n\n\n\n\ncat\n: to string together or display (CATenate) the contents of files onto the screen\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cat Circle.java\n\n\n\n\n\nless\n - variant of \ncat\n (includes features to read each page leisurely)\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ less Circle.java\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit from \"less\".\n\n\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.\n\n\nUNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n1\nchmod g-rw <file>\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n1\nchmod a+x <file>\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n1\nchmod 444 <file>\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n1\nchmod 600 <file>\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nSecure Copy (\nscp\n)\n\n\nSecure copy, or \nscp\n, is one way to transfer files from your local computer to \ncs2030-i\n.  If you choose not to use \nemacs\n or \nvim\n2\n and write your code on \ncs2030-i\n, you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory \ntest\n that you have created, do the following:\n\n\n1\nscp *.java happytan@cs2030-i:~/test\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.java\n is a regular expression that means all files with filename ending with \n.java\n.  You can copy specific files as well.  For instance,\n\n\n1\nscp Circle.java Point.java happytan@cs2030-i:~/test\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on VM \ncs2030-i\n.  On \ncs2030-i\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on VM is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.  \n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9\n\n\n\n\n\n\nMy personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#accessing-cs2030-lab-programming-environment",
            "text": "",
            "title": "Accessing CS2030 Lab Programming Environment"
        },
        {
            "location": "/unix/index.html#the-environment",
            "text": "The school has created a VM (virtual machine) for CS2030, with hostname  cs2030-i.comp.nus.edu.sg .  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.  I have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.",
            "title": "The Environment"
        },
        {
            "location": "/unix/index.html#ssh",
            "text": "",
            "title": "SSH"
        },
        {
            "location": "/unix/index.html#for-unix-based-os",
            "text": "If you use either macOS, Windows 10 (requires  Linux Subsystem on Windows ), or Linux, you should have the command line  ssh  installed.    Run: 1 ssh <username>@cs2030-i.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@cs2030-i.comp.nus.edu.sg   After the command above, following the instructions on screen.  The first time you ever connect to  cs2030-i.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "For UNIX-based OS"
        },
        {
            "location": "/unix/index.html#for-windows-7-or-8-or-windows-10-without-linux-subsystem",
            "text": "The desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use programs like  PuTTY  to access the VM.",
            "title": "For Windows 7 or 8 (or Windows 10 without Linux Subsystem)"
        },
        {
            "location": "/unix/index.html#accessing-cs2030-i-from-outside-soc",
            "text": "THe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways",
            "title": "Accessing cs2030-i from Outside SoC"
        },
        {
            "location": "/unix/index.html#using-soc-vpn",
            "text": "One way is to setup a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/unix/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the CS2030 VM that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/unix/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favourite SSH client.  After logging in, run the command  ssh cs2030-i  to connect to the CS2030 VM.  This effectively starts an SSH session to the VM from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/unix/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to commect to the CS2030 VM.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server ( cs2030-i ).  This method causes the CS2030 VM to seem as if it is hosted on a local port, e.g.  localhost : 2030 , allowing you to use your favourite SCP program (e.g.  FileZilla ) to access the VM.  To use local port forwarding (from local port  2030 ), connect to  sunfire  using  1 ssh -L 2030:cs2030-i.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  2030  of your machine to port  22  (the default SSH port) of  cs2030-i.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost : 2030  to access the VM.  PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "Once you logged into the VM, you will be prompted to enter a command with a prompt that looks like this: 1 happytan@cs2030-i:~[xxx]$  \nThis interface is provided by a UNIX shell -- not unlike  jshell , this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is  bash 1 .  The following is adapted for CS2030 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.  In the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or  sunfire  or  cs2030-i ) prompt of the form  1 happytan@cs2030-i:~[xxx]$   ~  indicates that you are currently in your home directory,  xxx  is a number indicating the number of commands that have been entered.  The following examples assumes that user  happytan  is logged into cs2030-i; however you can do it on your local UNIX platform too.  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  happytan  resides in the directory tree. The user  happytan  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#directory-commands",
            "text": "pwd : Print current Working Directory to show you which directory you are currently in 1\n2 happytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan     ls : LiSt files in your current directory 1\n2 happytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$  \n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.       Rule of Silence UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")      mkdir : MaKe a subDIRectory in current directory 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/  \nHere, you create a directory called  lab01 .  Now, when you  ls , you can see the directory listed.\nYou may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.     Command history  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.     cd : Change Directory from current directory to another 1\n2 happytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$  \nNote that the prompt changes to  ~/lab01  to indicate that you are now in the  lab01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e.,. the directory in which you started with when you first logged into the system. 1\n2 happytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$     rmdir :  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/",
            "title": "Directory commands"
        },
        {
            "location": "/unix/index.html#file-commands",
            "text": "cp :  CoPy files 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java  \nThe command above copy the files Circle.java from the HOME of user  cs2030 , under directory  lab01 , to the current directory.   If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 happytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .   The directory  lab01  and everything under it will be copied.   mv : MoVe files from one directory to another; can also be used to rename files. 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java     Filename completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 happytan@cs2030-i:~/lab01[xxx]$ mv C  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.    rm : ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle). 1\n2\n3\n4 happytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$",
            "title": "File commands"
        },
        {
            "location": "/unix/index.html#command-to-display-text-files",
            "text": "cat : to string together or display (CATenate) the contents of files onto the screen 1 happytan@cs2030-i:~/lab01[xxx]$ cat Circle.java   less  - variant of  cat  (includes features to read each page leisurely) 1 happytan@cs2030-i:~/lab01[xxx]$ less Circle.java  \nIn  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit from \"less\".   An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.",
            "title": "Command to display text files"
        },
        {
            "location": "/unix/index.html#unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run: 1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run: 1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx , or from  -rwxr--r--  to  -rwx--xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run: 1 chmod 444 <file>   To set the permission to  -rw------- , run: 1 chmod 600 <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "UNIX File Permission"
        },
        {
            "location": "/unix/index.html#secure-copy-scp",
            "text": "Secure copy, or  scp , is one way to transfer files from your local computer to  cs2030-i .  If you choose not to use  emacs  or  vim 2  and write your code on  cs2030-i , you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory  test  that you have created, do the following:  1 scp *.java happytan@cs2030-i:~/test    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.java  is a regular expression that means all files with filename ending with  .java .  You can copy specific files as well.  For instance,  1 scp Circle.java Point.java happytan@cs2030-i:~/test   scp  supports  -r  (recursive copy) as well.",
            "title": "Secure Copy (scp)"
        },
        {
            "location": "/unix/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on VM  cs2030-i .  On  cs2030-i , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on VM is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .        I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9    My personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0 \u21a9",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/vim/index.html",
            "text": "Vim Tips\n\n\nI collected below some tips on \nvim\n that I find helpful.\n\n\nConfiguration\n\n\nYou can configure your \nvim\n by putting your configuration options and scripts in the \n~/.vimrc\n file (a hidden file named \n.vimrc\n in your home directory).  This file will be loaded whenever you starts \nvim\n.\n\n\nHelp\n\n\nIn \nvim,\n the command \n:help <topic>\n shows help about a particular topic in \nvim\n.  Example, \n:help backup\n.\n\n\nBackup Files\n\n\nYou can ask \nvim\n to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.\n\n\nIn your \n~/.vimrc\n file, \n\n\n1\nset backup=on\n\n\n\n\n\n\nwill cause a copy of your file to be save with suffix \n~\n appended to its name everytime you save.\n\n\nI prefer not to clutter my working directory, so I set\n\n\n1\nset backupdir=~/.backup\n\n\n\n\n\n\nand create a directory named \n~/.backup\n to store my backup files.\n\n\nThe settings above are the default in your \ncs2030-i\n account.  So if you made changes to a file that you regreted on \ncs2030-i\n, or if accidentally deleted a file, you can check under \n~/.backup\n to see if the backup can save you.\n\n\nUndo\n\n\nSince we are on the topic of correcting mistakes, \nu\n in command mode undo your changes.  Prefix it with a number \nn\nn\n to undo \nn\nn\n times.  If you regreted your undo, \n<CTRL-R>\n will redo.\n\n\nSyntax Highlighting\n\n\nIf for some reasons, syntax highlighting is not on by default, add this to your \n~/.vimrc\n:\n\n\n1\nsyntax on\n\n\n\n\n\n\nRuler and Numbers\n\n\nIf you prefer to show the line number you are on and the column number you are on, adding the commands to \n~/.vimrc\n\n\n1\nset ruler\n\n\n\n\n\n\nwill display the line number and the column number on the lower right corner.  \n\n\nYou can also add\n\n1\nset number\n\n\n\n\n\nto label each line with a line number.\n\n\nJumping to a Line\n\n\nIf the compiler tells you there is an error on Line \nx\nx\n, you can issue \n:<x>\n to jump to Line \nx\nx\n.  For instance, \n:40\n will go to Line 40.\n\n\nNavigation\n\n\n\n\nw\n   jump to the beginning of the next word\n\n\nb\n   jump to the beginning of the previous word (reverse of \nw\n)\n\n\ne\n   jump to the end of the word (or next word when pressed again)\n\n\nf\n + char: search forward in the line and sit on the next matching char\n\n\nt\n + char:  search forward in the line and sit on one space before the matching char\n\n\n<CTRL-d>\n jump forward half page\n\n\n<CTRL-u>\n jump backward half page\n\n\n$\n jump to end of line\n\n\n0\n jump to the beginning of the line\n\n\n%\n jump between matching parentheses\n\n\n\n\nNavigation + Editing\n\n\nvim\n is powerful because you can combine \noperations\n with \nnavigation\n.  For instance \nc\n to change, \nd\n to delete, \ny\n to yank (copy).  Since \nw\n is the navigation command to move over the current word, combining them we get:\n\n\n\n\ncw\n change the current word (delete the current word and enter insert mode)\n\n\ndw\n delete the current word\n\n\nyw\n yank the current word (copy word into buffer)\n\n\n\n\nCan you guess what \ndf)\n, \ndt)\n, \nc$\n, \ny0\n do?\n\n\nIf you repeat the operation \nc\n, \nd\n, and \ny\n, it applies to the whole line, so:\n\n\n\n\ncc\n change the whole line\n\n\ndd\n delete the whole line\n\n\nyy\n yank the whole line\n\n\n\n\nYou can add a number before an operation to specify how many times you want to repeat an operation.  So \n5dd\n deletes 5 lines, \n5dw\n deletes 5 words, etc.\n\n\nSee the article \nOperator, the True Power of \nVim\n for more details.\n\n\nOther Editing Operations\n\n\n\n\nA\n jump to end of line and enter insert mode\n\n\no\n open next line and enter insert mode\n\n\nO\n open previous line and enter insert mode\n\n\n\n\nSearch and Replace in \nvim\n\n\n1\n:%s/oldWord/newWord/gc \n\n\n\n\n\n\n:\n enters the command mode.  \n%\n means apply to the whole document, \ns\n means substitute, \ng\n means global (otherwise, only the first occurance of each line is replaced). \nc\n is optional -- adding it cause \nvim\n to confirm with you before each replacement  \n\n\nCommenting blocks of code\n\n\nSometimes we need to comment out a whole block of code in Java for testing purposes. There are several ways to do it in \nvim\n:\n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter visual block mode\n\n\nUse arrow key to select the block of code you want to comment. \n\n\nI\n to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)\n\n\n//\n to insert the Java comment character (you will see it inserted in the current line, but don't worry)\n\n\n<ESC> <ESC>\n to escape from the visual code and to insert the comment character for the rest of the lines.\n\n\n\n\nTo uncomment, \n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter block visual mode\n\n\nUse arrow key to select the columns of text containing \n//\n\n\nx\n to delete them\n\n\n\n\nShell Command\n\n\nIf you need to issue a shell command quickly, you don't have to exit \nvim\n, run the command, and launch \nvim\n again.  You can use \n!\n, \n\n\n1\n:!<command>\n\n\n\n\n\n\nwill issue the command to shell.  E.g.,\n\n\n1\n:!ls\n\n\n\n\n\n\nYou can use this to compile your current file, without exiting \nvim\n.\n\n\n1\n:!javac %\n\n\n\n\n\n\nAbbreviation\n\n\nYou can use the command \nab\n to abbreviate frequently typed commands.  E.g., in your \n~/.vimrc\n, \n\n\n1\nab Sop System.out.println(\"\n\n\n\n\n\n\nNow, when you type \nSop\n, it will be expanded into \nSystem.out.println(\"\n\n\nAuto-Completion\n\n\nYou can \n<CTRL-P>\n to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.\n\n\nAuto-Indent the Whole File\n\n\nYou can \ngg=G\n in command mode to auto-indent the whole file.  \ngg\n is the command to go to the beginning of the file.  \n=\n is the command to indent.  \nG\n is the command to go to the end of the file.\n\n\nSwapping Lines\n\n\nSometimes you want to swap the order of two lines of code, in command mode, \nddp\n will do the trick.  \ndd\n deletes the current line, \np\n paste it after the current line, in effect swapping the order of the two lines.\n\n\nGoto File\n\n\nPlace your cursor on the name of a class (e.g., \nEvent\n), then in command mode, issue the \ngf\n command (goto file).  \nvim\n will open \nEvent.java\n.  You can set the \npath\n to load files from directories other than the current directory.   \"Ctrl-^\" will get out and back to the previous file.\n\n\nSyntax and Style Checker\n\n\nI use \nsyntastic\n to check for style and syntax whenever I save a file.  \nsyntastic\n is a \nvim\n plugin. \n\n\nMy \n.vimrc\n configuration file contains the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n\"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\nlet g:syntastic_java_checkers = [ \"checkstyle\", \"javac\" ]\nlet g:syntastic_java_checkstyle_classpath = \"~cs2030/bin/checkstyle-8.2-all.jar\"\nlet g:syntastic_java_checkstyle_conf_file = \"~cs2030/bin/cs2030_checks.xml\"\n\n\n\n\n\n\nThe last two lines refer to \ncheckstyle\n tool and its configuration file available from \n~cs2030/bin\n on the host \ncs2030-i.comp.nus.edu.sg\n.\n\n\nSplitting \nvim\n's Viewport\n\n\n\n\n:sp file.java\n splits the \nvim\n window horizontally\n\n\n:vsp file.java\n splits the \nvim\n window vertically\n\n\nCtrl-w Ctrl-w\n moves between the different \nvim\n viewports",
            "title": "Vim"
        },
        {
            "location": "/vim/index.html#vim-tips",
            "text": "I collected below some tips on  vim  that I find helpful.",
            "title": "Vim Tips"
        },
        {
            "location": "/vim/index.html#configuration",
            "text": "You can configure your  vim  by putting your configuration options and scripts in the  ~/.vimrc  file (a hidden file named  .vimrc  in your home directory).  This file will be loaded whenever you starts  vim .",
            "title": "Configuration"
        },
        {
            "location": "/vim/index.html#help",
            "text": "In  vim,  the command  :help <topic>  shows help about a particular topic in  vim .  Example,  :help backup .",
            "title": "Help"
        },
        {
            "location": "/vim/index.html#backup-files",
            "text": "You can ask  vim  to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.  In your  ~/.vimrc  file,   1 set backup=on   will cause a copy of your file to be save with suffix  ~  appended to its name everytime you save.  I prefer not to clutter my working directory, so I set  1 set backupdir=~/.backup   and create a directory named  ~/.backup  to store my backup files.  The settings above are the default in your  cs2030-i  account.  So if you made changes to a file that you regreted on  cs2030-i , or if accidentally deleted a file, you can check under  ~/.backup  to see if the backup can save you.",
            "title": "Backup Files"
        },
        {
            "location": "/vim/index.html#undo",
            "text": "Since we are on the topic of correcting mistakes,  u  in command mode undo your changes.  Prefix it with a number  n n  to undo  n n  times.  If you regreted your undo,  <CTRL-R>  will redo.",
            "title": "Undo"
        },
        {
            "location": "/vim/index.html#syntax-highlighting",
            "text": "If for some reasons, syntax highlighting is not on by default, add this to your  ~/.vimrc :  1 syntax on",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/vim/index.html#ruler-and-numbers",
            "text": "If you prefer to show the line number you are on and the column number you are on, adding the commands to  ~/.vimrc  1 set ruler   will display the line number and the column number on the lower right corner.    You can also add 1 set number   to label each line with a line number.",
            "title": "Ruler and Numbers"
        },
        {
            "location": "/vim/index.html#jumping-to-a-line",
            "text": "If the compiler tells you there is an error on Line  x x , you can issue  :<x>  to jump to Line  x x .  For instance,  :40  will go to Line 40.",
            "title": "Jumping to a Line"
        },
        {
            "location": "/vim/index.html#navigation",
            "text": "w    jump to the beginning of the next word  b    jump to the beginning of the previous word (reverse of  w )  e    jump to the end of the word (or next word when pressed again)  f  + char: search forward in the line and sit on the next matching char  t  + char:  search forward in the line and sit on one space before the matching char  <CTRL-d>  jump forward half page  <CTRL-u>  jump backward half page  $  jump to end of line  0  jump to the beginning of the line  %  jump between matching parentheses",
            "title": "Navigation"
        },
        {
            "location": "/vim/index.html#navigation-editing",
            "text": "vim  is powerful because you can combine  operations  with  navigation .  For instance  c  to change,  d  to delete,  y  to yank (copy).  Since  w  is the navigation command to move over the current word, combining them we get:   cw  change the current word (delete the current word and enter insert mode)  dw  delete the current word  yw  yank the current word (copy word into buffer)   Can you guess what  df) ,  dt) ,  c$ ,  y0  do?  If you repeat the operation  c ,  d , and  y , it applies to the whole line, so:   cc  change the whole line  dd  delete the whole line  yy  yank the whole line   You can add a number before an operation to specify how many times you want to repeat an operation.  So  5dd  deletes 5 lines,  5dw  deletes 5 words, etc.  See the article  Operator, the True Power of  Vim  for more details.",
            "title": "Navigation + Editing"
        },
        {
            "location": "/vim/index.html#other-editing-operations",
            "text": "A  jump to end of line and enter insert mode  o  open next line and enter insert mode  O  open previous line and enter insert mode",
            "title": "Other Editing Operations"
        },
        {
            "location": "/vim/index.html#search-and-replace-in-vim",
            "text": "1 :%s/oldWord/newWord/gc    :  enters the command mode.   %  means apply to the whole document,  s  means substitute,  g  means global (otherwise, only the first occurance of each line is replaced).  c  is optional -- adding it cause  vim  to confirm with you before each replacement",
            "title": "Search and Replace in vim"
        },
        {
            "location": "/vim/index.html#commenting-blocks-of-code",
            "text": "Sometimes we need to comment out a whole block of code in Java for testing purposes. There are several ways to do it in  vim :   Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter visual block mode  Use arrow key to select the block of code you want to comment.   I  to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)  //  to insert the Java comment character (you will see it inserted in the current line, but don't worry)  <ESC> <ESC>  to escape from the visual code and to insert the comment character for the rest of the lines.   To uncomment,    Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter block visual mode  Use arrow key to select the columns of text containing  //  x  to delete them",
            "title": "Commenting blocks of code"
        },
        {
            "location": "/vim/index.html#shell-command",
            "text": "If you need to issue a shell command quickly, you don't have to exit  vim , run the command, and launch  vim  again.  You can use  ! ,   1 :!<command>   will issue the command to shell.  E.g.,  1 :!ls   You can use this to compile your current file, without exiting  vim .  1 :!javac %",
            "title": "Shell Command"
        },
        {
            "location": "/vim/index.html#abbreviation",
            "text": "You can use the command  ab  to abbreviate frequently typed commands.  E.g., in your  ~/.vimrc ,   1 ab Sop System.out.println(\"   Now, when you type  Sop , it will be expanded into  System.out.println(\"",
            "title": "Abbreviation"
        },
        {
            "location": "/vim/index.html#auto-completion",
            "text": "You can  <CTRL-P>  to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.",
            "title": "Auto-Completion"
        },
        {
            "location": "/vim/index.html#auto-indent-the-whole-file",
            "text": "You can  gg=G  in command mode to auto-indent the whole file.   gg  is the command to go to the beginning of the file.   =  is the command to indent.   G  is the command to go to the end of the file.",
            "title": "Auto-Indent the Whole File"
        },
        {
            "location": "/vim/index.html#swapping-lines",
            "text": "Sometimes you want to swap the order of two lines of code, in command mode,  ddp  will do the trick.   dd  deletes the current line,  p  paste it after the current line, in effect swapping the order of the two lines.",
            "title": "Swapping Lines"
        },
        {
            "location": "/vim/index.html#goto-file",
            "text": "Place your cursor on the name of a class (e.g.,  Event ), then in command mode, issue the  gf  command (goto file).   vim  will open  Event.java .  You can set the  path  to load files from directories other than the current directory.   \"Ctrl-^\" will get out and back to the previous file.",
            "title": "Goto File"
        },
        {
            "location": "/vim/index.html#syntax-and-style-checker",
            "text": "I use  syntastic  to check for style and syntax whenever I save a file.   syntastic  is a  vim  plugin.   My  .vimrc  configuration file contains the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 \"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\nlet g:syntastic_java_checkers = [ \"checkstyle\", \"javac\" ]\nlet g:syntastic_java_checkstyle_classpath = \"~cs2030/bin/checkstyle-8.2-all.jar\"\nlet g:syntastic_java_checkstyle_conf_file = \"~cs2030/bin/cs2030_checks.xml\"   The last two lines refer to  checkstyle  tool and its configuration file available from  ~cs2030/bin  on the host  cs2030-i.comp.nus.edu.sg .",
            "title": "Syntax and Style Checker"
        },
        {
            "location": "/vim/index.html#splitting-vims-viewport",
            "text": ":sp file.java  splits the  vim  window horizontally  :vsp file.java  splits the  vim  window vertically  Ctrl-w Ctrl-w  moves between the different  vim  viewports",
            "title": "Splitting vim's Viewport"
        }
    ]
}